<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git基本操作]]></title>
    <url>%2F2019%2F10%2F21%2Fgit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. Git安装 git仓储有三个区：工作区、暂存区、版本库。 2. 初始化Git仓储/(仓库) 这个仓库会存放，git对我们项目代码进行备份的文件。 在项目目录右键打开 git bash。 命令：git init 3. 自报家门 就是在git中设置当前使用的用户是谁。 命令： 配置用户名：git config --global user.name &quot;你的的用户名&quot; 配置邮箱：git config --global user.email &quot;你的邮箱&quot; 4. 把代码存储到.git仓储中 1.把代码放到仓储的门口。 git add ./文件名 2.把仓储门口的代码放到里面的房间中去。 git commit -m &quot;对这次添加内容的说明&quot; 也可以一次性把修改的代码放到房间里(版本库)。 git add ./ git commit --all &quot;说明&quot; –all 表示把所有修改的文件提交到版本库。 5. 查看当前的状态 命令：git status 可以用来查看当前代码有没有被放到仓储中去。 一共有三种状态： 红色：工作区的代码没有放入暂存区，更没有到版本库中。 绿色：工作区的代码放入了暂存区，还没有保存到版本库。 工作区干净 (版本库保存的代码与工作区的代码一致)。 6. git中的忽略文件 .gitignore,在这个文件中可以设置要被忽略的文件或者目录。 被忽略的文件不会被提交到仓储里去。 在.gitignore中可以书写要被忽略的文件的路径。以/开头，一行写一个路径，这些路径所对应的文件都会被忽略，不会被提交到仓储中去。 写法： /.idea 会忽略.idea文件 /js 会忽略js目录里的所有文件 /js/*.js 会忽略js目录下的所有js文件 7. 查看日志 git log 查看历史提交的日志。 git log --oneline 可以看到简洁版的历史提交日志 就是查看提交过的历史（每一次提交的东西都会被git备份）。 8. 回退到指定的版本 git reset --hard Head~0 表示回退到上一次代码提交时的状态。 git reset --hard Head~1 表示回退到上上次代码提交时的状态。 git reset --hard [版本号] 可以通过版本号精确的回退到某一次提交时的状态。 需要先查看日志，然后看每一个日志前面的版本号(每个版本号都是唯一的)。 git reflog 可以看到每一次切换版本的记录：可以看到所有提交的版本号。 9. 分支 默认是有一个主分支 master。 9.1 创建分支 git branch dev 创建了一个dev分支。 在刚创建的dev分支里的东西和master分支里的东西是一样的。 9.2 切换分支 git checkout dev 切换到指定的分支，这里切换到名为dev的分支。 git branch 可以查看当前所在的分支。 9.3 合并分支 git merge dev 合并分支内容，把当前分支与指定的分支(dev)，进行合并。 当前分支是指 git branch 命令输出的前面有*号的分支 合并时如果有冲突，需要手动去处理，处理还需要再提交一次。 手动处理：git会自动合并冲突，然后需要自己去那个文件里面看哪个内容需要就留下，不需要的就手动从文件内容里面删除，然后再存储 10. GitHub https://github.com 不是git，只是一个网站 只不过这个网站提供了允许别人通过git上传代码的功能 10.1 github准备工作 在github中新建一个仓库(用来存储项目),仓库新建好之后有一个地址(点击HTTP会显示)，后面内容中的 [地址1] 为这个地址。 ! 用这个地址需要输入账号密码，可能会不安全，也比较麻烦，所以还可以使用密钥。 在github中新建一个密钥，将用git生成的密钥中的公钥文件中的内容添加到github中新建的密钥中。这个密钥也有一个地址(点击SSH会显示)，后面内容中的 [地址2] 为这个地址。 10.1 提交代码到github(当作git服务器来使用) git push [地址1] master 示例：git push https://github.com/huoqishi/test112.git 会把当前分支的内容传到远程的master分支上 git pull [地址1] master 示例：git pull https://github.com/huoqishi/test112.git 会把远程分支(master)的数据得到：(注意本地要初始化一个仓库) git clone [地址1] 会得到远程仓储相同的数据，如果多次执行会覆盖本地内容。 10.2 ssh方式上传代码 公钥、私钥，两者之间是有关联的。 用git生成公钥和私钥： ssh-keygen -t rsa -C &quot;邮箱&quot; 上传代码或者获取数据： git push [地址2] master git pull [地址2] master git clone [地址2] master 10.3 更简洁的上传方式 git remote add origin [地址2] 将地址用一个变量(这里用的origin)代替 git push origin -u master 在push时，加上-u参数，那么再下一次push时，就只需要写git push就能上传代码。 加上-u之后，git会将当前分支与远程的分支进行关联。 上传代码或者获取数据： git push git pull git clone 10.4 在push和pull操作冲突时 先pull,再push。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之面试题]]></title>
    <url>%2F2019%2F10%2F15%2FB-11-CSS3%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. css基本问题 CSS名字：层叠样式表 CSS全拼：Cascading Style Sheets 样式表的组成： – 样式表由 规则 组成 – 规则由 选择器+声明块 组成 – 声明块由 一条一条的 声明 组成 – 声明由 CSS合法的属性名+属性值 组成 浏览器渲染样式表的顺序：从右往左 – 原因：算法的复杂程度低，性能比较高 阐述对CSS选择器优先级的的理解： ！详细说明见 CSS3之选择器 中的3.css声明的优先级。 CSS声明的优先级（CSS选择器的优先级说法是是错误的） 层叠：先按来源进行刷选；如果来源相同，按选择器的特殊性继续刷选；选择器的特殊性如果相同，按顺序继续刷选。 2. 用css做选项卡 用target伪类 代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;!-- css代码： --&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; a &#123; text-decoration: none; color: paleturquoise; &#125; div &#123; background-color:pink; width: 100px; height: 100px; text-align: center; font: bold 20px/100px &quot;微软雅黑&quot;; /* 大小和字体必须写在最后 */ display:none; &#125; :target &#123; display: block; &#125;&lt;/style&gt;&lt;!-- html代码： --&gt;&lt;body&gt; &lt;a href=&quot;#div1&quot;&gt;div1&lt;/a&gt; &lt;a href=&quot;#div2&quot;&gt;div2&lt;/a&gt; &lt;a href=&quot;#div3&quot;&gt;div3&lt;/a&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;&lt;/body&gt; 3. 制作自定义按钮 用表单伪类checked 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- css代码： --&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; label &#123; float: left; &#125; label&gt;span &#123; display: inline-block; width: 100px; height: 100px; background-color: aqua; border-radius: 50%; &#125; input &#123; display: none; &#125; input:checked + span &#123; background-color: pink; &#125; &lt;/style&gt; &lt;!-- html代码： --&gt; &lt;body&gt; &lt;label &gt; &lt;input type=&quot;radio&quot; name=&quot;zi&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label &gt; &lt;input type=&quot;radio&quot; name=&quot;zi&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label &gt; &lt;input type=&quot;radio&quot; name=&quot;zi&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;/body&gt; 4. 导航栏最后一个不加边框 用not伪类 代码如下： 1234567891011121314151617181920212223242526 &lt;!-- css代码： --&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; float: left; padding: 0px 10px; &#125; li:not(:last-of-type) &#123; border-right: 1px solid pink; &#125; &lt;/style&gt; &lt;!-- html代码： --&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;first&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;second&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;third&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;fourth&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;fifth&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B-10-CSS3之新增UI方案]]></title>
    <url>%2F2019%2F10%2F14%2FB-10-CSS3%E4%B9%8B%E6%96%B0%E5%A2%9EUI%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1. 文本新增属性1.1 opacity opacity属性指定了一个元素的透明度。 默认值：1.0 不可继承 1.2 rgba rgba(0,0,0,.8); 应用场景：背景透明文字不透明 1.3 文字阴影 text-shadow用来为文字添加阴影，而且可以添加多层，阴影值之间用逗号隔开。（多个阴影时，第一个阴影在最上边） 默认值：none 不可继承 值： – &lt;color&gt;可选。可以在偏移量之前或之后指定。如果没有指定颜色，则使用UA（用户代理）选择的颜色。 – &lt;offset-x&gt; &lt;offset-y&gt;必选。这些长度值指定阴影相对文字的偏移量。 ！ &lt;offset-x&gt; 指定水平偏移量，若是负值则阴影位于文字左边。 ！ &lt;offset-y&gt; 指定垂直偏移量，若是负值则阴影位于文字上面。 ！ 如果两者均为0，则阴影位于文字正后方(如果设置了&lt;blur- radius&gt; 则会产生模糊效果)。 – &lt;blur-radius&gt;可选。这是 &lt;length&gt; 值。如果没有指定，则默认为0。值越大，模糊半径越大，阴影也就越大越淡。 应用场景： – 浮雕文字 123456h1&#123; text-align: center; font: 100px/200px &quot;微软雅黑&quot;; color: white; text-shadow: black 1px 1px 100px;&#125; – 文字模糊 1234567891011h1&#123; text-align: center; font: 100px/200px &quot;微软雅黑&quot;; color: black; transition: 1s;&#125;h1:hover&#123; color: rgba(0,0,0,0); text-shadow: black 0 0 200px;&#125; – 模糊背景 12345678910111213141516171819202122232425262728&lt;!-- css代码 --&gt;#wrap&#123; height: 100px; background: rgba(0,0,0,.5); position: relative;&#125;#wrap #bg&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; background: url(img/avatar.jpg) no-repeat; background-size:100% 100% ; z-index: -1; filter: blur(10px);&#125;img&#123; margin: 24px 0 0 24px;&#125;&lt;!-- html代码 --&gt;&lt;div id=&quot;wrap&quot;&gt; &lt;img src=&quot;img/avatar.jpg&quot; width=&quot;64px&quot; height=&quot;64px&quot;/&gt; &lt;div id=&quot;bg&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1.4 文字描边 只有webkit内核才支持：-webkit-text-stroke（准确的来说不能算是css3的东西，但需要知道） 1.5 文字排版 direction:控制文字的方向。 一定要配合unicode-bidi:bidi-override;来使用 text-overflow :确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号（’…’）。 应用场景：文字溢出显示省略号 – white-space: nowrap; – overflow: hidden; – text-overflow: ellipsis; – 包裹区域必须不能让子元素撑开 1234567891011121314 &lt;!-- css代码 --&gt;div&#123; width: 200px; height: 200px; border: 1px solid; margin: 0 auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; &lt;!-- html代码 --&gt; &lt;div&gt;尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷尚硅谷&lt;/div&gt; 2. 盒模型新增属性2.1 盒模型阴影 box-shadow ： – 以逗号分割列表来描述一个或多个阴影效果，可以用到几乎任何元素上。 – 如果元素同时设置了 border-radius ，阴影也会有圆角效果。多个阴影时和多个 text shadows 规则相同(第一个阴影在最上面)。 默认值: none 不可继承 值： – inset：默认阴影在边框外。使用inset后，阴影在边框内。 – &lt;offset-x&gt; &lt;offset-y&gt;：这是头两个 &lt;length&gt; 值，用来设置阴影偏移量。 ! &lt;offset-x&gt; 设置水平偏移量，如果是负值则阴影位于元素左边。 ! &lt;offset-y&gt; 设置垂直偏移量，如果是负值则阴影位于元素上面。 ! 如果两者都是0，那么阴影位于元素后面。这时如果设置&lt;blur-radius&gt; 或&lt;spread-radius&gt; 则有模糊效果。 – &lt;blur-radius&gt;：这是第三个 &lt;length&gt; 值。值越大，模糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。 – &lt;spread-radius&gt;：这是第四个 &lt;length&gt; 值。取正值时，阴影扩大；取负值时，阴影.收缩。默认为0，此时阴影与元素同样大。 – &lt;color&gt;：阴影颜色，如果没有指定，则由浏览器决定。 2.2 盒模型倒影 -webkit-box-reflect : 设置元素的倒影（准确的来说不能算是css3的东西，但需要知道） 默认值:none 不可继承 值：（必须是123的顺序） – 倒影的方向：(第一个值) above, below, right, left– 倒影的距离：(第二个值) 长度单位– 渐变：(第三个值) 2.3 盒模型resize resize ：CSS 属性允许你控制一个元素的可调整大小性。 （一定要配合overflow：auto使用） 默认值：none 不可继承 值： – none：元素不能被用户缩放。 – both：允许用户在水平和垂直方向上调整元素的大小。 – horizontal：允许用户在水平方向上调整元素的大小。 – vertical：允许用户在垂直方向上调整元素的大小。 2.4 box-sizing box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行/列为。 默认值：content-box 不可继承 2.5 怪异盒模型3. 新增UI样式3.1 圆角 传统的圆角生成方案，必须使用多张图片作为背景图案。 CSS3圆角的出现，使得我们再也不必浪费时间去制作这些图片了，而且还有其他多个优点： – 减少维护的工作量。图片文件的生成、更新、编写网页代码，这些工作都不再需要了。 – 提高网页性能。由于不必再发出多余的HTTP请求，网页的载入速度将变快。 – 增加视觉可靠性。某些情况下（网络拥堵、服务器出错、网速过慢等等），背景图片会下载失败，导致视觉效果不佳。CSS3就不会发生这种情况。 border-radius：用来设置边框圆角。当使用一个半径时确定一个圆形；当使用两个半径时确定一个椭圆，这个(椭)圆与边框的交集形成圆角效果。 默认值 : 0 不可继承 值： 固定的px值定义圆形半径或椭圆的半长轴，半短轴。不能用负值 使用百分数定义圆形半径或椭圆的半长轴，半短轴。水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度。不能用负值 这是一个简写属性，用来设置 – border-top-left-radius, – border-top-right-radius, – border-bottom-right-radius, – border-bottom-left-radius 半径的第一个语法取值可取1~4个值: – border-radius: radius – border-radius: top-left-and-bottom-right top-right-and-bottom-left – border-radius: top-left top-right-and-bottom-left bottom-right – border-radius: top-left top-right bottom-right bottom-left 半径的第二个语法取值也可取1~4个值 – border-radius: (first radius values) / radius – border-radius: (first radius values) / top-left-and-bottom-right top-right-and-bottom-left – border-radius: (first radius values) / top-left top-right-and-bottom-left bottom-right – border-radius: (first radius values) / top-left top-right bottom-right bottom-left 注意 ! 百分比值: – 在旧版本的 Chrome 和 Safari 中不支持。(fixed in Sepember 2010) – 在 11.50 版本以前的 Opera 中实现有问题。 – Gecko 2.0 (Firefox 4) 版本前实现不标准：水平半轴和垂直半轴都相对于盒子模型的宽度。 – 在旧版本的 iOS (iOS 5 之前) 和 Android 中 (WebKit 532 之前) 不支持。 3.2 边框图片 border-image： CSS属性允许在元素的边框上绘制图像。 – 这使得绘制复杂的外观组件更加简单，使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式。 默认值： 不可继承 – border-image-source: none – border-image-slice: 100% – border-image-width: 1 – border-image-outset: none – border-image-repeat: stretch 3.3 背景3.3.1 css2 background-color background-color 会设置元素的背景色。 默认值： transparent 不可继承 background-image background-image属性用于为一个元素设置一个或多个背景图像，图像在绘制时，以z轴方向堆叠的方式进行。先指定的图像会在之后指定的图像上面进行绘制。 注意：background-color会在image之下进行绘制，边框和内容会在image之上进行绘制。 默认值：none 不可继承 background-repeat background-repeat CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。 默认值：repeat 不可继承 值： – repeat-x = repeat no-repeat – repeat-y = no-repeat repeat – repeat = repeat repeat – no-repeat = no-repeat no-repeat – 第一个值代表水平方向。 – 第二个值代表垂直方向。 background-position background-position属性 ：指定背景位置的初始位置 默认值：0% 0% 不可继承 值： 百分比：参照尺寸为背景图片定位区域的大小减去背景图片的大小。 – 第一个值：元素在水平方向的位移。 – 第二个值：元素在垂直方向的位移 关键字： – top left and left top (！Same as ‘0% 0%’.) – top, top center, and center top (！Same as ‘50% 0%’.) – right top and top right (！Same as ‘100% 0%’.) – left, left center, and center left (！Same as ‘0% 50%’.) – center and center center (！Same as ‘50% 50%’.) – right, right center, and center right (！Same as ‘100% 50%’.) – bottom left and left bottom (！Same as ‘0% 100%’.) – bottom, bottom center, and center bottom (！Same as ‘50% 100%’.) – bottom right and right bottom (！Same as ‘100% 100%’.) 如果只有一个值被指定，则这个值就会默认设置背景图片位置中的水平方向，与此同时垂直方向的默认值被设置成50%。 background-attachment background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。 默认值：scroll 不可继承 值： – fixed：此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。 – scroll：此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动。 3.3.2 css3 background-origin：设置背景的渲染的起始位置 border-box padding-box content-box background-clip：设置背景裁剪位置 background-size background-size：设置背景图片大小 默认值：auto auto 不可继承 值： – 百分比： 指定背景图片相对背景区（background positioning area）的百分比。 – 背景区由background-origin设置，默认为盒模型的内容区与内边距。 – auto： 以背景图片的比例缩放背景图片。 注意： ！单值时，这个值指定图片的宽度，图片的高度隐式的为auto。 ！两个值: 第一个值指定图片的宽度，第二个值指定图片的高度 。 background background是CSS简写属性，用来集中设置各种背景属性。 background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat, background-size, background-attachment。 默认值： 不可继承 – background-image: none – background-position: 0% 0% – background-size: auto auto – background-repeat: repeat – background-origin: padding-box – background-clip: border-box – background-attachment: scroll – background-color: transparent ！ 顺序无关 3.4 渐变3.4.1 概述 CSS 渐变 是在 CSS3 Image Module 中新增加的图片类型；使用 CSS 渐变可以在两种颜色间制造出平滑的渐变效果. 用它代替图片，可以加快页面的载入时间、减小带宽占用。同时，因为渐变是由浏览器直接生成的，它在页面缩放时的效果比图片更好，因此你可以更加灵活、便捷的调整页面布局。 浏览器支持两种类型的渐变：线性渐变 (linear)，通过 linear-gradient 函数定义，以及 径向渐变 (radial)，通过 radial-gradient 函数定义. 3.4.2 分类 线性渐变 为了创建一个线性渐变，需要设置一个起始点和一个方向（指定为一个角度）。 还要定义终止色。终止色就是你想让浏览器去平滑的过渡过去，并且必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。 默认从上到下发生渐变：linear-gradient(red,blue); 改变渐变方向：（top bottom left right） linear-gradient(to 结束的方向,red,blue); 使用角度：linear-gradient(角度,red,blue); 颜色节点的分布（第一个不写为0%，最后一个不写为100%）：linear-gradient(red 长度或者百分比,blue 长度或者百分比); 重复渐变： repeating-linear-gradient(60deg,red 0,blue 30%); 径向渐变 radial-gradient() 函数创建一个&lt;image&gt;，用来展示由原点（渐变中心）辐射开的颜色渐变 默认均匀分布: radial-gradient(red,blue); – 不均匀分布：radial-gradient(red 50%,blue 70%); 改变渐变的形状：radial-gradient(circle ,red,blue); – circle – ellipse（默认为椭圆） 渐变形状的大小: – radial-gradient(closest-corner circle ,red,blue) – closest-side 最近边 – farthest-side 最远边 – closest-corner 最近角 – farthest-corner 最远角 （默认值） 改变圆心：radial-gradient(closest-corner circle at 10px 10px,red,blue);]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>css新增UI方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之自定义字体]]></title>
    <url>%2F2019%2F10%2F14%2FB-09-CSS3%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[1. 自定义字体 @font-face:允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face可以消除对用户电脑字体的依赖。 font-family– 所指定的字体名字将会被用于font或font-family属性。 src– 字体资源 ！注意：不能在一个CSS选择器中定义@font-face 2. 字体图标 1.Adobe illustrator – AI是一种应用于出版、多媒体和在线图像的工业标准矢量插画的软件，是一款非常好的矢量图形处理工具。 – 该软件主要应用于印刷出版、海报书籍排版、专业插画、多媒体图像处理和互联网页面的制作等。 – 也可以为线稿提供较高的精度和控制，适合生产任何小型设计到大型的复杂项目 2.FontLab – FontLab是一个专业级的字体编辑软件，广泛应用于字体 设计人员和排版印刷业等专业场合。 – 它能够对已有的字体进行修改，也可以完全按照要求 重新设计需要的字体。 – 字体兼容处理网站： https://www.fontsquirrel.com/tools/webfont-generator – icomoon字体图标 https://icomoon.io/#home 3.字体图标基本思路 – 设计一套矢量图 – 将不同的矢量图绑定到不同的字符上生成自定义字体 – 一般通过工具或者站点来处理 – 在页面中运用]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>css自定义字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之选择器]]></title>
    <url>%2F2019%2F10%2F14%2FB-08-CSS3%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.相关地址 CSS3选择器规范地址：https://www.w3.org/TR/2011/REC-css3-selectors-20110929/ CSS3选择最新选择器规范: https://www.w3.org/TR/selectors 2.各种选择器 2.1 基本选择器 通配符选择器： * { margin: 0; padding: 0; border: none; 元素选择器： body { background: #eee; } 类选择器： .list { list-style: square; } ID选择器： #list { width: 500px; margin: 0 auto; } 后代选择器：.list li { margin-top: 10px; background: #abcdef; } 2.2 基本选择器扩展 子元素选择器：#wrap &gt; .inner {color: pink;} – 也可称为直接后代选择器,此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素。 相邻兄弟选择器：#wrap #first + .inner {color: #f00;} – 它只会匹配紧跟着的兄弟元素。 通用兄弟选择器：#wrap #first ~ div { border: 1px solid;} – 它会匹配所有的兄弟元素(不需要紧跟)。 选择器分组：h1,h2,h3{color: pink;} – 此处的逗号我们称之为结合符。 2.3 属性选择器 存在和值属性选择器 – [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。 – [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。 – [attr~=val]：表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为val。 子串值属性选择器 – [attr|=val] : 选择attr属性的值是val（包括val）或以val-开头的元素。 – [attr^=val] : 选择attr属性的值以val开头（包括val）的元素。 – [attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。 – [attr*=val] : 选择attr属性的值中包含字符串val的元素。 2.4 伪类与伪元素选择器 链接伪类：注意:link，:visited，:target是作用于链接元素的！ – :link 表示作为超链接，并指向一个未访问的地址的所有锚。 – :visited 表示作为超链接，并指向一个已访问的地址的所有锚。 – :target 代表一个特殊的元素，它的id是URI的片段标识符 动态伪类：注意:hover，:active基本可以作用于所有的元素！ – :hover 表示悬浮到元素上。 – :active 表示匹配被用户激活的元素（点击按住时）。 – 由于a标签的:link和:visited可以覆盖了所有a标签的状态，所以当:link，:visited，:hover，:active同时出现在a标签身上时 :link和:visited不能放在最后！！！ – :visited选择器只有下列的属性才能被应用到已访问链接： color background-color border-color 表单相关伪类 – :enabled 匹配可编辑的表单。 – :disable 匹配被禁用的表单。 – :checked 匹配被选中的表单。 – :focus 匹配获焦的表单。 结构性伪类 ！ index的值从1开始计数！！ ！index可以为变量n(只能是n) ！index可以为even odd #wrap ele:nth-child(index) 表示匹配#wrap中第index的子元素 这个子元素必须是ele。 #wrap ele:nth-of-type(index) 表示匹配#wrap中第index的ele子元素。 除此之外:nth-child和:nth-of-type有一个很重要的区别：nth-of-type以元素为中心！！！ :nth-child(index)系列 – :first-child – :last-child – :nth-last-child(index) – :only-child (相对于:first-child:last-child 或者 :nth-child(1):nth-last-child(1)) :nth-of-type(index)系列 – :first-of-type – :last-of-type – :nth-last-type(index) – :only-of-type (相对于:first-of-type:last-of-type 或者 :nth-of-type(1):nth-last-of-type(1)) – :not – :empty(内容必须是空的，有空格都不行，有attr没关系) 根元素伪类选择器 – ：root (有的根元素为html,有的为body) 伪元素 – ::after – ::before – ::firstLetter – ::firstLine – ::selection ! 一个元素只有两个伪元素(before 和 after) ！伪元素选择器建议写两个冒号。 3. css声明的优先级3.1 选择器的特殊性 选择器的特殊性由选择器本身的组件确定，特殊性值表述为4个部分，如 0,0,0,0。 一个选择器的具体特殊性如下确定： – 1.对于选择器中给定的ID属性值，加 0,1,0,0。 – 2.对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0。 – 3.对于选择器中的给定的各个元素和伪元素，加0,0,0,1。 – 4.通配符选择器的特殊性为0,0,0,0。 – 5.结合符对选择器特殊性没有一点贡献。 – 6.内联声明的特殊性都是1,0,0,0。 – 7.继承没有特殊性 ！特殊性 1,0,0,0 大于所有以0开头的特殊性(不进位)。 ！选择器的特殊性最终都会授予给其对应的声明。 ！如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性越大的越占优势。 ！注意：id选择器和属性选择器： div[id=”test”]（0,0,1,1） #test（0,1,0,0） 3.2 重要声明 有时某个声明比较重要，超过了所有其他声明，css2.1就称之为重要声明，并允许在这些声明的结束分号之前插入 !important 来标志。 必须要准确的放置 !important 否则声明无效。 !important 总是要放在声明的最后，即分号的前面。 标志为 !important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决。 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决。 如果一个重要声明与非重要声明冲突，胜出的总是重要声明。 3.3 继承 继承没有特殊性，甚至连0特殊性都没有。 0特殊性要比无特殊性来的强。 3.4 来源 css样式的来源大致有三种 – 创作人员 – 读者 – 用户代理 权重： – 读者的重要声明 – 创作人员的重要声明 – 创作人员的正常声明 – 读者的正常声明 – 用户代理的声明 3.5 层叠 找出所有相关的规则，这些规则都包含一个选择器。 计算声明的优先级 – 先按来源排序 – 在按选择器的特殊性排序 – 最终按顺序]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>css选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之CSS Hack(不推荐使用)]]></title>
    <url>%2F2019%2F10%2F11%2FB-07-CSS%E4%B9%8BCSS-Hack%2F</url>
    <content type="text"><![CDATA[用到时进行查阅即可。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css Hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS基本操作]]></title>
    <url>%2F2019%2F10%2F11%2FB-06-CSS%E4%B9%8BPS%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. PS基本操作(1)1.1 设置PS的单位为像素(px) 进入PS –&gt; 界面选项 –&gt; 单位与标尺 –&gt; 像素 –&gt; 确定 1.2 标尺 ctrl + R 出现标尺，再按标尺消失。(要先放一张图片) 1.3 辅助线 鼠标放在标尺上，往下/右拖，就会出现辅助线，不需要的话再拖回去即可。(左边要选中拖动) ctrl + H ：隐藏辅助线，再按显示。 1.4 调整图片大小 alt + 滚轮 ：放大/缩小 ctrl + 1 ：恢复到100% ctrl + 0 ：适应屏幕大小 1.5 虚线框(4种) F8 ：显示虚线框选中部分的宽高等信息 ctrl + D ：让虚线框消失]]></content>
      <categories>
        <category>前端</category>
        <category>PS</category>
      </categories>
      <tags>
        <tag>ps基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之IE兼容问题]]></title>
    <url>%2F2019%2F10%2F11%2FB-06-CSS%E4%B9%8BIE%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. IE6对图片格式png24支持度不高1.1 导致的问题 如果使用的图片格式是png24，则会导致透明效果无法正常显示。 1.2 解决方法 可以使用png8来代替png24，即可解决问题– 缺点：但是使用png8代替png24以后，图片的清晰度会有所下降。 使用JavaScript来解决该问题，需要向页面中引入一个外部的JavaScript文件，后在写一下简单的JS代码，来处理该问题。 123456&lt;!-- 在body标签的最后引入外部的JS文件 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/DD_belatedPNG_0.0.8a-min.js&quot;&gt;&lt;/script&gt;&lt;!--再创建一个新的script标签，并且编写一些js代码 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; DD_belatedPNG.fix(&quot;*&quot;);&lt;/script&gt; CSS Hack – 同方法2，代码如下： 1234&lt;!--[if IE 6]&gt; &lt;script src=&quot;js/DD_belatedPNG_0.0.8a-min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;DD_belatedPNG.fix(&apos;img&apos;);&lt;/script&gt;&lt;![endif]--&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>高度塌陷</tag>
        <tag>IE兼容问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之框架集]]></title>
    <url>%2F2019%2F10%2F11%2FB-05-CSS%E4%B9%8B%E6%A1%86%E6%9E%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[1. 框架集1.1 概述 框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面。 框架集可以同时引入多个页面，而内联框架只能引入一个，在h5标准中，推荐使用框架集，而不使用内联框架。 使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中，所以要使用框架集，页面中就不可以使用body标签。 属性： – rows，指定框架集中的所有的框架，一行一行的排列。 – cols， 指定框架集中的所有的页面，一列一列的排列。 – 这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小。 frameset中也可以再嵌套frameset。 frameset和iframe一样，它里边的内容都不会被搜索引擎所检索，所以如果搜索引擎检索到的页面是一个框架页的话，它是不能去判断里边的内容的。 使用框架集则意味着页面中不能有自己的内容，只能引入其他的页面，而每单独加载一个页面，浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求，用户的体验比较差。如果非得用建议使用frameset而不使用iframe。 演示： 123456789101112&lt;frameset cols=&quot;30% , * , 30%&quot;&gt; &lt;!-- 在frameset中使用frame子标签来指定要引入的页面 ,引入几个页面就写几个frame --&gt; &lt;frame src=&quot;01.表格.html&quot; /&gt; &lt;frame src=&quot;02.表格.html&quot; /&gt; &lt;!-- 嵌套一个frameset --&gt; &lt;frameset rows=&quot;30%,50%,*&quot;&gt; &lt;frame src=&quot;04.表格的布局.html&quot; /&gt; &lt;frame src=&quot;05.完善clearfix.html&quot; /&gt; &lt;frame src=&quot;06.表单.html&quot; /&gt; &lt;/frameset&gt;&lt;/frameset&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>框架集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见问题及解决方法]]></title>
    <url>%2F2019%2F10%2F10%2FB-00-CSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 高度塌陷1.1 塌陷原因 在文档流中，父元素的高度默认是被子元素撑开的。但是当为子元素设置浮动以后，子会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。 1.2 解决方法（均为设置塌陷元素） 把父元素的高度写死 -缺点：不能自动适应子元素高度 根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。 *当开启元素的BFC以后，元素将会具有如下的特性： 1.父元素的垂直外边距不会和子元素重叠 2.开启BFC的元素不会被浮动元素所覆盖 3.开启BFC的元素可以包含浮动的子元素 *如何开启元素的BFC 1.设置元素浮动 -使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题 2.设置元素绝对定位 -与设置浮动效果相同 3.设置元素为inline-block -可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 4.将元素的overflow设置为一个非visible的值 -具体代码： overflow: auto; overflow: hidden; -ie6代码： zoom: 1; *清除浮动（受的影响） 清除浮动1： 可以直接在高度塌陷的父元素的最后，添加一个空白的div，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用。 在浮动的元素后面加一个空的兄弟元素，并给这个空元素设置清除浮动 clear: both; -缺点：使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。 清除浮动2： 可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加一个div的原理一样，可以达到一个相同的效果， 而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用 12345678910111213141516.clearfix:after&#123; /*添加一个内容*/ content: &quot;&quot;; /*转换为一个块元素*/ display: block; /*清除两侧的浮动*/ clear: both;&#125;/* * 在IE6中不支持after伪类, * 所以在IE6中还需要使用hasLayout来处理 */.clearfix&#123; zoom:1;&#125; 完善clearfix: 同时解决外边距重叠和高度塌陷 12345678910.clearfix:before,.clearfix:after&#123; content: &quot;&quot;; display: table; clear: both;&#125;.clearfix&#123; zoom: 1;&#125; 2. 父子元素的外边距重叠2.1 解决方法： 1234567.box1:before&#123; content: &quot;&quot;; /* display:table可以将一个元素设置为表格显示 */ display: table;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css常见问题</tag>
        <tag>高度塌陷</tag>
        <tag>垂直外边距重叠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客搭建过程]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在b站上看了codesheep和geekmubai的视频教程（视频是Mac系统），二者结合，搭建了自己的博客（我的是Windows系统），主题及修改则是到处查着修改，比较混乱，暂时还没整理。只整理了一下搭建的过程并记录了下来，如下所示： 1.去官网安装node.js 打开命令行(win + R –&gt; cmd –&gt; 回车) C:\Users\颖&gt;npm -v （查看npm是否安装好） 6.9.0 C:\Users\颖&gt;node -v （查看node是否安装好） 10.16.0 2.安装hexo博客框架 C:\Users\颖&gt;npm install -g cnpm –registry=https://registry.npm.taobao.org (用npm安装cnpm,把镜像源指向淘宝) C:\Users\颖&gt;cnpm C:\Users\颖&gt;cnpm -v （查看cnpm是否安装好） C:\Users\颖&gt;cnpm install -g hexo-cli （用cnpm安装hexo博客框架） 3.建立一个空的blog文件夹 C:\Users\颖&gt;cd blog （进入blog文件夹里） C:\Users\颖\blog&gt;hexo init （初始化一个博客，会生成一些东西可以在命令行用dir查看） C:\Users\颖\blog&gt;hexo s （在本地启动博客） 4.把博客部署到github 在github中新建一个仓库，这个仓库的名称必须是Git名字+github.io C:\Users\颖\blog&gt;cnpm install –save hexo-deployer-git （安装一个部署插件） 5.打开blog中的_config.yml文件，用记事本打开到最底部，做如下修改： deploy:&nbsp;&nbsp;&nbsp;type: git&nbsp;&nbsp;&nbsp;repo: https://github.com/geekying/geekying.github.io.git (github中新建的仓库的地址)&nbsp;&nbsp;&nbsp;branch: master 6.去官网下载git，安装完成后在git中做如下操作： $ git config –global user.name “geekying” $ git config –global user.email “congyingw@sina.com“ $ ssh-keygen -t rsa -C “congyingw@sina.com“ -在github中新建一个密钥，内容为刚才生成的.ssh中的id_rsa.pub文件中的密钥 7.回到命令行，完成部署 C:\Users\颖\blog&gt;hexo d （hexo deploy） 8.更换主题 C:\Users\颖\blog&gt;git clone https://github.com/kjhuanhao/HEXO-HHC-NEXT （克隆一下主题） -(我换成了next主题https://github.com/kjhuanhao/HEXO-HHC-NEXT) 打开blog中的.config文件，用记事本打开到最底部，做如下修改： themes：next回到命令行 C:\Users\颖\blog&gt;hexo clean C:\Users\颖\blog&gt;hexo g (generate生成) C:\Users\颖\blog&gt;hexo s (server) C:\Users\颖\blog&gt;hexo d (deploy) 9.新建一篇博客 C:\Users\颖\blog&gt;hexo n “标题” &emsp;&emsp;在blog文件夹里找到source/_post中的markdown文件，进行内容编辑，编辑好之后重复更换主题的最后四条语句即可。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之表格和表单]]></title>
    <url>%2F2019%2F10%2F09%2FB-04-CSS%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%92%8C%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1.表格1.1 表格概述 表格的作用就是用来表示格式化的数据。 1.2 表格标签 table、tr、th、td (表格) – 在table标签中使用tr来表示表格中的一行，有几行就有几个tr。 – 在tr中需要使用td来创建一个单元格，有几个单元格就有几个td。 – th表示表头。 caption、thead、tbody、tfoot (长表格) caption表示表格的标题 thead、tbody、tfoot – thead 表格的头部、tbody 表格主体、tfoot 表格底部 – 这三个标签的作用，就来区分表格的不同的部分，他们都是table的子标签，都需要直接写到table中，tr需要写在这些标签当中。 – thead中的内容，永远会显示在表格的头；tfoot中的内容，永远都会显示表格的底部；tbody中的内容，永远都会显示表格的中间。 – 如果表格中没有写tbody，浏览器会自动在表格中添加tbody。并且将所有的tr都放到tbody中。 ！ 注意tr并不是table的子元素，而是tbody的子元素。通过table &gt; tr 无法选中， 需要通过tbody &gt; tr 1.3 合并单元格 合并单元格指将两个或两个以上的单元格合并为一个单元格。 合并单元格可以通过在th或td中设置属性来完成。 – colspan：用来设置横向的合并单元格。 – rowspan：用来设置纵向的合并单元格。 1.4 表格的样式 之前学习的很多属性都可以用来设置表格的样式，比如color可以用 来设置文本的颜色。padding可以设置内容和表格边框的距离。 width：设置表格的宽度 margin: 0 auto; 让表格居中 border：边框 background-color：设置背景样式 text-align：设置文本的水平对齐 vertical-align：设置文本的垂直对齐 – 可选值：top、baseline、middle、bottom border-spacing：边框间距 – table和td边框之间默认有一个距离通过border-spacing属性可以设置这个距离 border-collapse：合并边框 – 可选值：collapse(合并边框)、separate(不合并边框) – 如果设置了边框合并，则border-spacing自动失效。 2. 表单2.1 表单概述 现实生活中的表单是用来提交信息的。 网页中表单的作用就是用来将用户信息提交给服务器的。比如：百度的搜索框 注册 登录这些操作都需要填写表单。最常用到的表单就是baidu的搜索框。 2.2 表单项12345文本框 &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;密码框 &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;多选框 &lt;input type=&quot;checkbox&quot; name=&quot;sports&quot;&gt; 单选框 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;提交按钮 &lt;input type=&quot;submit&quot; value=&quot; 提交 &quot;&gt;下拉列表 &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;/select&gt; 2.3 表单标签 form – 使用form标签创建一个表单。 – form标签中必须指定一个 action 属性，该属性指向的是一个服务器的地址，当提交表单时将会提交到action属性对应的地址。 fieldset – 在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset中。 legend – 在fieldset可以使用legend子标签，来指定组名。 label – label标签专门用来选中表单中的提示文字的。 – 该标签可以指定一个for属性，该属性的值需要指定一个表单项的id值。 inpute input是使用的最多的表单项，它可以 根据不同的type属性呈现不同的状态。 type属性可选值： text：文本框 – 使用input来创建一个文本框，它的type属性是text。 password：密码框 – 使用input创建一个密码框，它的type属性值是password。 radio：单选按钮 – 使用input来创建一个单选按钮，它的type属性使用radio。 – 单选按钮通过name属性进行分组，name属性相同是一组按钮。 – 像这种需要用户选择但是不需要用户直接填写内容的表单项，还必须指定一个value属性，这样被选中的表单项value属性值将会最终提交给服务器。 – 如果希望在单选按钮中指定默认选中的选项，则可以在希望选中的项中添加checked=”checked”属性。 checkbox：多选框 – 使用input创建一个多选框，它的type属性使用checkbox。 – 多选框通过name属性进行分组，name属性相同是一组按钮。 – 像这种需要用户选择但是不需要用户直接填写内容的表单项，还必须指定一个value属性，这样被选中的表单项value属性值将会最终提交给服务器。 – 如果希望在多选框中指定默认选中的选项，则可以在希望选中的项中添加checked=”checked”属性。 submit：提交按钮 – 提交按钮可以将表单中的信息提交给服务器。 – 使用input创建一个提交按钮,它的type属性值是submit。 – 在提交按钮中可以通过value属性来指定按钮上的文字。 reset ：重置按钮 – 点击重置按钮以后表单中内容将会恢复为默认值。 – 使用input创建一个重置按钮,它的type属性值是reset。 – 在重置按钮中可以通过value属性来指定重置上的文字。 如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性(name表示提交内容的名字)。 用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器。url地址?查询字符串 – 查询字符串的格式：属性名=属性值&amp;属性名=属性值&amp;属性名=属性值&amp;属性名=属性值 在文本框中也可以指定value属性值，该值将会作为文本框的默认值显示。 通过修改value属性值，可以修改按钮上的文字 fieldset、legend、label (长表单) -fieldset用来为表单项进行分组。 -legend用于指定每组的名字。 -label标签用来为表单项定义描述文字。 select、option、optgroup optgroup用于为列表项分组。 option表示下拉列表中的列表项。 使用select来创建一个下拉列表。 – 下拉列表的name属性需要指定给select，而value属性需要指定给option。 – 可以通过在option中添加selected=”selected”来将选项设置为默认选中。 – 当为select添加一个multiple=”multiple”，则下拉列表变为一个多选的下拉列表。 – 在select中可以使用optgroup对选项进行分组，同一个optgroup中的选项是一组，可以通过label属性来指定分组的名字。 textarea – textarea用来创建一个文本域，实际效果和 文本框类似，只是可以输入多行数据。 – 可用属性： *cols：文本域的列数 *rows：文本域的行数 button– 也可以使用button标签来创建按钮。这种方式和使用input类似，只不过由于它是成对出现的标签，使用起来更加的灵活。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>表格</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒子模型+元素背景设置]]></title>
    <url>%2F2019%2F10%2F09%2FB-03-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2B%E5%85%83%E7%B4%A0%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 盒子模型1.1 盒子概述 CSS处理网页时，它认为每个元素都包含在一 个不可见的盒子里，这样方便布局。 1.2 盒子模型 一个盒子我们会分成几个部分： – 内容区(content) – 内边距(padding) – 边框(border) – 外边距(margin) 1.3 内容区 内容区指的是盒子中放置内容的区域，也就是元素 中的文本内容，子元素都是存在于内容区中的。 如果没有为元素设置内边距和边框，则内容区大小 默认和盒子大小是一致的。 通过width和height两个属性可以设置内容区的大 小。 width和height属性只适用于块元素。 1.4 内边距 内边距指的就是元素内容区与边框以内 的空间。 默认情况下width和height不包含padding的大小。 使用padding属性来设置元素的内边距。 padding:10px 20px 30px 40px; –这样会设置元素的上、右、下、左四个方向的内边距。 padding:10px 20px 30px; –分别指定上、左右、下四个方向的内边距 padding:10px 20px; –分别指定上下、左右四个方向的内边距 padding:10px; – 同时指定上左右下四个方向的内边距 同时在css中还提供了padding-top、padding-right、paddingright、padding-bottom分别用来指定四个方向的内边距。 1.5 边框 可以在元素周围创建边框，边框是元素可见框的最外部。 可以使用border属性来设置盒子的边框： –- border:1px red solid; –- 上边的样式分别指定了边框的宽度、颜色和样式。 也可以使用border-top/left/right/bottom分别指定上右下左 四个方向的边框。 和padding一样，默认width和height并包括边框的宽度。 边框可以设置多种样式： – none（没有边框） – dotted（点线） – dashed（虚线） – solid（实线） – double（双线） – groove（槽线） – ridge（脊线） – inset（凹边） – outset（凸边） 1.6 外边距 外边距是元素边框与周围元素相距的空间。 使用margin属性可以设置外边距。 用法和padding类似，同样也提供了四个方向的 margin-top/right/bottom/left。 当将左右外边距设置为auto时，浏览器会将左右外 边距设置为相等，所以这行代码margin:0 auto可以使元素居中。2. 盒子的位置及大小相关 2.1 display 不能为行内元素设置width、height、 margin-top和margin-bottom。 可以通过修改display来修改元素的性 质。 可选值： – block：设置元素为块元素 – inline：设置元素为行内元素 – inline-block：设置元素为行内块元素 – none：隐藏元素（元素将在页面中完全消失） 2.2 visibility visibility属性主要用于元素是否可见。 和display不同，使用visibility隐藏一个元素，隐藏后其在文档中所占的位置会依然保持，不会被其他元素覆盖。 可选值： – visible：可见的 – hidden：隐藏的(占位) 2.3 overflow 当相关标签里面的内容超出了样式的宽度 和高度是，就会发生一些奇怪的事情，浏 览器会让内容溢出盒子。 可以通过overflow来控制内容溢出的情况。 可选值： – visible：默认值 – scroll：添加滚动条(不管是否溢出，并且水平和垂直都添加) – auto：根据需要添加滚动条 – hidden：隐藏超出盒子的内容 2.4 文档流 文档流指的是文档中可现实的对象在排列时所占用的位置。 2.5 浮动 浮动指的是使元素脱离原来的文本流，在父元素中浮动起来。 浮动使用float属性。 可选值： -none，默认值，不清除浮动。 -left，清除左侧浮动元素对当前元素的影响。 -right，清除右侧浮动元素对当前元素的影响。 -both，清除两侧浮动元素对当前元素的影响清除对他影响最大的那个元素的浮动。 块级元素和行内元素都可以浮动，当一个行内元素浮动以后将会自动变为一个块级元素。 当一个块级元素浮动以后，宽度会默认被内容撑开，所以当漂浮一个块级元素时我们都会为其指定一个宽度。 当一个元素浮动以后，其下方的元素会上移。元素中的内容将会围绕在元素的周围。- 浮动会使元素完全脱离文本流，也就是不再在文档中在占用位置。 元素设置浮动以后，会一直向上漂浮直到遇到父元素的边界或者其他 浮动元素。 元素浮动以后即完全脱离文档流，这时不会再影响父元素的高度。也就是浮动元素不会撑开父元素。 浮动元素默认会变为块元素，即使设置display:inline以后其依然是个块元素。 2.6 清除浮动 clear属性可以用于清除元素周围的浮动对元素的影响。 元素不会因为上方出现了浮动元素而改变位置。 可选值： – left：忽略左侧浮动 – right：忽略右侧浮动 – both：忽略全部浮动 – none：不忽略浮动，默认值 2.7 定位 定位：定位指的就是将指定的元素摆放到页面的任意位置，通过定位可以任意的摆放元素。 通过position属性来设置元素的定位 可选值： -static：默认值，元素没有开启定位 -relative：开启元素的相对定位 -absolute：开启元素的绝对定位 -fixed：开启元素的固定定位（也是绝对定位的一种） 当开启了元素的定位（position属性值是一个非static的值）时，可以通过left right top bottom四个属性来设置元素的偏移量– left：元素相对于其定位位置的左侧偏移量。 – right：元素相对于其定位位置的右侧偏移量。 – top：元素相对于其定位位置的上边的偏移量。 – bottom：元素相对于其定位位置下边的偏移量。 *通常偏移量只需要使用两个就可以对一个元素进行定位。一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位。 */ 2.8 相对定位 每个元素在页面的文档流中都有一个自然位置。相对于这个位置对元素进行移动就称为相对定位。周围的元素完全不受此影响。 当元素的position属性设置为relative时，则开启了元素的相对定位。 开启了相对定位以后，可以使用top、right、bottom、left四个属性对元素进行定位。 相对定位的特点: – 当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生任何变化。 – 相对定位是相对于元素在文档流中原来的位置进行定位。 – 相对定位的元素不会脱离文档流。 – 相对定位会使元素的层级提升，使元素可以覆盖文本流中的元素。 – 相对定位不会改变元素的性质，块还是块，内联还是内联 2.9 绝对定位 绝对定位指使元素相对于html元素或离他最近的祖先定位元素进行定位。 当position属性值设置为absolute时，则开启了元素的绝对定位。 开启了绝对定位以后，可以使用top、right、 bottom、left四个属性对元素进行定位。 绝对定位的特点： – 开启绝对定位，会使元素脱离文档流。 – 开启绝对定位以后，如果不设置偏移量，则元素的位置不会发生变化。 – 绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位）。如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位。 – 绝对定位会使元素提升一个层级。 – 绝对定位会改变元素的性质(内联元素变成块元素)。 – 块元素的宽度和高度默认都被内容撑开 2.10 固定定位 固定定位的元素会被锁定在屏幕的某个位置上，当访问者滚动网页时，固定元素会在屏幕上保持不动。 当将position属性设置为fixed时，则开启了元素的固定定位。 当开启了固定定位以后，可以使用top、right、bottom、left四个属性对元素进行定位。 绝对定位的特点： –固定定位也是一种绝对定位，它的大部分特点都和绝对定位一样。 –固定定位永远都会相对于浏览器窗口进行定位。 – 固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动。 – IE6不支持固定定位。 后三条是不同之处。 2.11 层级 如果定位元素的层级是一样，则下边的元素会盖住上边的。 通过z-index属性可以用来设置元素的层级。可以为z-index指定一个正整数作为值，该值将会作为当前元素的层级。 层级越高，越优先显示。(也就是z-index 值较大的元素会显示在网页的最上层) 对于没有开启定位的元素不能使用z-index。 3. css背景设置3.0 background background是背景的简写属性，通过这个属性可以一次性设置多个样式，而且样式的顺序没有要求。 例如： background: green url(img/1.jpg) no-repeat center center fixed 3.1 background-color background-color属性用来为元素设置背景颜色。 需要指定一个颜色值，当指定了一个颜色以后，整个元素的可见区域都会使用这个颜色作为背景色。 如果不设置背景颜色，元素默认背景颜色为透明，实际上会显示父元素的背景颜色。 3.2 background-image 使用background-image来设置背景图片 语法：background-image:url(相对路径); 显示规则： – 如果背景图片大于元素，默认会显示图片的左上角。 – 如果背景图片和元素一样大，则会将背景图片全部显示。 – 如果背景图片小于元素大小，则会默认将背景图片平铺以充满元素。 可以同时为一个元素指定背景颜色和背景图片 – 这样背景颜色将会作为背景图片的底色。 – 一般情况下设置背景图片时都会同时指定一个背景颜色。 3.3 background-repeat background-repeat用于设置背景图片的重复方式。 可选值：– repeat：默认值，背景图片会双方向重复（平铺）。 – no-repeat：背景图片不会重复，有多大就显示多大。 – repeat-x：背景图片沿水平方向重复。 – repeat-y：背景图片沿垂直方向重复。 如果只设置背景图片默认背景图片将会使 用平铺的方式，可以通过该属性进行修改。 3.4 background-position 通过background-position可以调整背景图片在元素中的位置(背景图片默认是贴着元素的左上角显示)。 可选值：该属性可以使用 top right left bottom center中的两个值，来指定一个背景图片的位置 – top left 左上 – bottom right 右下 – 如果只给出一个值，则第二个值默认是center 也可以直接指定两个偏移量： 第一个值是水平偏移量 – 如果指定的是一个正值，则图片会向右移动指定的像素。 – 如果指定的是一个负值，则图片会向左移动指定的像素。 第二个是垂直偏移量 – 如果指定的是一个正值，则图片会向下移动指定的像素。 – 如果指定的是一个负值，则图片会向上移动指定的像素。 可以通过三种方式来确定图片在水平方向和垂直方向的起点。 – 关键字 – 数值 – 百分比 3.5 background-attachment background-attachment用来设置背景图片是否随页面一起滚动 可选值： – scroll：默认值，背景图片随着窗口滚动。 – fixed：背景图片会固定在某一位置，不随页面滚动。 当背景图片的background-attachment设置为fixed时， 背景图片的定位永远相对于浏览器的窗口。 不随窗口滚动的图片，一般都是设置给body，而不设置给其他元素。 3.6 CSS Sprite (雪碧图) CSS Sprites是一种网页图片应用处理方式。 通过这种方式我们可以将网页中的零星图 片集中放到一张大图上。 这样一来，一次请求便可以同时加载多张 图片，大大提高了图片的加载效率。 消除按钮闪烁(闪烁会造成一次不佳的用户体验)。 产生问题的原因： – 背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求。– 但是我们外部资源并不是同时加载，浏览器会在资源被使用才去加载资源。 – 由于加载图片需要一定的时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况。 – 为了解决该问题，可以将三个图片整合为一张图片，这样可以同时将三张图片一起加载，就不会出现闪烁的问题了。 – 然后在通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术（CSS-Sprite）。 优点： – 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片，提高访问效率，提高了用户体验。 – 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css盒子模型</tag>
        <tag>溢出</tag>
        <tag>定位</tag>
        <tag>css背景设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2019%2F10%2F09%2FB-02-CSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. css选择器选择器（selector），会告诉浏览器：网页 上的哪些元素需要设置什么样的样式。 1.1 元素选择器 元素选择器（标签选择器），可以根据标 签的名字来从页面中选取指定的元素。 语法： 标签名 { } 1.2 类选择器 类选择器，可以根据元素的class属性值选 取元素。 语法： .className { } 1.3 ID选择器 ID选择器，可以根据元素的id属性值选取元素。 语法：#id { } 1.4 复合选择器 (交集选择器) 复合选择器，可以同时使用多个选择器， 这样可以选择同时满足多个选择器的元素。 语法：选择器1选择器2{} 1.5 群组选择器(并集选择器) 群组选择器，可以同时使用多个选择器， 多个选择器将被同时应用指定的样式。 语法： 选择器1,选择器2,选择器3 { } 1.6 通用选择器 通用选择器，可以同时选中页面中的所有 元素。 语法： *{ } 1.7 后代选择器 后代选择器可以根据标签的关系，为处在 元素内部的代元素设置样式。 语法： 祖先元素 后代元素 后代元素 { } 1.8 伪类选择器 有四个伪类可以根据访问者与该链接的交互方式，将链接设置成4种不同的状态。 正常链接 a:link{ } 访问过的链接 a:visited{ }（只能定义字体颜色） 鼠标滑过的链接 a:hover{ } 正在点击的链接 a:active{ } 其他伪类： 获取焦点 :focus 指定元素前 :before 指定元素后 :after 选中的元素 ::selection 1.9 伪元素选择器 给段落定义样式： 首字母 :first-letter{ } 首行 :first-line{ } 1.10 属性选择器 属性选择器可以挑选带有特殊属性的标签。 语法: [属性名]{ } – 属性名可以是类名/id名等 [属性名=”属性值”]{ } – 属性为某个特定值的 [属性名~=”属性值”]{ } – 选取属性值中包含指定词汇的元素。 [属性名|=”属性值”]{ } – 选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [属性名^=”属性值”]{ } – 属性值以XXX开头 [属性名$=”属性值”]{ } – 属性值以XXX结尾 [属性名*=”属性值”]{ } – 属性值包含XXX 1.11 子元素选择器 子元素选择器可以给另一个元素的子元素设置样式。 语法：父元素 &gt; 子元素{} 其他子元素选择器 :first-child – 选择第一个子标签 :last-child – 选择最后一个子标签 :nth-child(n) – 选择指定位置的子元素,n 是整数或odd(奇数位置)/even(偶数位置) :first-of-type 选择指定类型的第一个子元素 :last-of-type 选择指定类型的最后一个子元素 :nth(n)-of-type 选择指定类型的子元素 1.12 兄弟选择器 除了根据祖先父子关系，还可以根据兄弟 关系查找元素。 语法: 查找后边一个兄弟元素 ： 兄弟元素 + 兄弟元素{}查找后边所有的兄弟元素： 兄弟元素 ~ 兄弟元素{} 1.13 否定伪类选择器 否定伪类可以帮助我们选择不是其他东西 的某件东西。 语法: :not(选择器){} 比如： p:not(.hello)表示选择所有的p元素但 是class为hello的除外。 2. 选择器的权重2.1 权重概述 在页面中使用CSS选择器选中元素时，经常都是一个元素同时被多个选择器选中。如果两个选择器设置的是同一个样式则会产生冲突， 这样h1到底要应用那个样式呢？CSS中会默认使用权重较大的样式 2.2 权重的计算 不同的选择器有不同的权重值： 内联样式：权重是1000 id选择器：权重是100 类、属性、伪类选择器：权重是10 元素选择器：权重是1 通配符：权重是0 默认样式：没有权重 计算权重需要将一个样式的全部选择器相加，权重高的优先显示，权重相同的就后面的样式使用。 ！权重相加结果不会超过最大值]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css选择器</tag>
        <tag>标签关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown常用语法]]></title>
    <url>%2F2019%2F10%2F09%2F00-markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标题 # 一级标题一级标题 ## 二级标题二级标题 ### 三级标题三级标题 #### 四级标题四级标题 ##### 五级标题五级标题 ###### 六级标题六级标题 2.列表(注意空格) * ：无序列表 + ：无序列表 - ：无序列表 ：有序列表 ：有序列表 ：有序列表3.换行 按两次回车 html中的标签br &lt;可识别的内容&gt;4.分割线 --- 连续输入三个- *** 连续输入三个* 5.超链接 [超链接名字](超链接的地址src) wcy’blog 6.粗体和斜体 *内容* ：一个*号代表 斜体 这是斜体文字 **内容** ：两个*号代表 粗体 这是粗体文字 ***内容*** ：三个*号代表 斜体+粗体 这是斜体+粗体文字 7.引用 &gt; 引用一段话 这是引用的话的示例 &lt;!–￼0–&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown常用语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2019%2F10%2F09%2FB-01-CSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. CSS简介1.1 css概述 层叠样式表 (Cascading Style Sheets) css可以用来为网页创建样式表，通过样式表可以对网页进行装饰。 1.2 基本语法 CSS的样式表由一个一个的样式构成，一个样式又由 选择器 和 声明块 构成。 语法：选择器 {样式名:样式值；样式名:样式值; } 1.3 行内样式 可以直接将样式写到标签内部的style属性中，这种样式不用填写选择器，直接编写 声明即可。 &lt;p style=”color: red;font-size: 30px”&gt;&lt;/p&gt; 这种方式编写简单，定位准确。但是由于 直接将css代码写到了html标签的内部，导 致结构与表现耦合，同时导致样式不能够 复用，所以这种方式我们不使用。 1.4 内部样式表 可以直接将样式写到&lt;style&gt;标签中。 &lt;style&gt; p{color:red; font-size: 30px;} &lt;/style&gt; 这样使css独立于html代码，而且可以同时为 多个元素设置样式，这是我们使用的比较多的 一种方式。 但是这种方式，样式只能在一个页面中使用， 不能在多个页面中重复使用。 1.5 外部样式表 可以将所有的样式保存到一个外部的css文 件中，然后通过标签将样式表引入 到文件中。 &lt;link rel=”stylesheet” type=”text/css” href=”style.css”&gt; 这种方式将样式表放入到了页面的外部， 可以在多个页面中引入，同时浏览器加载 文件时可以使用缓存，这是我们开发中使 用的最多的方式。 2. 文本格式化2.1 单位 px 对于不同的显示器来说一个像素 的大小是不同的。 百分比 也可以使用一个百分数来表示一个大小，百分比是相对于父元素来说的。 em em和百分比类似，也是相对于父元素说的，1em就相 当于100%，2em相当于200%，1.5em相当于150%。 2.2 颜色 颜色英文单词 aqua、black、blue、fuchsia、gray、green、 lime、maroon、navy、olive、orange、 purple、red、silver、teal、white、yellow 十六进制颜色 颜色 是由指定浓度的红绿蓝混合而成的。比如：：#6600FF RGB值 –也可以使用计算机中常用的RGB值来表示 颜色。 –可以使用0255的数值，也可以使 用0%100%的百分比数。 RGB(100%,0%,0%) RGB(0,255,0) –第一个数表示红色的浓度，第二个数表示 绿色浓度，第三个数表示蓝色的浓度。 RGBA –RGBA表示一个颜色和RGB类似，只不过比 RGB多了一个A（alpha）来表示透明度， 透明度需要一个0-1的值。 RGBA(255,100,5,0.5) – 0表示完全透明， 1表示完全不透明。 2. 文字属性2.0 字体属性的简写 font可以一次性同时设置多个字体的样式。 语法： font:加粗 斜体 小型大写 大小/行高 字体 这里前边几个加粗、斜体和小型大写的顺 序无所谓，也可以不写，但是大小和字体 必须写且必须写到后两个。 2.1 文字大小 font-size用来指定文字的大小。 2.2 字体 font-family可以指定标签中文字使用 的字体。 例如：p{font-family:Arial} 通过font-family可以同时指定多个字体。 例如：p{font-family:Arial , Helvetica , sans-serif} 这里面sans-serif并不是指的具体某一个字体。而是一类字体。 2.3 字体分类 serif（衬线字体） sans-serif（非衬线字体） monospace （等宽字体） cursive （草书字体） fantasy （虚幻字体） 以上这些分类都是一些大的分类，并没有 涉及具体的类型，如果将字体指定为这些 格式，浏览器会自己选择指定类型的字体。 2.4 斜体和粗体 font-style用来指定文本的斜体。 – 指定斜体：font-style:italic – 指定非斜体：font-style:normal font-weight用来指定文本的粗体。 – 指定粗体：font-weight:bold – 指定非粗体：font-weight:normal 2.5 小型大写字母 font-variant属性可以将字母类型设置为小型大写。 – font-variant:small-caps 2.6 行间距 line-height用于设置行高，行高越大则行 间距越大。 行间距 = line-height – font-size 2.7 大写化 text-transform样式用于将元素中的字母全 都变成大小。 大写：text-transform:uppercase 小写：text-tansform:lowercase 首字母大写： text-transform:capitalize 正常：text-transform:none 2.8 文本的修饰 text-decoration属性，用来给文本添加各 种修饰。通过它可以为文本的上方、下方 或者中间添加线条。 可选值：underline / overline /line-through / none 2.9 字母间距和单词间距 letter-spacing用来设置字符之间的间距。 word-spacing用来设置单词之间的间距。 这两个属性都可以直接指定一个长度或百分数作为值。正数代表的是增加距离，而负数代表减少距离。 2.10 对齐文本 text-align用于设置文本的对齐方式。 可选值： – left：左对齐 – right：右对齐 – justify：两边对齐 – center：居中对齐 2.11 首行缩进 text-indent用来设置首行缩进。 该样式需要指定一个长度，并且只对第一 行生效。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>样式表</tag>
        <tag>css基本语法</tag>
        <tag>文本格式化</tag>
        <tag>文字属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F10%2F09%2FA-01-HTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. HTML简介1.1 HTML概述 HTML(Hypertext Markup Language)：超文本标记语言。 它负责网页三要素中的 结构。 HTML使用标签的的形式来标识网页中的不 同组成部分。 所谓超文本指的是超链接，使用超链接可 以让我们从一个页面跳转到另一个页面。 1.2 标签 HTML中的标记指的就是标签 HTML使用标记标签来描述网页 结构： 1.&lt;标签名&gt;标签内容&lt;/标签&gt; 2.&lt;标签名 /&gt; 1.3 元素 我们还将一个完整的标签称为元素 父元素、子元素、祖先元素、后代元素1.4 属性 通过属性为HTML元素提供附加信息。 属性需要设置在开始标签或自结束标签中。 属性总是以名称/值对的形式出现。 有些属性可以是任意值，有些则必须是指定值。 常见属性 ：id、class、tittle 1.5 注释 HTML注释中的内容不会在网页中显示。 格式: &lt;!– 注释内容 –&gt; 注释不能嵌套！2. HTML的发展2.1 发展历史 1993年6月：HTML第一个版本发布。 1995年11月：HTML2.0 1997年1月：HTML3.2（W3C推荐） 1999年12月：HTML4.01（W3C推荐） 2000年底：XHTML1.0（W3C推荐） 2014年10月：HTML5（W3C推荐）2.2 doctype(文档声明) 说明：不进行文档声明或者不进行正确的文档声明浏览器有可能会出现 怪异模式，为避免这种情况，所以一定要进行正确的文档声明 html4 1.过渡版:&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 2.严格版:&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 3.框架集:&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN” “http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; xhtml1.0 1.过渡版:&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “ http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 2.严格版:&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 3.框架集:&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; html5 &lt;!DOCTYPE html&gt; 3. 编码3.1 编码问题 在计算机的内部，文件都是以二进制编码 保存的。 所谓的二进制编码就是指1和0，也就是我 们的所有内容都需要转换为1和0。 中国两个字在计算机的底层保存的可能要 转换为10100101这种二进制码，这一过程 称为编码。 计算机在读取文件时需要将10100101在转 换为中国给我们显示这一过程称为解码。 3.2 字符集 字 符集规定了如何将文本转换为二进制编码。 常见的字符集：ASKII、ISO8859-1、GBK、 GB2312、UTF-8。 如果编码和解码所用的字符集不一致，就会出现乱码问题。 为了避免乱码，我们统一使用utf-8。 &lt;meta charset=”utf-8” /&gt; 3.3 &lt;meta&gt; meta的作用： –&lt;meta&gt; 标签可提供有关页面的元信息，比如 针对搜索引擎和更新频度的描述和关键词。 –&lt;meta&gt; 标签位于文档的头部，不包含任何内 容。&lt;meta&gt; 标签的属性定义了与文档相关联 的名称/值对。 meta的用法: – 设置页面的字符集 :&lt;meta charset=”utf-8”&gt; – 设置网页的描 :&lt;meta name=”description” content=””&gt; – 设置页面的关键字 :&lt;meta name=”keywords” content=””&gt; – 请求的重定向 :&lt;meta http-equiv=”refresh” content=”5;url=地址”/&gt; 4. 常用标签4.1 &lt;html&gt; 作用：&lt;html&gt;标签用于告诉浏览器这个文档中包含 的信息是用HTML编写的。 用法：\ 所有的网页的内容都需要编写到html标签中， 一个页面中html标签只能有一个；html标签中有两个子标签head和body。 4.2 &lt;head&gt; 作用：&lt;head&gt;标签用来表示网页的元数据，head中 包含了浏览器和搜索引擎使用的其他不可见信 息。 用法： head标签作为html标签的子元素的出现，一 个网页中只能有一个head。 4.3 &lt;title&gt; 作用：&lt;title&gt;标签表示网页的标题，一般会在网页的标 题栏上显示；title标签中的文字，是页面优化的最重要因素。在 搜索引擎的搜索时最先看到的、最醒目的内容。 用法： 建议将title标签紧贴着head标签编写，这样搜索 引擎可以快速检索到标题标签； 网站中的多个页面的title也不应该重复，这样不利 于搜索隐藏检索。 4.4 &lt;body&gt; 作用：&lt;body&gt;标签用来设置网页的主体，所有在页 面中能看到的内容都应该编写到body标签中。 用法： body标签作为html的子标签使用。 4.5 &lt;h1&gt;~&lt;h6&gt; 作用：h1h6都是网页中的标题标签，用来表示网页 中的一个标题，不同的是，从h1h6重要性越 来越低； 标题标签相当于正文的标题，通常认为重要性 仅次于页面的title； 一般标题标签我们只会使用到h3，h3以后的标 题标签对于搜索引擎就没有什么意义了； 一个页面中只会使用一个h1标签。 4.6 &lt;p&gt; 作用：\ 标签表示网页中的一个段落； 一般浏览器会在段落的前和后各加上一个换行， 也就是段落会在页面中自成一行。 4.7 &lt;br /&gt; 作用：&lt;br /&gt;标签表示一个换行标签，使用br标签可 以使br标签后的内容另起一行。 4.8 &lt;hr /&gt; 作用：&lt;hr /&gt;标签是水平线标签，使用hr标签可以在 页面中打印一条水平线，水平线可以将页面分 成上下两个部分。 4.9 &lt;img /&gt; 作用：&lt; img /&gt;标签是图片标签，可以用来向页面中 引入一张外部的图片。 属性： src • 指向一个外部的图片的路径；alt • 图片的描述 4.10 &lt;a&gt; 作用：标签是超链接标签，通过a标签，可以快 速跳转到其他页面。 属性：href • 指向一个链接地址；– target • 设置打开目标页面的位置(可选值：_blank新窗口、 _self当前窗口)。5. 实体(转义字符)5.1 实体 在HTML中预留了一些字符，这些预留字符是不能在网页中直接使用的。 比如&lt;和&gt;,我们不能直接在页面中使用&lt;和 &gt;号，因为浏览器会将它解析为html标签 为了可以使用这些预留字符，我们必须在 html中使用字符实体。 语法: &amp;实体名;5.2 实体字符 小于号&lt; : &amp;lt; 大于号&gt; : &amp;gt; 空格 : &amp;nbsp; 和符号&amp; : &amp;amp 版权© : &amp;copy; 引号” : &amp;quot; 注册商标® : &amp;reg;商标™ : &amp;trade;6. 开发工具6.1 文本编辑器 记事本 Notepad++(免费) Sublime(收费)6.2 IDE(集成开发工具) DreamWeaver（收费） WebStorm（收费） Hbuilder（免费） 7. 文本标签7.1 &lt;em&gt;和&lt;strong&gt; em标签用于表示一段内容中的着重点。 strong标签用于表示一个内容的重要性。 通常em显示为斜体，而strong显示为粗体；这两个标签可以单独使用，也可以一起使用。7.2 &lt;i&gt;和&lt;b&gt; i标签会使文字变成斜体。 b标签会使文字变成粗体。 这两个标签和em和strong类似，但是这两个标签没有语义。 所以根据html5标准，当我们只想设置文本 特殊显示，而不需要强调内容时就可以使 用i和b标签。7.3 &lt;small&gt; small标签表示细则一类的旁注，通常包括 免责声明、注意事项、法律限制、版权信 息等。 浏览器在显示small标签时会显示一个比父 元素小的字号。7.4 &lt;cite&gt; 使用cite标签(《》)可以指明对某内容的引用或参 考。例如，戏剧、文章或图书的标题，歌 曲、电影、照片或雕塑的名称等。7.5 &lt;blockquote&gt;和&lt;q&gt; blockquote和q表示标记引用的文本。 blockquote用于长引用(“”)，q用于短引用。 在两个标签中还可以使用cite属性来表示引用的地址。7.6 &lt;sup&gt;和&lt;sub&gt; sup和sub用于定义上标和下标7.7 &lt;ins&gt;和&lt;del&gt; ins表示插入的内容，显示时通常会加上下 划线。 del表示删除的内容，显示时通常会加上删 除线。7.8 &lt;code&gt;和&lt;pre&gt; 如果你的内容包含代码示例或文件名，就 可以使用code元素。 pre元素表示的是预格式化文本，可以使用 pre包住code来表示一段代码。7.9 有序列表 使用ol和li来创建一个有序列表。7.10 无序列表 使用ul和li来创建一个有序列表。7.9 定义列表 使用dl、dd、dt来创建一个定义列表。12345678&lt;dl&gt; &lt;dt&gt;定义项1&lt;/dt&gt; &lt;dd&gt;定义描述1&lt;/dd&gt; &lt;dt&gt;定义项2&lt;/dt&gt; &lt;dd&gt;定义描述2&lt;/dd&gt; &lt;dt&gt;定义项3&lt;/dt&gt; &lt;dd&gt;定义描述3&lt;/dd&gt; &lt;/dl&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
        <category>HTML基础</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html的发展</tag>
        <tag>html标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java循环语句语]]></title>
    <url>%2F2019%2F10%2F08%2F03-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[1. switch语句1.1 switch语句结构（掌握） 格式 123456789101112switch (表达式) &#123; case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程： 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 1.2 switch语句练习-春夏秋冬（应用） 需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。 运行结果： 1234春：3、4、5夏：6、7、8秋：9、10、11冬：1、2、12 示例代码： 123456789101112131415161718192021222324252627282930313233public class Demo1 &#123; public static void main(String[] args) &#123; //键盘录入月份数据，使用变量接收 Scanner sc = new Scanner(System.in); System.out.println("请输入一个月份："); int month = sc.nextInt(); //case穿透 switch(month) &#123; case 1: case 2: case 12: System.out.println("冬季"); break; case 3: case 4: case 5: System.out.println("春季"); break; case 6: case 7: case 8: System.out.println("夏季"); break; case 9: case 10: case 11: System.out.println("秋季"); break; default: System.out.println("你输入的月份有误"); &#125; &#125;&#125; 注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。 2. for循环2.1 for循环结构（掌握） 循环： 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 for循环格式： 123for (初始化语句;条件判断语句;条件控制语句) &#123; 循环体语句;&#125; 格式解释： 初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去 循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去 执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 2.2 for循环练习-输出数据（应用） 需求：在控制台输出1-5和5-1的数据 示例代码： 12345678910111213public class ForTest01 &#123; public static void main(String[] args) &#123; //需求：输出数据1-5 for(int i=1; i&lt;=5; i++) &#123; System.out.println(i); &#125; System.out.println("--------"); //需求：输出数据5-1 for(int i=5; i&gt;=1; i--) &#123; System.out.println(i); &#125; &#125;&#125; 2.3 for循环练习-求和（应用） 需求：求1-5之间的数据和，并把求和结果在控制台输出 示例代码： 12345678910111213141516171819202122public class ForTest02 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //从1开始到5结束的数据，使用循环结构完成 for(int i=1; i&lt;=5; i++) &#123; //将反复进行的事情写入循环结构内部 // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中 sum += i; /* sum += i; sum = sum + i; 第一次：sum = sum + i = 0 + 1 = 1; 第二次：sum = sum + i = 1 + 2 = 3; 第三次：sum = sum + i = 3 + 3 = 6; 第四次：sum = sum + i = 6 + 4 = 10; 第五次：sum = sum + i = 10 + 5 = 15; */ &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println("1-5之间的数据和是：" + sum); &#125;&#125; 本题要点： 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的 2.4 for循环练习-求偶数和（应用） 需求：求1-100之间的偶数和，并把求和结果在控制台输出 } 示例代码： 123456789101112131415public class ForTest03 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同 for(int i=1; i&lt;=100; i++) &#123; //对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数 if(i%2 == 0) &#123; sum += i; &#125; &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println("1-100之间的偶数和是：" + sum); &#125;&#125; 2.5 for循环练习-水仙花（应用） 需求：在控制台输出所有的“水仙花数” 解释：什么是水仙花数？ 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数 例如153 3*3*3 + 5*5*5 + 1*1*1 = 153 思路： 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数 示例代码 1234567891011121314151617public class ForTest04 &#123; public static void main(String[] args) &#123; //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i=100; i&lt;1000; i++) &#123; //在计算之前获取三位数中每个位上的值 int ge = i%10; int shi = i/10%10; int bai = i/10/10%10; //判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等 if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123; //输出满足条件的数字就是水仙花数 System.out.println(i); &#125; &#125; &#125;&#125; 2.6 for循环练习-统计水仙花数个数（应用） 需求：统计“水仙花数”一共有多少个，并在控制台输出个数 示例代码： 12345678910111213141516171819public class ForTest05 &#123; public static void main(String[] args) &#123; //定义变量count，用于保存“水仙花数”的数量，初始值为0 int count = 0; //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i=100; i&lt;1000; i++) &#123; //在计算之前获取三位数中每个位上的值 int ge = i%10; int shi = i/10%10; int bai = i/10/10%10; //在判定水仙花数的过程中，满足条件不再输出，更改为修改count的值，使count+1 if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123; count++; &#125; &#125; //打印输出最终结果 System.out.println("水仙花共有：" + count + "个"); &#125;&#125; 本题要点： 今后如果需求带有统计xxx，请先想到计数器变量 计数器变量定义的位置，必须在循环外部 3. while循环3.1 while结构（掌握） while循环完整格式： 12345初始化语句;while (条件判断语句) &#123; 循环体语句; 条件控制语句;&#125; while循环执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 示例代码： 12345678910111213141516public class WhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次"HelloWorld" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println("HelloWorld"); &#125; System.out.println("--------"); //while循环实现 int j = 1; while(j&lt;=5) &#123; System.out.println("HelloWorld"); j++; &#125; &#125;&#125; 3.2 while循环练习-珠穆朗玛峰（应用） 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度? 示例代码： 1234567891011121314151617181920public class WhileTest &#123; public static void main(String[] args) &#123; //定义一个计数器，初始值为0 int count = 0; //定义纸张厚度 double paper = 0.1; //定义珠穆朗玛峰的高度 int zf = 8844430; //因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环 //折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度 while(paper &lt;= zf) &#123; //循环的执行过程中每次纸张折叠，纸张的厚度要加倍 paper *= 2; //在循环中执行累加，对应折叠了多少次 count++; &#125; //打印计数器的值 System.out.println("需要折叠：" + count + "次"); &#125;&#125; 4. 循环细节4.1 do…while循环结构（掌握） 完整格式： 12345初始化语句;do &#123; 循环体语句; 条件控制语句;&#125;while(条件判断语句); 执行流程： ① 执行初始化语句 ② 执行循环体语句 ③ 执行条件控制语句 ④ 执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行 ⑤ 回到②继续 示例代码： 12345678910111213141516public class DoWhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次"HelloWorld" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println("HelloWorld"); &#125; System.out.println("--------"); //do...while循环实现 int j = 1; do &#123; System.out.println("HelloWorld"); j++; &#125;while(j&lt;=5); &#125;&#125; 4.2 三种循环的区别（理解） 三种循环的区别 for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行） do…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断） for循环和while的区别 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用 死循环（无限循环）的三种格式 for(;;){} while(true){} do {} while(true); 4.3 跳转控制语句（掌握） 跳转控制语句（break） 跳出循环，结束循环 跳转控制语句（continue） 跳过本次循环，继续下次循环 注意： continue只能在循环中进行使用！ 4.4 循环嵌套（理解） 循环嵌套概述：在循环中，继续定义循环 示例代码： 123456789public static void main(String[] args) &#123; //外循环控制小时的范围，内循环控制分钟的范围 for (int hour = 0; hour &lt; 24; hour++) &#123; for (int minute = 0; minute &lt; 60; minute++) &#123; System.out.println(hour + "时" + minute + "分"); &#125; System.out.println("--------"); &#125; &#125; 理解： 请反复理解这句话（整个内循环，就是外循环的一个循环体，内部循环体没有执行完毕，外循环是不会继续向下执行的） 结论： 外循环执行一次，内循环执行一圈 5. Random5.1 Random产生随机数（掌握） 概述： Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能 API后续课程详细讲解，现在可以简单理解为Java已经写好的代码 使用步骤： 导入包 import java.util.Random; 创建对象 Random r = new Random(); 产生随机数 int num = r.nextInt(10); 解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19 示例代码： 12345678910111213141516import java.util.Random;public class RandomDemo &#123; public static void main(String[] args) &#123; //创建对象 Random r = new Random(); //用循环获取10个随机数 for(int i=0; i&lt;10; i++) &#123; //获取随机数 int number = r.nextInt(10); System.out.println("number:" + number); &#125; //需求：获取一个1-100之间的随机数 int x = r.nextInt(100) + 1; System.out.println(x); &#125;&#125; 5.3 Random练习-猜数字（应用） 需求： 程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 A. 如果猜的数字比真实数字大，提示你猜的数据大了 B. 如果猜的数字比真实数字小，提示你猜的数据小了 C. 如果猜的数字与真实数字相等，提示恭喜你猜中了 示例代码： 123456789101112131415161718192021222324252627282930import java.util.Random;import java.util.Scanner;public class RandomTest &#123; public static void main(String[] args) &#123; //要完成猜数字的游戏，首先需要有一个要猜的数字，使用随机数生成该数字，范围1到100 Random r = new Random(); int number = r.nextInt(100) + 1; while(true) &#123; //使用程序实现猜数字，每次均要输入猜测的数字值，需要使用键盘录入实现 Scanner sc = new Scanner(System.in); System.out.println("请输入你要猜的数字："); int guessNumber = sc.nextInt(); //比较输入的数字和系统产生的数据，需要使用分支语句。 //这里使用if..else..if..格式，根据不同情况进行猜测结果显示 if(guessNumber &gt; number) &#123; System.out.println("你猜的数字" + guessNumber + "大了"); &#125; else if(guessNumber &lt; number) &#123; System.out.println("你猜的数字" + guessNumber + "小了"); &#125; else &#123; System.out.println("恭喜你猜中了"); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>流程控制语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础语法02]]></title>
    <url>%2F2019%2F10%2F08%2F02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java基础语法1. 运算符1.1 算术运算符（理解）1.1.1 运算符和表达式运算符：对常量或者变量进行操作的符号 表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。 ​ 不同运算符连接的表达式体现的是不同类型的表达式。 举例说明： 123int a = 10;int b = 20;int c = a + b; +：是运算符，并且是算术运算符。 a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。 1.1.2 算术运算符 符号 作用 说明 + 加 参看小学一年级 - 减 参看小学一年级 * 乘 参看小学二年级，与“×”相同 / 除 参看小学二年级，与“÷”相同 % 取余 获取的是两个数据做除法的余数 注意： /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。 1234int a = 10;int b = 3;System.out.println(a / b); // 输出结果3System.out.println(a % b); // 输出结果1 1.1.3 字符的“+”操作char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值： ‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加 ‘A’ – 65 A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加 ‘0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加 123456789// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少char ch1 = 'a';System.out.println(ch1 + 1); // 输出98，97 + 1 = 98char ch2 = 'A';System.out.println(ch2 + 1); // 输出66，65 + 1 = 66char ch3 = '0';System.out.println(ch3 + 1); // 输出49，48 + 1 = 49 算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。 提升规则： byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。 整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型 ​ 等级顺序：byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double 例如： 123456789byte b1 = 10;byte b2 = 20;// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度int i3 = b1 + b2; // 应该使用int接收byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型-------------------------------int num1 = 10;double num2 = 20.0;double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型 tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。 1.1.4 字符串的“+”操作当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。 1System.out.println("itheima"+ 666); // 输出：itheima666 在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。 1234System.out.println(1 + 99 + "年黑马"); // 输出：199年黑马System.out.println(1 + 2 + "itheima" + 3 + 4); // 输出：3itheima34// 可以使用小括号改变运算的优先级 System.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7 1.2 赋值运算符（应用）赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。 符号 作用 说明 = 赋值 a=10，将10赋值给变量a += 加后赋值 a+=b，将a+b的值给a -= 减后赋值 a-=b，将a-b的值给a *= 乘后赋值 a*=b，将a×b的值给a /= 除后赋值 a/=b，将a÷b的商给a %= 取余后赋值 a%=b，将a÷b的余数给a 注意： 扩展的赋值运算符隐含了强制类型转换。 1234short s = 10;s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10); 1.3 自增自减运算符（理解） 符号 作用 说明 ++ 自增 变量的值加1 – 自减 变量的值减1 注意事项： ​ ++和– 既可以放在变量的后边，也可以放在变量的前边。 ​ 单独使用的时候， ++和– 无论是放在变量的前边还是后边，结果是一样的。 ​ 参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者–。 ​ 参与操作的时候，如果放在变量的前边，先拿变量做++或者–，后拿变量参与操作。 ​ 最常见的用法：单独使用。 123456789101112131415int i = 10;i++; // 单独使用System.out.println("i:" + i); // i:11int j = 10;++j; // 单独使用System.out.println("j:" + j); // j:11int x = 10;int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1System.out.println("x:" + x + ", y:" + y); // x:11，y:10int m = 10;int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1System.out.println("m:" + m + ", m:" + m); // m:11，m:11 练习： 123456789int x = 10;int y = x++ + x++ + x++;System.out.println(y); // y的值是多少？/*解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。所以整个式子应该是：int y = 10 + 11 + 12;输出结果为33。*/注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！ 1.4 关系运算符（应用）关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。 符号 说明 == a==b，判断a和b的值是否相等，成立为true，不成立为false != a!=b，判断a和b的值是否不相等，成立为true，不成立为false &gt; a&gt;b，判断a是否大于b，成立为true，不成立为false &gt;= a&gt;=b，判断a是否大于等于b，成立为true，不成立为false &lt; a&lt;b，判断a是否小于b，成立为true，不成立为false &lt;= a&lt;=b，判断a是否小于等于b，成立为true，不成立为false 注意事项： ​ 关系运算符的结果都是boolean类型，要么是true，要么是false。 ​ 千万不要把“==”误写成“=”，”==”是判断是否相等的关系，”=”是赋值。 123456789101112int a = 10;int b = 20;System.out.println(a == b); // falseSystem.out.println(a != b); // trueSystem.out.println(a &gt; b); // falseSystem.out.println(a &gt;= b); // falseSystem.out.println(a &lt; b); // trueSystem.out.println(a &lt;= b); // true// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量boolean flag = a &gt; b;System.out.println(flag); // 输出false 1.5 逻辑运算符（应用）逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。 符号 作用 说明 &amp; 逻辑与 a&amp;b，a和b都是true，结果为true，否则为false | 逻辑或 a|b，a和b都是false，结果为false，否则为true ^ 逻辑异或 a^b，a和b结果不同为true，相同为false ! 逻辑非 !a，结果和a的结果正好相反 1234567891011121314151617181920212223242526272829//定义变量int i = 10;int j = 20;int k = 30;//&amp; “与”，并且的关系，只要表达式中有一个值为false，结果即为falseSystem.out.println((i &gt; j) &amp; (i &gt; k)); //false &amp; false,输出falseSystem.out.println((i &lt; j) &amp; (i &gt; k)); //true &amp; false,输出falseSystem.out.println((i &gt; j) &amp; (i &lt; k)); //false &amp; true,输出falseSystem.out.println((i &lt; j) &amp; (i &lt; k)); //true &amp; true,输出trueSystem.out.println("--------");//| “或”，或者的关系，只要表达式中有一个值为true，结果即为trueSystem.out.println((i &gt; j) | (i &gt; k)); //false | false,输出falseSystem.out.println((i &lt; j) | (i &gt; k)); //true | false,输出trueSystem.out.println((i &gt; j) | (i &lt; k)); //false | true,输出trueSystem.out.println((i &lt; j) | (i &lt; k)); //true | true,输出trueSystem.out.println("--------");//^ “异或”，相同为false，不同为trueSystem.out.println((i &gt; j) ^ (i &gt; k)); //false ^ false,输出falseSystem.out.println((i &lt; j) ^ (i &gt; k)); //true ^ false,输出trueSystem.out.println((i &gt; j) ^ (i &lt; k)); //false ^ true,输出trueSystem.out.println((i &lt; j) ^ (i &lt; k)); //true ^ true,输出falseSystem.out.println("--------");//! “非”，取反System.out.println((i &gt; j)); //falseSystem.out.println(!(i &gt; j)); //!false，,输出true 短路逻辑运算符 符号 作用 说明 &amp;&amp; 短路与 作用和&amp;相同，但是有短路效果 || 短路或 作用和|相同，但是有短路效果 在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。 逻辑与&amp;，无论左边真假，右边都要执行。 短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。 逻辑或|，无论左边真假，右边都要执行。 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。 123456789int x = 3;int y = 4;System.out.println((x++ &gt; 4) &amp; (y++ &gt; 5)); // 两个表达都会运算System.out.println(x); // 4System.out.println(y); // 5System.out.println((x++ &gt; 4) &amp;&amp; (y++ &gt; 5)); // 左边已经可以确定结果为false，右边不参与运算System.out.println(x); // 4System.out.println(y); // 4 1.6 三元运算符（理解）三元运算符语法格式： 1关系表达式 ? 表达式1 : 表达式2; 解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。 举例： 123int a = 10;int b = 20;int c = a &gt; b ? a : b; // 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值 三元运算符案例： 1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。 1234567891011public class OperatorTest01 &#123; public static void main(String[] args) &#123; //1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。 int weight1 = 180; int weight2 = 200; //2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。 boolean b = weight1 == weight2 ? true : false; //3：输出结果 System.out.println("b:" + b); &#125;&#125; 2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。 1234567891011121314public class OperatorTest02 &#123; public static void main(String[] args) &#123; //1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。 int height1 = 150; int height2 = 210; int height3 = 165; //2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。 int tempHeight = height1 &gt; height2 ? height1 : height2; //3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。 int maxHeight = tempHeight &gt; height3 ? tempHeight : height3; //4：输出结果 System.out.println("maxHeight:" + maxHeight); &#125;&#125; 2. 数据输入（应用）我们可以通过 Scanner 类来获取用户的输入。使用步骤如下： 1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。 1import java.util.Scanner; 2、创建Scanner对象。 1Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变 3、接收数据 1int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。 示例： 1234567891011import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; //创建对象 Scanner sc = new Scanner(System.in); //接收数据 int x = sc.nextInt(); //输出数据 System.out.println("x:" + x); &#125;&#125; 改写三个和尚案例，数据使用键盘录入。 1234567891011121314151617181920import java.util.Scanner;public class ScannerTest &#123; public static void main(String[] args) &#123; //身高未知，采用键盘录入实现。首先导包，然后创建对象。 Scanner sc = new Scanner(System.in); //键盘录入三个身高分别赋值给三个变量。 System.out.println("请输入第一个和尚的身高："); int height1 = sc.nextInt(); System.out.println("请输入第二个和尚的身高："); int height2 = sc.nextInt(); System.out.println("请输入第三个和尚的身高："); int height3 = sc.nextInt(); //用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。 int tempHeight = height1 &gt; height2 ? height1 : height2; //用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。 int maxHeight = tempHeight &gt; height3 ? tempHeight : height3; //输出结果。 System.out.println("这三个和尚中身高最高的是：" + maxHeight +"cm"); &#125;&#125; 3. 流程控制语句（应用）在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。 3.1 流程控制语句分类​ 顺序结构 ​ 分支结构(if, switch) ​ 循环结构(for, while, do…while) 3.2 顺序结构顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。 顺序结构执行流程图： 3.3 分支结构之if语句if语句格式11234格式：if (关系表达式) &#123; 语句体; &#125; 执行流程： ①首先计算关系表达式的值 ②如果关系表达式的值为true就执行语句体 ③如果关系表达式的值为false就不执行语句体 ④继续执行后面的语句内容 示例： 123456789101112131415161718public class IfDemo &#123; public static void main(String[] args) &#123; System.out.println("开始"); //定义两个变量 int a = 10; int b = 20; //需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b if(a == b) &#123; System.out.println("a等于b"); &#125; //需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c int c = 10; if(a == c) &#123; System.out.println("a等于c"); &#125; System.out.println("结束"); &#125;&#125; if语句格式2123456格式：if (关系表达式) &#123; 语句体1; &#125; else &#123; 语句体2; &#125; 执行流程： ①首先计算关系表达式的值 ②如果关系表达式的值为true就执行语句体1 ③如果关系表达式的值为false就执行语句体2 ④继续执行后面的语句内容 示例： 12345678910111213141516public class IfDemo02 &#123; public static void main(String[] args) &#123; System.out.println("开始"); //定义两个变量 int a = 10; int b = 20; b = 5; //需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b if(a &gt; b) &#123; System.out.println("a的值大于b"); &#125; else &#123; System.out.println("a的值不大于b"); &#125; System.out.println("结束"); &#125;&#125; if语句案例：奇偶数 需求：任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。 分析： ​ ①为了体现任意给出一个整数，采用键盘录入一个数据 ​ ②判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构 ​ ③判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0 ​ ④根据判定情况，在控制台输出对应的内容 1234567891011121314151617import java.util.Scanner;public class IfTest01 &#123; public static void main(String[] args) &#123; //为了体现任意给出一个整数，采用键盘录入一个数据。(导包，创建对象，接收数据) Scanner sc = new Scanner(System.in); System.out.println("请输入一个整数："); int number = sc.nextInt(); //判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构 //判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0 //根据判定情况，在控制台输出对应的内容 if(number%2 == 0) &#123; System.out.println(number + "是偶数"); &#125; else &#123; System.out.println(number + "是奇数"); &#125; &#125;&#125; if语句格式312345678910格式：if (关系表达式1) &#123; 语句体1; &#125; else if (关系表达式2) &#123; 语句体2; &#125; …else &#123; 语句体n+1;&#125; 执行流程： ①首先计算关系表达式1的值 ②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值 ③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值 ④… ⑤如果没有任何关系表达式为true，就执行语句体n+1。 示例：键盘录入一个星期数(1,2,…7)，输出对应的星期一，星期二，…星期日 1234567891011121314151617181920212223242526import java.util.Scanner;public class IfDemo03 &#123; public static void main(String[] args) &#123; System.out.println("开始"); // 需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日 Scanner sc = new Scanner(System.in); System.out.println("请输入一个星期数(1-7)："); int week = sc.nextInt(); if(week == 1) &#123; System.out.println("星期一"); &#125; else if(week == 2) &#123; System.out.println("星期二"); &#125; else if(week == 3) &#123; System.out.println("星期三"); &#125; else if(week == 4) &#123; System.out.println("星期四"); &#125; else if(week == 5) &#123; System.out.println("星期五"); &#125; else if(week == 6) &#123; System.out.println("星期六"); &#125; else &#123; System.out.println("星期日"); &#125; System.out.println("结束"); &#125;&#125; if语句格式3案例： 需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。 分析： ​ ①小明的考试成绩未知，可以使用键盘录入的方式获取值 ​ ②由于奖励种类较多，属于多种判断，采用if…else…if格式实现 ​ ③为每种判断设置对应的条件 ​ ④为每种判断设置对应的奖励 123456789101112131415161718192021222324import java.util.Scanner;public class IfTest02 &#123; public static void main(String[] args) &#123; //小明的考试成绩未知，可以使用键盘录入的方式获取值 Scanner sc = new Scanner(System.in); System.out.println("请输入一个分数："); int score = sc.nextInt(); //由于奖励种类较多，属于多种判断，采用if...else...if格式实现 //为每种判断设置对应的条件 //为每种判断设置对应的奖励 //数据测试：正确数据，边界数据，错误数据 if(score&gt;100 || score&lt;0) &#123; System.out.println("你输入的分数有误"); &#125; else if(score&gt;=95 &amp;&amp; score&lt;=100) &#123; System.out.println("山地自行车一辆"); &#125; else if(score&gt;=90 &amp;&amp; score&lt;=94) &#123; System.out.println("游乐场玩一次"); &#125; else if(score&gt;=80 &amp;&amp; score&lt;=89) &#123; System.out.println("变形金刚玩具一个"); &#125; else &#123; System.out.println("胖揍一顿"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Path环境变量</tag>
        <tag>java基础语法</tag>
        <tag>流程控制语句</tag>
        <tag>运算符</tag>
        <tag>数据输入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础语法01]]></title>
    <url>%2F2019%2F10%2F08%2F01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. Java概述1.1 Java语言发展史（了解）语言：人与人交流沟通的表达方式 计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言 Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言 Java之父：詹姆斯·高斯林（James Gosling） 2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：https://www.oracle.com 当前，我们课程使用的JDK版本：11.0 1.2 Java语言跨平台原理（理解）Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。 1.3 JRE和JDK（记忆）JVM（Java Virtual Machine），Java虚拟机 JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API） JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具 总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。 1.4 JDK的下载和安装（应用）1.4.1 下载通过官方网站获取JDK http://www.oracle.com 注意：针对不同的操作系统，需要下载对应版本的JDK。 具体下载步骤请参见《JDK下载及安装说明文档》 1.4.2 安装傻瓜式安装，下一步即可。但默认的安装路径是在C:\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\develop。 注意：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。 具体安装步骤请参见《JDK下载及安装说明文档》 1.4.3 JDK的安装目录介绍 目录名称 说明 bin 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 conf 该路径下存放了JDK的相关配置文件。 include 该路径下存放了一些平台特定的头文件。 jmods 该路径下存放了JDK的各种模块。 legal 该路径下存放了JDK各模块的授权文档。 lib 该路径下存放了JDK工具的一些补充JAR包。 2. 第一个演示程序2.1 常用DOS命令（应用）在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。 1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。 2、常用命令及其作用 操作 说明 盘符名称: 盘符切换。E:回车，表示切换到E盘。 dir 查看当前路径下的内容。 cd 目录 进入单级目录。cd itheima cd .. 回退到上一级目录。 cd 目录1\目录2... 进入多级目录。cd itheima\JavaSE cd \ 回退到盘符目录。 cls 清屏。 exit 退出命令提示符窗口。 2.2 Path环境变量的配置（应用）2.2.1 为什么配置环境变量开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以配置环境变量的作用就是可以使bin目录下的java相关命令可以在任意目录下使用。 2.2.2 配置环境变量步骤具体配置步骤请参见《Java环境变量配置说明》文档。 2.3 HelloWorld案例（应用）HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。各种计算机语言都习惯使用该案例作为第一个演示案例。 2.3.1 Java程序开发运行流程开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。 2.3.2 HelloWorld案例的编写1、新建文本文档文件，修改名称为HelloWorld.java。 2、用记事本打开HelloWorld.java文件，输写程序内容。 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; 2.3.3 HelloWorld案例的编译和运行存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。 编译：javac 文件名.java 范例：javac HelloWorld.java 执行：java 类名 范例：java HelloWorld 2.4 HelloWorld案例常见问题（理解）2.4.1 BUG在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。 2.4.2 BUG的解决1、具备识别BUG的能力：多看 2、具备分析BUG的能力：多思考，多查资料 3、具备解决BUG的能力：多尝试，多总结 2.4.3 HelloWorld案例常见问题1、非法字符问题。Java中的符号都是英文格式的。 2、大小写问题。Java语言对大小写敏感（区分大小写）。 3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。 4、编译命令后的java文件名需要带文件后缀.java 5、运行命令后的class文件名（类名）不带文件后缀.class … 2.5 Notepad++软件的安装和使用（应用）2.5.1 什么要使用Notepad++软件Notepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。 2.5.2 Notepad++软件安装安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\develop。 具体安装步骤请参见《Nodepad++软件安装及配置说明》文档。 2.5.3Notepad++软件配置安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。 具体配置的说明请参见《Nodepad++软件安装及配置说明》文档。 3. java基础语法3.1 注释（理解）注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种： 单行注释。单行注释的格式是使用//，从//开始至本行结尾的文字将作为注释文字。 1// 这是单行注释文字 多行注释。多行注释的格式是使用/* 和 */将一段较长的注释括起来。 123456/*这是多行注释文字这是多行注释文字这是多行注释文字*/注意：多行注释不能嵌套使用。 文档注释。文档注释以/**开始，以*/结束。（以后讲） 3.2 关键字（理解）关键字是指被java语言赋予了特殊含义的单词。 关键字的特点： ​ 关键字的字母全部小写。 ​ 常用的代码编辑器对关键字都有高亮显示，比如现在我们能看到的public、class、static等。 3.3 常量（应用）常量：在程序运行过程中，其值不可以发生改变的量。 Java中的常量分类： ​ 字符串常量 用双引号括起来的多个字符（可以包含0个、一个或多个），例如”a”、”abc”、”中国”等 ​ 整数常量 整数，例如：-10、0、88等 ​ 小数常量 小数，例如：-5.5、1.0、88.88等 ​ 字符常量 用单引号括起来的一个字符，例如：’a’、’5’、’B’、’中’等 ​ 布尔常量 布尔值，表示真假，只有两个值true和false ​ 空常量 一个特殊的值，空值，值为null 除空常量外，其他常量均可使用输出语句直接输出。 123456789public class Demo &#123; public static void main(String[] args) &#123; System.out.println(10); // 输出一个整数 System.out.println(5.5); // 输出一个小数 System.out.println('a'); // 输出一个字符 System.out.println(true); // 输出boolean值true System.out.println("欢迎来到黑马程序员"); // 输出字符串 &#125;&#125; 3.4 数据类型（记忆、应用）3.4.1 计算机存储单元我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”， 通常用大写字母”B”表示，字节是由连续的8个位组成。 除了字节外还有一些常用的存储单位，其换算单位如下： 1B（字节） = 8bit 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 3.4.2 Java中的数据类型Java是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。 Java中的基本数据类型： 数据类型 关键字 内存占用 取值范围 整数类型 byte 1 -128~127 short 2 -32768~32767 int(默认) 4 -2的31次方到2的31次方-1 long 8 -2的63次方到2的63次方-1 浮点类型 float 4 负数：-3.402823E+38到-1.401298E-45 正数： 1.401298E-45到3.402823E+38 double(默认) 8 负数：-1.797693E+308到-4.9000000E-324 正数：4.9000000E-324 到1.797693E+308 字符类型 char 2 0-65535 布尔类型 boolean 1 true，false 说明： ​ e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。 ​ 在java中整数默认是int类型，浮点数默认是double类型。 3.5 变量（应用）3.5.1 变量的定义变量：在程序运行过程中，其值可以发生改变的量。 从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。 变量的定义格式： 123数据类型 变量名 = 初始化值; // 声明变量并赋值int age = 18;System.out.println(age); 或者 123456// 先声明，后赋值（使用前赋值即可）数据类型 变量名;变量名 = 初始化值;double money;money = 55.5;System.out.println(money); 还可以在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。 123456789int a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开System.out.println(a);System.out.println(b);int c,d; // 声明int类型的变量c和d，中间使用逗号隔开c = 30;d = 40;System.out.println(c);System.out.println(d); 变量的使用：通过变量名访问即可。 3.5.2 使用变量时的注意事项 在同一对花括号中，变量名不能重复。 变量在使用之前，必须初始化（赋值）。 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。 3.6 标识符（记忆、理解）标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。 Java中标识符的组成规则： ​ 由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。 ​ 不能使用java中的关键字作为标识符。 ​ 标识符对大小写敏感（区分大小写）。 Java中标识符的命名约定： ​ 小驼峰式命名：变量名、方法名 ​ 首字母小写，从第二个单词开始每个单词的首字母大写。 ​ 大驼峰式命名：类名 ​ 每个单词的首字母都大写。 ​ 另外，标识符的命名最好可以做到见名知意 ​ 例如：username、studentNumber等。 3.7 类型转换（理解）在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。 自动类型转换： ​ 把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如： 12double num = 10; // 将int类型的10直接赋值给double类型System.out.println(num); // 输出10.0 强制类型转换： ​ 把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。 ​ 强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量; ​ 例如： 123double num1 = 5.5;int num2 = (int) num1; // 将double类型的num1强制转换为int类型System.out.println(num2); // 输出5（小数位直接舍弃） 说明： char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，’a’对应97。 12int a = 'a';System.out.println(a); // 将输出97 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。 12345678byte b1 = 10;byte b2 = 20;byte b3 = b1 + b2; // 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。// 修改为:int num = b1 + b2;// 或者：byte b3 = (byte) (b1 + b2); boolean类型不能与其他基本数据类型相互转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java发展</tag>
        <tag>JRE和JDK</tag>
        <tag>DOS命令</tag>
        <tag>Path环境变量</tag>
        <tag>java基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
