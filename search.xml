<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node之实现服务器配置]]></title>
    <url>%2F2019%2F12%2F15%2FF-03-Node%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. Web开发概述 Node.js服务器模型与php服务器模型的区别 传统的动态网站开发需要应用软件 PHP ： Apache + php模块 java ：Tomcat 、Weblogic Node.js : 不需要应用软件（可以自己实现） 2. Node.js实现静态网站功能2.1 使用http模块初步实现服务器功能 1、引入http模块：const http = require(&#39;http&#39;); 2、创建服务器实例对象：let server = http.createServer(); 3、绑定请求事件：server.on() —&gt; 详细使用可以查看文档 参数1：事件类型(request/response) 参数2：事件处理函数(参数1请求req，参数2响应res) 4、监听端口：server.listen() —&gt; 详细使用可以查看文档 参数1：端口号 参数2：IP地址(默认是localhost–&gt;127.0.0.0) 参数3：回调函数 详细代码： 12345678910111213// 详细书写 const http = require(&apos;http&apos;); let server = http.createServer(); server.on(&apos;request&apos;,(req,res)=&gt;&#123; res.end(&apos;hello&apos;) // 这里的内容会在浏览器中显示 &#125;) server.listen(3000);// 端口是80可以省略// 简写代码 http.createServer((req,res)=&gt;&#123; res.end(&apos;wcy&apos;); &#125;).listen(3000,&apos;192.168.43.131&apos;,()=&gt;&#123; console.log(&apos;running...&apos;); // 此处的内容输出在黑窗口 &#125;); 5、打开服务器(在node中执行当前文件) 6、在浏览器中打开(localhost:3000) 7、Ctrl + C —&gt; 退出服务器 这有一个缺点：不能识别路径 —&gt; 还需要处理路径的分发 2.2 实现静态服务器功能 http模块、path模块、fs模块 2.2.1 处理请求路径的分发 1、req对象是Class: http.IncomingMessage的实例对象 req.url：可以获取URL中的路径（端口之后部分） 2、res对象是Class: http.ServerResponse的实例对象 res.write(); —&gt; write向客户端响应内容,可以写多次 res.end(); —&gt; end方法用来完成响应，只能执行一次 res.writeHead() —&gt; 设置响应头(响应类型，编码) 3、代码演示 —&gt; 详细使用建议查看文档 12345678910111213141516const http = require(&apos;http&apos;);http.createServer((req,res)=&gt;&#123; // res.end(req.url); if(req.url.startsWith(&apos;/index&apos;))&#123; res.write(&apos;hello&apos;); res.write(&apos;hi&apos;); res.write(&apos;nihao&apos;); res.end(); &#125;else if(req.url.startsWith(&apos;/about&apos;))&#123; res.end(&apos;about&apos;); &#125;else&#123; res.end(&apos;no content&apos;); &#125;&#125;).listen(3000,&apos;192.168.0.106&apos;,()=&gt;&#123; console.log(&apos;running...&apos;);&#125;); 实际开发中请求的不是字符串而是整个页面—&gt;所以要进行静态资源优化 2.2.2 响应完整页面 详细代码：(事先把页面放进了当前目录下的www目录里面) 1234567891011121314151617181920212223242526272829// 根据路径读取文件的内容，并且响应到浏览器端 let readFile = (url,res) =&gt; &#123; fs.readFile(path.join(__dirname,&apos;www&apos;,url),&apos;utf8&apos;,(err,files)=&gt;&#123; if(err) &#123; res.end(&apos;server error&apos;); &#125; else &#123; res.end(files); &#125; &#125;); &#125; http.createServer((req,res)=&gt;&#123;// 处理路径的分发 if(req.url.startsWith(&apos;/index&apos;)) &#123; readFile(&apos;index.html&apos;,res); &#125; else if(req.url.startsWith(&apos;/about&apos;)) &#123; readFile(&apos;about.html&apos;,res); &#125; else if(req.url.startsWith(&apos;/list&apos;)) &#123; readFile(&apos;list.html&apos;,res) &#125; else &#123; //res.end(&apos;no content&apos;)// 设置相应类型和编码 res.writeHead(200,&#123; &apos;Content-Type&apos;:&apos;text/plain; charset=utf8&apos; &#125;) res.end(&apos;页面不存在&apos;); // 不设置编码，会出现乱码的情况 &#125; &#125;).listen(3000,&apos;192.168.43.131&apos;,()=&gt;&#123; console.log(&apos;running...&apos;); &#125;) 这种方式不够灵活，随着请求资源越来越多 —&gt; 分支会越来越多 —&gt; 会越来越难处理 2.2.3 响应完整页面(进一步处理) 详细代码：(事先把页面放进了当前目录下的www目录里面) 12345678910111213141516171819202122232425262728293031const mime = require(&apos;./mime.json&apos;);// 引入的是文件格式映射表http.createServer((req,res)=&gt;&#123; fs.readFile(path.join(__dirname,&apos;www&apos;,req.url),(err,files)=&gt;&#123; if(err) &#123;// 没有找到对应文件 res.writeHead(404,&#123; &apos;Content-Type&apos;:&apos;text/plain; charset=utf8&apos; &#125;) res.end(&apos;页面不存在！&apos;) &#125; else &#123; let dtype = &apos;text/html&apos;; // 默认的类型// 获取请求文件的后缀 let ext = path.extname(req.url);// 如果请求的文件后缀合理，就获取到标准的响应格式 if(mime[ext]) &#123; dtype = mime[ext]; &#125;// 如果响应的内容是文本，就设置成utf8编码 if(dtype.startsWith(&apos;text&apos;)) &#123; dtype += &apos;; charset=utf8&apos; &#125;// 设置响应头信息 res.writeHead(200,&#123; &apos;Content-Type&apos;:dtype &#125;); res.end(files); &#125; &#125;) &#125;).listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;); &#125;) 封装成一个模块(02.module.js) —&gt; 方便后续使用 3. 参数传递与获取3.1 get参数获取 url模块 引入模块：const http = require(&#39;url&#39;) url.parse(str,true);：parse方法的作用就是把URL字符串转化为对象 参数1：url地址 参数2：true/false —&gt; 加true(数据显示为对象)，不加显示为字符串 详细使用建议查看文档 url.format();：format的作用就是把对象转化为标准的URL字符串 参数：对象 get参数传递：可以直接在浏览器的地址栏里传入。 get参数获取： 使用url.parse()以后，obj.qurey.username / obj.qurey.password即可获取到。3.2 post参数获取 qureystring模块 引入模块：const querystring = require(&#39;querystring&#39;); querystring.parse()：parse方法的作用就是把字符串转成对象 参数：传入的参数字符串(let param = ‘username=lisi&amp;password=123’;) querystring.stringify()：stringify的作用就是把对象转成字符串 参数：对象obj post参数传递：借助插件/表单 1234let pdata = &apos;&apos;;req.on(&apos;data&apos;,(chunk)=&gt;&#123; pdata += chunk;&#125;); post参数获取：使用querystring.parse()以后，obj.username / obj.password 12345req.on(&apos;end&apos;,()=&gt;&#123; console.log(pdata); let obj = querystring.parse(pdata); res.end(obj.username + &apos;======&apos; + obj.password);&#125;); 4. 动态网站开发4.1 创建服务器实现动态网站效果5.模板引擎 解决占位符不统一的问题，使代码更加通用 安装包：npm install art-template --save5.1 引擎基本使用 详细使用建议查看文档 引入包：let template = require(&#39;art-template&#39;); template.compile(模板字符串)：编译 —-&gt; 配合 render(数据)使用 template.render() 参数1：模板字符串 参数2：数据 代码演示如何使用 12345678910111213141516171819202122//使用1： let template = require(&apos;art-template&apos;); let html = template(__dirname + &apos;/mytpl.art&apos;, &#123; user: &#123; name: &apos;lisi&apos; &#125; &#125;); console.log(html);//使用2： // let tpl = &apos;&lt;ul&gt;&#123;&#123;each list as value&#125;&#125;&lt;li&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt;&#123;&#123;/each&#125;&#125;&lt;/ul&gt;&apos;; let tpl = &apos;&lt;ul&gt;&#123;&#123;each list&#125;&#125;&lt;li&gt;&#123;&#123;$index&#125;&#125;---&#123;&#123;$value&#125;&#125;&lt;/li&gt;&#123;&#123;/each&#125;&#125;&lt;/ul&gt;&apos;; let render = template.compile(tpl); let ret = render(&#123; list : [&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;] &#125;); console.log(ret);//使用3： let tpl = &apos;&lt;ul&gt;&#123;&#123;each list&#125;&#125;&lt;li&gt;&#123;&#123;$index&#125;&#125;-------------&#123;&#123;$value&#125;&#125;&lt;/li&gt;&#123;&#123;/each&#125;&#125;&lt;/ul&gt;&apos;; let ret = template.render(tpl,&#123; list : [&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;pineapple&apos;] &#125;); console.log(ret); 6. Express基本使用 引入1：const express = require(&#39;express&#39;)(); 引入2：推荐使用 const express = require(&#39;express&#39;); const app = express(); !注意：express包返回的是一个函数，一定要调用 6.0 初步实现服务器功能 app.get() 参数1：路径 参数2：回调函数(参数1：req，参数2：res) res.send()等同于原生里面的res.end()。 代码示例： 123456789101112131415 const express = require(&apos;express&apos;); const app = erpress();// 写法1： app.get(&apos;/&apos;,(req,res)=&gt;&#123; res.send(&apos;wcy&apos;); &#125;).listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;); &#125;)// 写法2： let server = app.get(&apos;/&apos;,(req,res)=&gt;&#123; res.send(&apos;abcdefghijklmn&apos;); &#125;); server.listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;); &#125;) 6.1 静态服务器 app.use(&#39;虚拟目录&#39;,express.static(&#39;静态资源目录&#39;)); 托管静态文件 可以指定虚拟目录 可以指定多个目录作为静态资源目录 使用多个：app.use(&#39;虚拟目录&#39;,express.static(&#39;静态资源目录&#39;)); app.use() 参数1：指定一个虚拟路径(该参数可有可无) 参数2：express.static()(参数是静态资源的位置/包含静态资源的文件夹) app.listen() 参数1：端口号 参数2：IP地址 参数3：回调函数(无需传参) 代码示例： 123456789 let server = app.use(express.static(&apos;static-data&apos;)); server.listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;); &#125;)// 上述代码优化 app.use(&apos;/wcy&apos;,express.static(&apos;static-data&apos;)); app.listen(3000,()=&gt;&#123; console.log(&apos;running...&apos;); &#125;) 6.2 路由6.2.1 路由介绍 路由：根据请求路径和请求方式进行路径分发处理 http的常用请求方式：(express全部支持) post —&gt; 添加 get —&gt; 查询 put —&gt; 更新 delete —&gt; 删除 对于url来说：restful api (一种满足特定格式的URL地址)，支持上述的四种格式 6.2.1 express路由的处理 app.get()： 参数1：路径 参数2：回调函数(参数req，res) app.post()： 参数1：路径 参数2：回调函数(参数req，res) app.put()： 参数1：路径 参数2：回调函数(参数req，res) app.delete()： 参数1：路径 参数2：回调函数(参数req，res) app.use()：直接使用use分发可以处理所有的路由请求 参数：回调函数 app.use(&#39;路径&#39;,router) app.all()：all方法绑定的路由与请求方式无关 参数1：路径 参数2：回调函数(参数req，res) app.route(&#39;路径&#39;).get(回调函数).post(回调函数))：route方法可以指定特定的请求方式 6.3 中间件 详细使用建议查看文档！ 中间件：就是处理过程中的一个环节（简单理解） 中间件是一个函数，它可以访问请求对象(req)、响应对象(res)和web应用中处于请求/响应循环流程中的中间件，一般被命名为next变量。 中间件的挂载方式 use方法 路由方式:get post put delete6.3.1 应用级中间件 app.use((req,res,next)=&gt;{...; next()}); next方法的作用就是把请求传递到下一个中间件 参数1：路径(可以不写) 参数2：回调函数6.3.2 路由级中间件 app.get() app.post() app.put() app.delete() 回调函数中的next next(&#39;route)：跳转到下一个路由() 注意：是跳转到下一个路由，其中一个路由可以包含多个中间件6.3.3 错误处理中间件 详细使用建议查看文档！ 回调函数中多一个err参数，处理错误 —&gt;6.3.4 内置中间件 详细使用建议查看文档！ express.static(‘资源文件夹’)6.3.5 第三方中间件 详细使用建议查看文档！ cookie-parser：一个第三方的包(用npm搜索即可下载或查看如何使用) 6.4 模板引擎整合6.5 常用API基本使用7.总结 Node.js的Web开发相关的内容： 1、Node.js不需要依赖第三方应用软件（Apache），可以基于api自己实现 2、实现静态资源服务器 3、路由处理（路径加请求方式共同组成了路由的分发策略） 4、动态网站 5、模板引擎 6、get和post参数传递和处理 Web开发框架：express]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H-07-移动web之基础知识]]></title>
    <url>%2F2019%2F12%2F13%2FH-07-%E7%A7%BB%E5%8A%A8web%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 基础知识1.1 屏幕 移动设备与PC设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。 1.1.1 屏幕尺寸 通常所指的屏幕尺寸，实际上指的是屏幕对角线的长度（一般用英寸来度量）。 1.1.2 屏幕分辨率 分辨率则一般用像素来度量 px，表示屏幕水平和垂直方向的像素数。 例如1920*1080指的是屏幕垂直方向和水平方向分别有1920和1080个像素点而构成 1.2 长度单位 在Web开发中可以使用px（像素）、em、pt（点）、in（英寸）、cm（厘米）做为长度单位，最常用px（像素）做为长度单位。 可以将上述的几种长度单位划分成相对长度单位和绝对长度单位。 其中像素是一个相对长度单位（像素并没有固定的长度）。 1.3 像素密度 用PPI（Pixels Per Inch）值来表示屏幕每英寸的像素数量，我们将PPI、DPI都称为像素密度，但PPI应用更广泛，DPI在Android设备比较常见。 PPI值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。(利用勾股定理可以计算得出PPI) 屏幕尺寸固定时，当PPI 越大，像素的实际大小就会越小，当PPI越小，像素实际大小就越大。 1.4 设备独立像素1.4.1 起因 随着技术发展，设备不断更新，出现了不同PPI的屏幕共存的状态（如iPhone3G/S为163PPI，iPhone4/S为326PPI），像素不再是统一的度量单位，这会造成同样尺寸的图像在不同PPI设备上的显示大小不一样。 为了不影响用户的体验，需要一个新的单位，这个新的单位能够保证图像内容在不同的PPI设备看上去大小应该差不多。这就是独立像素，在IOS设备上叫PT(Point)，Android设备上叫DIP(Device independent Pixel)或DP。 1.4.2 设备独立像素 dp同px是有一个对应（比例）关系的，这个对应（比例）关系是操作系统确定并处理，目的是确保不同PPI屏幕所能显示的图像大小是一致的，通过window.devicePixelRatio可以获得该比例值。 dp（或pt）和px并不总是绝对的倍数关系（并不总能保证能够整除），而是window.devicePixelRatio ~= 物理像素/独立像素。 1.5. 像素1.5.1 物理像素 物理像素指的是屏幕渲染图像的最小单位，属于屏幕的物理属性，不可人为进行改变，其值大小决定了屏幕渲染图像的品质，我们以上所讨论的都指的是物理像素。 如何获取？ window.screen.width window.screen.height1.5.2 CSS像素 CSS像素，与设备无关像素，指的是通过CSS进行网页布局时用到的单位，其默认值(PC端)是和物理像素保持一致的（1个单位的CSS像素等于1个单位的物理像素），但是可以通过缩放来改变其大小。 物理像素和CSS像素的关系： 1个物理像素并不总是等于一个CSS像素，通过调整浏览器缩放比例，可以有大于、等于、小于这3种情况。 2. 远程调试2.1 模拟调试 在浏览器中进行模拟调试。 模拟调试可以满足大部分的开发调试任务，但是由于移动设备种类繁多，环境也十分复杂，模拟调试容易出现差错。 2.2 真机调试 两种方法： ！将做好的网页上传至服务器或者本地搭建服务器，然后移动设备通过网络来访问。 借助第三方的调试工具，如weinre、debuggap、ghostlab等。真机调试必须保证移动设备同服务器间的网络是相通的。 3. 视口视口（viewport）是用来约束网站中最顶级块元素&lt;html&gt;的，即它决定了&lt;html&gt;的大小。 1.viewport的概念:移动设备上,用来显示网页的区域. a) 如果把移动设备的浏览器(也有可能是app中的webview) ,当做相框的话 b) viewport就相当于相框中的画,可能会比相框小,可能会比相框大,如果刚好一样大,那就皆大欢喜. 2.修改viewport:我们可以通过meta标签去修改viewport的值 ,防止滚动条出现,提升用户体验 a) 移动web常见设置：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; b) 该属性最早是苹果公司在Safari中推出用来解决移动设备的viewport问题的。后来被各大安卓以及浏览器厂商效仿,所以说这个属性真的是非常有用的。 3.可选值 a) width：设置layout viewport 的宽度，为一个正整数，或字符串” device- width” b) initial-scale：设置页面的初始缩放值，为一个数字，可以带小数 c) minimum-scale：允许用户的最小缩放值，为一个数字，可以带小数 d) maximum-scale：允许用户的最大缩放值，为一个数字，可以带小数 e) height：设置layout viewport 的高度，这个属性对我们并不重要，很少使用 f) user-scalable：是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 3.1 PC设备 在PC设备上viewport的大小取决于浏览器窗口的大小，以CSS像素做为度量单位。 viewport间接的决定并影响了我们网页的布局(&lt;html&gt;的大小是会影响到我们的网页布局的，viewport又决定了&lt;html&gt;的大小)。 获取viewport的大小 document.documentElement.clientWidth document.documentElement.clientHeight 在PC端，通过调整浏览器窗口可以改变viewport的大小，为了保证网页布局不发生错乱，需要给元素设定较大固定宽度。 3.2 移动设备 在移动设备上viewport不再受限于浏览器的窗口，而是允许开发人员自由设置viewport的大小，通常浏览器会设置一个默认大小的viewport，为了能够正常显示那些专为PC设计的网页，一般这个值的大小会大于屏幕的尺寸。 3.3 移动设备产生缩放和滚动条的原因 移动设备上有2个viewport（为了方便理解人为定义的），分别是layout viewport和ideal viewport。 3.3.1 layout viewport layout viewport（布局视口）指的是我们可以进行网页布局区域的大小，同样是以CSS像素做为计量单位。 获取 layout viewport document.documentElement.clientWidth document.documentElement.clientHeight 如果要保证为PC设计的网页在移动设备上布局不发生错乱，移动设备会默认设置一个较大的viewport（如IOS为980px），这个viewport实际指的是layout viewport。 3.3.2 ideal viewport ideal viewport（理想视口）指的是设备屏幕区域，（以设备独立像素PT、DP做为单位）以CSS像素做为计量单位，其大小是不能被改变的。 获取ideal viewport有两种情形（并不总是正确的，在实际开发一般无需获取这个值具体大小。） 新设备 window.screen.width; window.screen.height; 老设备 window.screen.width / window.devicePixelRatio; window.screen.height / window.devicePixelRatio; 3.3.3 出现滚动条的原因 移动设备浏览器会默认设置一个layout viewport，并且这个值会大于ideal viewport，那么我们也知道ideal viewport就是屏幕区域，layout viewport是我们布局网页的区域，那么最终layout viewport是要显示在ideal viewport里的，而layout viewport大于ideal viewport时，于是就出现滚动条了。 3.3.4 出现缩放的原因 移动设备厂商认为将网页完整显示给用户才最合理，而不该出现滚动条，所以就将layout viewport进行了缩放，使其恰好完整显示在ideal viewport（屏幕）里，其缩放比例为ideal viewport / layout viewport。 3.4 移动浏览器 移动端开发主要是针对IOS和Android两个操作系统平台的，除此之外还有Windows Phone。 移动端主要可以分成三大类，系统自带浏览器、应用内置浏览器、第三方浏览器 指跟随移动设备操作系统一起安装的浏览器。 通常在移动设备上都会安装一些APP，这些APP里往往会内置一个浏览器，就称这个浏览器为应用内置浏览器（也叫WebView）。(这个内置的浏览器一般功能比较简单，并且客户端开发人员可以更改这个浏览器的某些设置，在实际的开发中这个浏览器很重要) 指安装在手机的浏览器如FireFox、Chrome、360等等。 4. 屏幕适配 移动页面最理想的状态是，避免滚动条且不被默认缩放处理. 可以通过设置来进行控制，并改变浏览器默认的layout viewport的宽度。 4.1 Viewport详解 viewport 是由苹果公司为了解决移动设备浏览器渲染页面而提出的解决方案，后来被其它移动设备厂商采纳。 其使用参数如下：通过设置属性content=””实现，中间以逗号分隔 例如：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; width 设置layout viewport 宽度，其取值可为数值或者device-width。 height 设置layout viewport 高度，其取值可为数值或者device-height。 initital-scale设置页面的初始缩放值，为一个数字，可以带小数。 maximum-scale允许用户的最大缩放值，为一个数字，可以带小数。 minimum-scale允许用户的最小缩放值，为一个数字，可以带小数。 user-scalable是否允许用户进行缩放，值为”no”或”yes”。 4.2 控制缩放 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 当设置width=device-width，也达到了initial-scale=1的效果，得知其实 initial-scale = ideal viewport / layout viewport。 两种方式都可以控制缩放，开发中一般同时设置width=device-width和initial-scale=1.0（为了解决一些兼容问题） 4.3 避免滚动 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 滚动条是 layout viewport 相对于 ideal viewport 的，所以只要设置 layout viewport 小于或等于 ideal viewport 4.4 适配方案 移动开发的核心是屏幕适配，然而并示有专门的规范进行约束，一般是对现有持术进行归纳而总结出适配方案，总结出以下几种适配方案： 4.4.1 固定宽度 1、设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 2、设置内容区域大小为320px 3、设置内容区域水平居中显示 此方案已经很少采用了。 4.4.2 百分比宽度 1、设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 2、设置页面宽度为百分比 CSS里百分比的使用： width —&gt; 参照父元素的宽度 height —&gt; 参照父元素的高度 padding —&gt; 参照父元素的宽度 border —&gt; 不支持百分比设置 margin —&gt; 参照父元素的宽度 这种方案最容易理解，但是在设置元素高度时有非常大的局限性。 4.4.3 rem单位 1、设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 2、设置页面元素宽度单位为rem 或 em 关于em和rem em 相对长度单位，其参照当前元素字号大小，如果当前元素未设置字号则会继承其祖先元素字号大小。 rem 相对长度单位，其参照根元素(html)字号大小。 4.4.4 100%像素 1、设置网页宽度等于设备物理像素 2、设置初始化缩放比例（值为1 / window.devicePixelRatio） 淘宝针对iPhone设备采用的这种方案 5. 媒体查询 通过媒体查询可以检测当前网页运行在什么终端，可以有机会实现网页适应不同终端的展示风格。 5.1 媒体类型 将不同的终端设备划分成不同的类型，称为媒体类型。 all —&gt; 用于所有设备 print —&gt; 用于打印机和打印预览 screen —&gt; 用于电脑屏幕，平板电脑，智能手机 5.2 媒体特性 每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。 width —&gt; 定义输出设备中的页面可见区域宽度 height —&gt; 定义输出设备中的页面可见区域高度 min-width —&gt; 定义输出设备中的页面最小可见区域宽度 min-height —&gt; 定义输出设备中的页面最小可见区域高度 max-width —&gt; 定义输出设备中的页面最大可见区域宽度 max-height —&gt; 定义输出设备中的页面最大可见区域高度 device-width —&gt; 定义输出设备的屏幕可见宽度 device-height —&gt; 定义输出设备的屏幕可见高度 aspect-ratio —&gt; 定义输出设备中的页面可见区域宽度与高度的比率 device-aspect-ratio —&gt; 定义输出设备的屏幕可见宽度与高度的比率 5.3 关键字 关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件。 and 可以将多个媒体特性连接到一起，相当于“且”的意思。 not 排除某个媒体类型，相当于“非”的意思，可以省略。 only指定某个特定的媒体类型，可以省略。 5.4 引入方式 1、link方法：&lt;link href=&quot;./5-1.css&quot; media=&quot;only screen and (max-width: 320px)&quot;&gt; @media方法（写在CSS里）：@media only screen and (max-width: 320px) {...} 5.5 常用特性 1、width / height完全等于layout viewport 2、max-width / max-height 小于等于layout viewport 3、min-width / min-height 大于等于layout viewport 4、device-width / device-height 完全等于ideal viewport 5、orientation: portrait | landscape肖像/全景模式 6. 触屏事件6.1 事件类型 touchstart: 手指触摸屏幕时触发 touchmove: 手指在屏幕上移动时触发 touchend: 手指离开屏幕时触发 6.2 TouchEvent对象 touches: 位于屏幕上的所有手指的列表 targetTouches: 位于该元素上的所有手指的列表 changedTouches：touchstart时包含刚与触摸屏接触的触点，touchend时包含离开触摸屏的触点。 ！注：没有对比出touches同targetTouches的差异，推荐使用targetTouches 6.3 Touch对象 clientX/Y：手指相对于layout viewport的水平/垂直像素距离 pageX/Y：手指相对于layout viewport的水平/垂直像素距离（含滚动） screenX/Y：手指相对于layout viewport的水平/垂直像素距离（含滚动）,（未设置viewport时，screenX/Y在Webview中不正确） target：手指最初与屏幕接触时的元素 移动开发通常会设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;，这时这三对坐标值是完全一样的。 6.4 click延时 早期移动设备浏览器网页时内容非常小，为了增强用户体验，苹果公司专门为移动设备设计了双击放大的功能，确保用户可以非常方便的放大网页内容，但是当用户单击一个按钮时，移动设备会延时（约300ms）执行，判断用单是否要双击。 用触屏事件可以解决这个问题。 6.5 手势封装详细手势见wcy笔记中的内容。 Tap：点击 Double tap：双击 Drag：拖拽 Flick：轻滑 Pinch：缩小 Spread：放大 Press：按压 Press and tap：按压点击 Press and drag：按压拖拽 Rotate：旋转 利用触屏事件简易封装手势，主要用途是熟悉触屏事件的使用。 【tap检测接触和离开屏幕的距离来实现】 【drag跟踪手指移动位置，进而设置元素定位坐标】 【swipe判断手指滑动的方向】 7. 移动端类库 iScroll.js swipe.js swiper.js fastclick.js 8. 网页布局8.1 布局方式 1、固定宽度布局：为网页设置一个固定的宽度，通常以px做为长度单位，常见于PC端网页。 2、流式布局：为网页设置一个相对的宽度，通常以百分比做为长度单位。 3、栅格化布局：将网页宽度人为的划分成均等的长度，然后排版布局时则以这些均等的长度做为度量单位，通常利用百分比做为长度单位来划分成均等的长度。 4、响应式布局：通过检测设备信息，决定网页布局方式，即用户如果采用不同的设备访问同一个网页，有可能会看到不一样的内容，一般情况下是检测设备屏幕的宽度来实现。 8.2 响应式布局 Responsive design，意在实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。 响应式布局常用于企业的官网、博客、新闻资讯类型网站，这些网站以浏览内容为主，没有复杂的交互。 般我们会对常见的设备尺寸进行划分后，再分别确定为不同的尺寸的设备设计专门的布局方式：（类型与布局宽度） 大屏幕：大于等于1200px 默认：大于等于980px 平板：小于等于768px 手机到平板：小于等于767px 手机：小于等于480px]]></content>
      <categories>
        <category>前端</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H-06-Ajax之ajax跨域]]></title>
    <url>%2F2019%2F12%2F08%2FH-06-Ajax%E4%B9%8Bajax%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1. 跨域的概念 前端没有办法从后台获取json形式的数据，只能获取jsonp形式的数据 Ajax的异步，缺点是使代码的可读性降低了，如果请求有数据依赖，就必须要嵌套。（node中的Promise可以解决这一问题）1.1 同源策略 同源策略是浏览器的一种安全策略，所谓同源指的是请求URL地址中的协议、域名和端口都相同，只要其中之一不相同就是跨域 同源策略主要为了保证浏览器的安全性 在同源策略下，浏览器不允许Ajax跨域获取服务器数据 1.2 跨域解决方法 jsonp(主流使用) document.domain+iframe location.hash + iframe window.name + iframe window.postMessage flash等第三方插件 2.jsonp2.1 原理分析 jsonp的本质：动态创建script标签，然后通过它的src属性发送跨域请求，然后服务器端响应的数据格式为【函数调用（foo(实参)）】，所以在发送请求之前必须先声明一个函数，并且函数的名字与参数中传递的名字要一致。这里声明的函数是由服务器响应的内容（实际就是一段js代码-函数调用）来调用。 2.1.1 静态script标签的src属性进行跨域请求 &lt;script /*async*/ type=&quot;text/javascript&quot; src=&quot;http://wcy.com/wcy/cross.php?flag=1&quot;&gt; script标签里面的async属性表示异步加载资源，默认情况下是同步加载 异步会报错，解析时获取不到数据。 这种方式存在的两个主要的问题： 1、必须保证加载的顺序 2、不方便通过程序传递参数 php代码返回的是一段js代码 2.1.2 动态创建script标签，通过标签的src属性发送请求 动态创建script标签发出去的请求是异步请求 jsonp的本质就是动态创建script标签，通过它的src属性向服务端发送它的跨域请求，通过响应内容动态调用事先定义好的方法。 服务器响应的内容是函数调用:foo(data)。 2.2 调用函数的名字处理 前端迎合后端，灵活调用2.2.1 前台：回调函数的名字必须与src属性中传入的callback参数的值一致 后台：$cback = $_GET[&#39;callback&#39;]; echo $cback.&#39;(&#39;.json_encode($arr)&#39;)&#39;; script.src = &#39;http://wcy.com/wcy/cross.php?callback=wcy&#39;;+ &amp;usename=wcy&amp;password=123… 等号前面是后台获取数据用的，等号后面是前台传入数据用的。 3. jQuery中jspon ！jsonp只支持get请求3.1 jQuery跨域的解决方案 $.ajax({...}) jsonp:&#39;abc&#39;，作用就是自定义参数名字（callback=abc 这里的名字指的是等号前面的键，后端根据这个键获取方法名，jquery的默认参数名称是callback）。 jsonpCallback:&#39;abc&#39;，这个属性的作用就是自定义回调函数的名字（callback=abc ，这里的名字指的是等号后面的值） 详细代码： 1234567891011121314151617181920$(function() &#123; $(&quot;#btn&quot;).click(function() &#123; //与Ajax比较像，但内部实现并不是ajax $.ajax(&#123; type: &apos;get&apos;, url: &apos;http://wcy.com/wcy/jsonp.php&apos;, dataType: &apos;jsnp&apos;, jsonp: &apos;cb&apos;, jsonpCallback: &apos;wcy&apos;, data: &#123;&#125;, success: function(data) &#123; console.log(data.username,data.password); &#125;, error:function(data) &#123; console.log(data); console.log(&apos;error&apos;); &#125; &#125;) &#125;) &#125;) 3.1.1 不进success方法的问题 形式1：只进error方法 后端：echo &#39;123&#39;; 形式2：进success方法 后端：$arr = $_GET[&#39;callback&#39;]; ... 3.2 jQuery中的jsonp封装 见代码ajax2和AjaxAll 跨域获取数据必须要加dataType属性，并且值为jsonp 3.3 API Store http://apistore.baidu.com/ 别人的接口 自己写的接口 第三方接口 4. 模板引擎 回调函数中的字符串拼接的方法不够合理和规范，维护也不够友好。 作用：把拼接字符串的逻辑规范化，方便后期维护。4.1 工作流程 模板 + 数据 —&gt; 静态页面片段 4.2 artTemplate 是流行的模板引擎之一，性能非常优越 4.3 使用1案例 代码 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot; src=&quot;./template.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/html&quot; id=&quot;template&quot;&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &#123;&#123;if books&#125;&#125; &#123;&#123;each books as value i&#125;&#125; &lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt; &#123;&#123;/each&#125;&#125; &#123;&#123;/if&#125;&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var data = &#123; title: &apos;图书信息&apos;, books: [&apos;三国演义&apos;,&apos;水浒传&apos;,&apos;西游记&apos;,&apos;红楼梦&apos;] &#125;; var html = template(&apos;template&apos;,data); var con = document.getElementById(&apos;container&apos;); con.innerHTML = html; &#125;&lt;/script&gt; var html = template(&#39;template&#39;,data); template的作用就是把模板和数据拼接到一块生成一个静态HTML片段，实际就是该方法的返回值 参数一：模板id 参数二：用来渲染的数据 4.4 转义 不转义加#，默认是转义的。 代码示例： 12345678910111213&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; &lt;p&gt;不转义：&#123;&#123;#value&#125;&#125;&lt;/p&gt; // 渲染结果是红色的hello world! &lt;p&gt;默认转义： &#123;&#123;value&#125;&#125;&lt;/p&gt; // 渲染结果是value的值&lt;/script&gt;&lt;script&gt; // 这里的数据当中包含特殊字符 var data = &#123; value: &apos;&lt;span style=&quot;color:#F00&quot;&gt;hello world!&lt;/span&gt;&apos; &#125;; var html = template(&apos;test&apos;, data); document.getElementById(&apos;content&apos;).innerHTML = html;&lt;/script&gt; 4.5 编译的形式(使用2) var render = template.compile(source); 根据模板生成渲染函数；compile方法返回值是一个函数(render函数) var html = render(data); render的作用就是用数据渲染静态标签内容 代码示例： 12345678910111213141516&lt;script&gt; var source = &apos;&lt;ul&gt;&apos; &apos;&#123;&#123;each list as value i&#125;&#125;&apos; &apos;&lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt;&apos; &apos;&#123;&#123;/each&#125;&#125;&apos; &apos;&lt;/ul&gt;&apos;; // 根据模板生成渲染函数；compile方法返回值是一个函数 var render = template.compile(source); // render的作用就是用数据渲染静态标签内容 var data = &#123; list: [&apos;摄影&apos;, &apos;电影&apos;, &apos;民谣&apos;, &apos;旅行&apos;, &apos;吉他&apos;] &#125;; var html = render(data); document.getElementById(&apos;content&apos;).innerHTML = html;&lt;/script&gt; 4.6 嵌入子模板 把include &#39;模板名&#39;放在插值表达式中，如下列代码所示。 代码示例： 1234&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &#123;&#123;include &apos;list&apos;&#125;&#125; //在test模板里面嵌入list模板 &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>Ajax</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax之ajax封装]]></title>
    <url>%2F2019%2F12%2F07%2FH-05-Ajax%E4%B9%8Bajax%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1.初步封装 传入url,type,param,dataType,callback参数 1.1 创建XMLHttpRequest对象 处理兼容问题 12345if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125; 1.2 准备发送 请求类型处理：传入请求类型(形参type) url处理：url = type == &#39;get&#39; ? url + &quot;?&quot; + param : url; 异步/同步处理：传入 ture/false 1.3 执行发送动作 传入形参param，参数处理： 123456var data = null; if(type == &apos;post&apos;)&#123; data = param; xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); &#125; xhr.send(data); 1.4 指定回调函数 处理响应数据的类型：data = dataType == &#39;json&#39; ? JSON.parse(data) : data; 传入回调函数callback，调用callback(data); 1.5 代码示例12345678910111213141516171819function ajax(url,type,param,dataType,callback) &#123; url = type == &apos;get&apos; ? url + &quot;?&quot; + param : url; xhr.open(type,url,ture); var data = null; if(type == &apos;post&apos;) &#123; data = param; xhr.setRequesHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;) &#125; xhr.send(data); xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status == 200)&#123; var data = xhr.responseText; data = dataType == &apos;json&apos; ? JSON.parse(data) : data; callback(data); &#125; &#125; &#125;&#125; 2. 改进封装 1、传入一个obj作为形参 2、对obj进行初始化 123456789// 默认参数 var defaults = &#123; type : &apos;get&apos;, data : &#123;&#125;, url : &apos;#&apos;, dataType : &apos;text&apos;, async : true, success : function(data)&#123;console.log(data)&#125; &#125; 3、传入的覆盖，未传入的使用默认值 123for(var key in obj)&#123; defaults[key] = obj[key];&#125; 4、处理创建XMLHttpRequest对象的兼容问题 5、处理url：把对象形式的参数转化为字符串形式的参数 1234567var param = &apos;&apos;;for(var attr in obj.data)&#123; param += attr + &apos;=&apos; + obj.data[attr] + &apos;&amp;&apos;;&#125;if(param)&#123; param = param.substring(0,param.length - 1);&#125; 6、处理get/post请求参数并且处理问题 123456789// get请求：处理中文乱码问题if(defaults.type == &apos;get&apos;)&#123; defaults.url += &apos;?&apos; + encodeURI(param);&#125;// post请求：设置请求头及数据if(defaults.type == &apos;post&apos;)&#123; data = param; xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);&#125; 7、准备发送（设置发送的参数） xhr.open(defaults.type,defaults.url,defaults.async); 8、处理post请求参数并且设置请求头信息（必须设置） 9、处理同步请求，不会调用回调函数 1234567if(!defaults.async)&#123; if(defaults.dataType == &apos;json&apos;)&#123; return JSON.parse(xhr.responseText); &#125;else&#123; return xhr.responseText; &#125;&#125; 10、指定回调函数（处理服务器响应数据） 123456789101112xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; var data = xhr.responseText; if(defaults.dataType == &apos;json&apos;)&#123; // data = eval(&quot;(&quot;+ data +&quot;)&quot;); data = JSON.parse(data); &#125; defaults.success(data); &#125; &#125;&#125; 3.jQuery中的ajax封装3.1 使用11234567891011121314151617181920212223$(function()&#123; $(&quot;#btn&quot;).click(function()&#123; var code = $(&quot;#code&quot;).val(); $.ajax(&#123; type:&apos;get&apos;, url:&apos;./11.php&apos;, data:&#123;code:code&#125;, dataType:&apos;json&apos;, success:function(data)&#123; if(data.flag == 0)&#123; $(&quot;#info&quot;).html(&quot;该图书不存在&quot;); &#125;else&#123; var tag = &apos;&lt;ul&gt;&lt;li&gt;书名：&apos; + data.bookname + &apos;&lt;/li&gt;&lt;li&gt;作者：&apos; + data.author + &apos;&lt;/li&gt;&lt;li&gt;描述：&apos; + data.desc + &apos;&lt;/li&gt;&lt;/ul&gt;&apos;; $(&quot;#info&quot;).html(tag); &#125; &#125;, error:function(data)&#123; console.dir(data); $(&quot;#info&quot;).html(&quot;服务器发生错误，请与管理员联系&quot;); &#125; &#125;); &#125;);&#125;);3.2 使用21234567891011121314151617181920$(function()&#123; $(&quot;#btn&quot;).click(function()&#123; var code = $(&quot;#code&quot;).val(); var data = $.ajax(&#123; type:&apos;post&apos;, url:&apos;./11.php&apos;, async:false, data:&#123;code:code&#125;, dataType:&apos;json&apos; &#125;); // data.responseJSON = JSON.parse(xhr.responseText); data = data.responseJSON; if(data.flag == 0)&#123; $(&quot;#info&quot;).html(&quot;该图书不存在&quot;); &#125;else&#123; var tag = &apos;&lt;ul&gt;&lt;li&gt;书名：&apos; + data.bookname + &apos;&lt;/li&gt;&lt;li&gt;作者：&apos; + data.author + &apos;&lt;/li&gt;&lt;li&gt;描述：&apos; + data.desc + &apos;&lt;/li&gt;&lt;/ul&gt;&apos;; $(&quot;#info&quot;).html(tag); &#125; &#125;);&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>Ajax</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax之ajax基础知识]]></title>
    <url>%2F2019%2F12%2F05%2FH-04-Ajax%E4%B9%8Bajax%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 使用Ajax发送请求流程1.1 XMLHttpRequest对象1.1.1 创建XMLHttpRequest对象 标准浏览器： var xhr = new XMLHttpRequest(); IE6： var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 处理兼容 详细代码1： 123456var xhr = null;if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest();//标准&#125;else&#123; xhr = new ActiveXObject(&quot;Microsoft&quot;);//IE6&#125; 详细代码2： 12345try&#123; xhr = new XMLHttpRequest(); &#125;catch(e)&#123; xhr = new ActiveXObject(&quot;Microsoft&quot;); &#125; 1.1.2 readyState状态 xhr.readyState = 0：表示xhr对象创建完成 xhr.readyState = 1：表示已经发送了请求 xhr.readyState = 2：浏览器已经收到了服务器响应的数据 xhr.readyState = 3：正在解析数据 xhr.readyState = 4：数据已经解析完成，可以使用了 4表示服务器返回的数据已经可以使用了，但是这个数据不一定是正常的 1.1.3 http常见状态码 200：表示响应成功 200表示服务器返回的数据是正常的，不是200的话表示数据是错误的 404没有找到请求的资源 500服务器端错误 1.2 准备发送 xhr.open() xhr.open(&#39;get&#39;,&#39;./01check.php?username=&#39;+un+&#39;&amp;password=&#39;+pw,true); 参数： 第一个参数：请求方式(get获取数据；post提交数) 第二个参数：路径/请求地址（get请求需要在此处传参） 第三个参数：同步或者异步标志位，默认是true表示异步，false表示同步，默认为true(异步) 如果是get请求那么请求参数必须在url中传递，encodeURI()用来对中文参数进行编码，防止乱码 post请求参数通过send传递，不需要通过encodeURI()转码，必须设置请求头信息。 1.3 执行发送动作 xhr.send() get请求 xhr.send(null); 参数： get请求直接传null post请求 xhr.send(param);(注意：var param = ‘username=’+un+’&amp;password=’+pw) 参数：post请求传入数据 post请求参数在这里传递，并且不需要转码 一定要设置请求头：xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); 1.5 指定回调函数 该函数调用的条件就是readyState状态发生变化（不包括从0变为1） xhr.onreadystatechange = function() {...} 用法示例：12345678910111213xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; var data = xhr.responseText; var info = document.getElementById(&apos;info&apos;); if(data == &apos;1&apos;)&#123; info.innerHTML = &apos;登录成功&apos;; &#125;else if(data == &apos;2&apos;)&#123; info.innerHTML = &apos;用户名或者密码错误&apos;; &#125; &#125; &#125;&#125; Ajax接收数据只有两种： var datas = xhr.responseText; var datas = xhr.responseXML; 2. 响应数据格式及数据解析 xml和json都是静态资源文件，不能够动态获取数据，所以要用php开发xml/以接口形式获取数据 2.1 XML2.1.1 XML数据格式 这种数据格式称作元数据(元数据：描述数据的数据) 代码示例：12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;booklist&gt; &lt;book&gt; &lt;name&gt;三国演义&lt;/name&gt; &lt;author&gt;罗贯中&lt;/author&gt; &lt;desc&gt;一个杀伐纷争的年代&lt;/desc&gt; &lt;/book&gt;&lt;/booklist&gt; 这种数据格式的弊端： 1、元数据占用的数据量比较大，不利于大量数据的网络传输 2、解析不太方便 2.1.2 解析 解析过程与HTML非常类似（可以查看文档中的XML DOM） 解析方法：通过标签名获取到bookList，根据DOM节点一层一层获取到文本内容(.innerHTML) .childNodes：获取所有节点 .children：获取所有文本节点 .firstChild：获取到文本节点，获取到的是带有双引号的文本 .wholeText：获取到文本内容 代码示例： 12345var data = xhr.responseXML;var bookList = data.getElementsByTagName(&apos;booklist&apos;);var books = bookList[0].children;// 所有文本节点var book1 = books[0];// 第一个文本节点var name = book1.children[0].firstChild.wholeText;// 2.1.3 php开发xml 与上面不同的是，这种方法数据是可变的，上面方法的数据只能写死 设置响应头信息：header(&quot;Content-Type:text/xml;&quot;);，保证浏览器可以把相应内容识别为xml文件类型 不设置响应头信息，返回的数据为null2.1.4 ajax接收XML格式数据 var datas = xhr.responseXML;2.1 json2.1.1 json数据格式 json数据和普通的js对象的区别： 1、json数据没有变量 2、json形式的数据结尾没有分号 3、json数据中的键必须用双引号包住 json文件中不能写注释 2.1.2 解析 解析方法：获取到json数据，使用一些方法进行转换(json —&gt; 对象)，对数据进行操作(操作对象=操作数据) 方法： JSON.parse(str)：把json形式的字符串转成对象 JSON.stringify(obj)：把对象转成字符串 eval()：eval的作用就是把字符串解析成js代码并执行 eval并不安全，不建议使用 json_encode() 作用：就是把数组转化成json形式的字符串 代码演示： 123456var str = &apos;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;12&quot;&#125;&apos;;var obj = JSON.parse(str);//把json形式的字符串转成对象var str1 = JSON.stringify(obj);//把对象转成字符串console.log(str1);//&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;12&quot;&#125; // var d = eval(&quot;(&quot; + data + &quot;)&quot;); // eval=parse 2.1.3 接口的形式 通过后端的编程语言来动态生成数据的 代码示例： 123456789&lt;?php $uname = &apos;wangwu&apos;; $age = &apos;13&apos;; echo &apos;&#123;&quot;username&quot;:&quot;&apos;.$uname.&apos;&quot;,&quot;age&quot;:&quot;&apos;.$age.&apos;&quot;&#125;&apos;;// 变量填充的数据 $arr = array(&quot;name1&quot;=&gt;&quot;tom&quot;,&quot;name2&quot;=&gt;&quot;jerry&quot;,&quot;name3&quot;=&gt;&quot;spike&quot;); $str = json_encode($arr); // 把数组转化成json形式的字符串 echo $str;?&gt; 2.1.4 ajax接收json格式数据 var data = xhr.responseText; 3.异步机制 单线程+事件队列 事件队列中的任务执行的条件： 1、主线程已经空闲 2、任务满足触发条件： 定时函数（延时时间已经达到）；setTimeout()、setInterval() 事件函数（特定事件被触发）；btn.onclick=functoin(){...} ajax的回调函数（服务器端有数据相应）；xhr.onreadystatechange=function() 3.1 同步与异步3.1.1 页面加载的同步与异步 普通的页面效果(同步)：整个页面刷新(会出现白屏的情况) 页面不刷新效果(异步)：局部刷新(例如评论加载的效果) 3.1.2 两者的行为方式 同步：彼此等待 —&gt; 阻塞(相对于通信双方来说的) 异步：各做各的 —&gt; 非阻塞]]></content>
      <categories>
        <category>前端</category>
        <category>Ajax</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax之php基础知识]]></title>
    <url>%2F2019%2F12%2F03%2FH-03-Ajax%E4%B9%8Bphp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1.基本语法 所有的php相关的代码都要写到这里面；&lt;?php ... ?&gt; php是一种后台编程语言；使用php可以开发动态网站和后台接口（所谓接口就是url地址，用于给前端提供数据）。 1.1 变量声明 变量名的规则：由$/字母/数字/下划线，不能以数字开头，大小写敏感 $Num = 123; 1.2 字符串拼接 js中字符串拼接用+；php当中的字符串拼接用的是. 1.3 单引号与双引号的差异 单引号对于其中的变量当作普通的字符串来处理 双引号对于其中的变量会把变量解析成变量值 1.4 内容输出 echo：输出简单数据类型，如字符串、数值 print_r()：输出复杂数据类型，如数组 var_dump()：输出详细信息，如对象、数组 1.5 字符串拼接 echo 的作用就是向页面当中输出字符串：echo &#39;&lt;div&gt;Hello World!&lt;/div&gt;&#39;; 1.6 数据类型 与JavaScript基本类似，都是弱类型语言 1.6.1 数据类型 字符串、整型、浮点型、布尔型、数组、对象、NULL 基本类型：number、string、boolean、null、undefined 引用类型：object（Array、Math、RegExp、Date、Object、Error、Number、String、Boolean） 1.6.2 判断变量的类型 gettype() 内置函数，用来判断变量的类型 1.6.3 数组 一维数组 数组的两种形式 $arr = array(1,2,3);默认key是从0开始的整数 $arr = array(&quot;a&quot;=&gt;&quot;1&quot;,&quot;b&quot;=&gt;&quot;2&quot;,&quot;c&quot;=&gt;&quot;3&quot;);指定键 二维数组 1234$arr6 = array();$arr6[0] = array(11,22,33);$arr6[1] = array(33,44,55);$arr6[2] = array(55,66,77); count()是内置函数，用来计算数组的长度 遍历数组时，循环体中的分号必须写 123for($i=0; $i&lt;count($arr1); $i++) &#123; echo $arr1[$i].&quot;&lt;br/&gt;&quot;;// 此处分号必须写&#125; foreach()遍历数组 123456789 sleep(3);// 执行到这里的时候等待3秒// 遍历数组1 foreach($arr3 as $key =&gt; $value) &#123; echo $key.&apos;===&apos;.$value.&apos;&lt;br /&gt;&apos;; &#125;// 遍历数组2 foreach($arr as $value)&#123; echo $value.&apos;-----&lt;br&gt;&apos;; &#125; 1.7 运算符 与JavaScript基本类似，都是弱类型语言 基本类型：number、string、boolean、null、undefined 引用类型：object（Array、Math、RegExp、Date、Object、Error、Number、String、Boolean） 1.8 分支循环语句 if/switch while for foreach 1.9 函数1.9.1 自定义函数 语法规则（函数名不区分大小写） 示例：12345function Foo($str) &#123; return $str;&#125;$ret1 = foo(&apos;hi wcy&apos;);echo $ret1; 1.9.2 系统函数 gettype()：检测数据类型的 json_encode()：把对象变成json类型的字符串 1.10 预定义变量（表单处理） $_GET $_POST 1.10.1 http协议的常用请求方式：(增删改查) get：用来从服务器获取数据(参数一般作为查询条件) (http://localhost/ajax/php/page.php?abc=1) $f = $_GET[&#39;abc&#39;]; post：用来添加数据 $uname = $_POST[&#39;username&#39;]; post获取到的数据是字符串类型的12345678910111213&lt;form action=&quot;./post.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;$un = $_POST[&apos;username&apos;];$pd = $_POST[&apos;password&apos;];if($un === &apos;admin&apos; &amp;&amp; $pd === &apos;123&apos;) &#123; echo &apos;登录成功&apos;;&#125; else &#123; echo &apos;登录失败，用户名或者密码错误&apos;;&#125; put：用来修改数据 delete：用来删除数据 2. 其它2.1 设置服务器响应的文件类型 header(&quot;Content-Type:text/plain;charset=utf-8&quot;);2.1 判断数组中没有对应键 array_key_exists :用来判断数组中没有对应键 使用： 123456if(array_key_exists($code,$books) == 1)&#123; $book = $books[$code];//这里根据参数获取一本书的信息 echo json_encode($book);&#125;else&#123; echo &apos;&#123;&quot;flag&quot;:0&#125;&apos;;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>Ajax</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js之Ajax学前知识]]></title>
    <url>%2F2019%2F12%2F02%2FH-02-js%E4%B9%8BAjax%2F</url>
    <content type="text"><![CDATA[1. 基础知识1.1 前端相关的知识点 html（html5） 主要用来实现页面的排版布局 css（css3） 主要用来实现页面的样式美化 JavaScript（jQuery） 主要用来实现前端功能特效 采用上面的这些技术开发的页面和前端特效脚本需要放到服务器才能够对外提供服务，才能够让互联网上的网友看到。 1.2 客户端与服务器 本质上都是计算机，只不过样子不同，配置不同，应用场景不同（安装的应用软件不同） 客户端主要用于普通上网用户 服务器主要给上网用户提供后台服务 1.3 网络相关概念 IP地址（唯一的确定互联网上的一台计算机） 域名 IP地址的别名，方便记忆 DNS 用于维护IP地址与域名的关系 端口 用来确定计算机上的网络应用程序 1.4 通信协议理解 通信双方约定的规则 http/https 超为本传输协议 ftp 文件传输协议 smpt/pop3 邮件收发协议 …… 1.5 网站 网站由一系列页面组成（页面由js、css、图片、html标签。。。所有的这些文件都被称为资源） 1.5.1 静态网站 就是提前写好的html页面（包括图片、媒体文件。。。静态资源文件），并且部署到服务器上静态网站主要存在的问题： 随着网站规模的增大可维护性逐渐降低 没有交互性 1.5.2 动态网站 动态指的是html页面是动态生成的，这里动态生成的不一定是一个完整的页面，有可能仅仅是页面的一部分，或者仅仅是数据(普通字符串、json、xml)实现动态网站的技术： php java（jsp） .net Node.js python …… 1.6 配置集成环境1.6.1 允许同一局域网内可以访问 Deny —- Allow ipconfig ipconfig /all 查看同一局域网内的IP地址（以太网适配器） 1.6.2 配置其它目录可访问（更改根目录） DocumentRoot —&gt; 路径改为要设置的根目录 1.6.3 配置其它目录可访问（支持多个网站） Virtual hosts —&gt; 去掉#Include conf/extra/httpd-vhosts.conf中的# 找到与配置文件在同级目录下的extra/httpd-vhosts.conf文件，并做出修改 DocumenRoot必须要在上面配置的根目录下面 1.6.4 配置计算机域名与ip地址的关系 打开C:\Windows\System32\drivers\etc\host 添加对应关系]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js之jQuery]]></title>
    <url>%2F2019%2F11%2F29%2FH-01-js%E4%B9%8BjQuery%2F</url>
    <content type="text"><![CDATA[1. 介绍1.1 是什么？好处？1.1.1 是什么？ JavaScript框架库:就是一个普通的js文件,封装了很多的函数,封装了很多兼容的代码 jQuery是JavaScript框架库中的一种 1.1.2 好处？ jQuery的好处:写的少,做的多,链式编程,隐式迭代等… jQuery可以解决js兼容的问题 1.2 与window相比较1.2.1 顶级对象 DOM中的顶级对象:docuemnt—页面中的顶级对象 docuemnt点出来的是DOM中的属性和方法 BOM中的顶级对象:window—-浏览器中的顶级对象 window点出来的是浏览器中的属性和方法 window.document jQuery的顶级对象:jQuery—$ $点出来的是jQuery中的方法 1.2.2 页面加载事件 window中的页面加载事件只能写一个，写多个后写的会覆盖先写的，最终只有一个有效。 jQuery中的页面加载事件，可以写多个，且全部有效。 jQuery中的$(window).load(function(){...})等同于window.onload = function(){...},都表示页面中所有的内容加载完毕后才触发,标签,图片,文字内容…. jQuery中的$(document).ready(function(){...})和$(function(){...})都表示页面中的基本的标签加载完毕后就可以触发了 12345678910111213141516// window中的页面加载事件 window.onload = function() &#123; console.log(&quot;hahhahahh111~~~&quot;); &#125;// jQuery中的页面加载事件1 $(window).load(function() &#123; console.log(&quot;hahhahahh111~~~&quot;); &#125;)// jQuery中的页面加载事件2 $(document).ready(function() &#123; console.log(&quot;hahhahahh111~~~&quot;); &#125;)// jQuery中的页面加载事件3 $(function() &#123; console.log(&quot;hahhahahh111~~~&quot;); &#125;) 1.2.3 二者互换 DOM —&gt; jQuery：DOM对象转jQuery对象,只需要把DOM对象放在$(dom对象)---&gt;jQuery对象 jQuery —&gt; DOM：如下两种方式 1.$(btnObj).get(0);----&gt;DOM对象 2.$(btnObj)[0];-----&gt;DOM对象 1.2.4 二者元素的获取 DOM中获取元素的方式： document.getElementById(“id的值”);根据id获取元素,一个 document.getElementsByTagName(“标签的名字”);根据标签的名字获取元素,多个 document.getElementsByName(“name属性的值”);根据name属性的值获取元素,多个 document.getElementsByClassName(“类样式的名字”);根据的是类样式的名字来获取元素,多个 jQuery获取元素的方式：通过各种选择器来获取元素 1.根据id来获取—&gt;id选择器 —-&gt;$(“#id的值”);一个 2.根据标签的名字来获取—标签选择器—&gt;$(“标签的名字”);多个 3.根据类样式的名字获取—&gt;类选择器—&gt;$(“.类样式的名字”);多个 jQuery中的索引选择器： 获取ul中的第一个li标签元素：$(&quot;#uu&gt;li&quot;).first(&quot;li&quot;); 获取ul中的最后一个li标签元素：$(&quot;#uu&gt;li&quot;).last(&quot;li&quot;); 获取ul中的索引为奇数的li标签元素：$(&quot;#uu&gt;li:odd&quot;).css(...); 获取ul中的索引为偶数的li标签元素：$(&quot;#uu&gt;li:even&quot;).css(...); 获取ul中的索引为n的li标签元素：$(&quot;#uu&gt;li:eq(n)&quot;).css(...); 获取ul中的索引大于n的所有的li标签元素：$(&quot;#uu&gt;li:gt(n)&quot;).css(...); 获取ul中的索引小于n的所有的li标签元素：$(&quot;#uu&gt;li:lt(n)&quot;).css(&quot;...); jQuery中的属性选择器：空格: 获取div中所有type属性为checkbox的input：$(&quot;#dv2 :checkbox&quot;).prop(&quot;checked&quot;,true) 1.2.5 动态创建元素的方法 DOM中创建元素: 1.document.write(&quot;标签代码&quot;);缺陷:页面加载后创建元素,把页面中原有的内容全部的干掉 2.innerHTML 3.document.createElement(&quot;标签的名字&quot;) jQuery中创建元素的方式: 1.$(&quot;标签的代码&quot;) 2.对象.html(&quot;标签的代码&quot;); 2. 方法2.1 常见方法2.1.0 .find()方法 举例说明获取tbody中所有的复选框：$(&quot;tbody&quot;).find(&quot;:checkbox&quot;).prop(&quot;checked&quot;,true); 2.1.1 .html()方法 设置标签中间显示其他标签及内容,类似于innerHTML 小括号中可以直接写标签的字符串内容,就是设置div中的元素内容：$(&quot;#dv&quot;).html(&quot;&lt;p&gt;这是一个p标签&lt;/p&gt;&quot;); 小括号中什么也没有,表示的时候获取div中的元素内容：console.log($(&quot;#dv&quot;).html()); .html()方法相当于DOM中的innerHTML 2.1.2 .text()方法 设置标签中间显示的文本内容,类似于innerText 如果小括号中写内容,就是设置文字内容：$(&quot;#dv&quot;).text(&quot;这是一个div&quot;);//设置 小括号什么也不写,表示的是获取这个元素中的文字内容：console.log($(&quot;#dv&quot;).text());//获取 .text()方法相当于DOM中的innerText 2.1.3 .val()方法 设置input标签中value的值,类似于value 小括号中写内容就是设置元素的value属性：$(&quot;#txt&quot;).val(&quot;哈哈hhhhh&quot;); 小括号中什么也不写,获取元素的value属性的值：console.log($(&quot;#txt&quot;).val()); .val()方法，就是元素的value属性 获取文本域中的内容: 1. .text()方法 2 .val()方法--推荐 12345678910111213141516// jQuery代码$(function () &#123; $(&quot;#btn&quot;).click(function () &#123; $(&quot;#se&quot;).val(4);//可以改变某一项选中 &#125;);&#125;);// html代码&lt;input type=&quot;button&quot; value=&quot;选中重庆&quot; id=&quot;btn&quot;/&gt;&lt;select id=&quot;se&quot;&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;重庆&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;东京&lt;/option&gt;&lt;/select&gt; 2.1.4 .css()方法 设置元素的样式,类似于style 该方法如果只是设置一个样式的属性和值,那么这个方法写两个参数,第一个参数是属性,第二个参数是值 $(&quot;#dv&quot;).css(&quot;backgroundColor&quot;,&quot;yellow&quot;); 该方法里面也可以直接写键值对的方式 $(&quot;#dv&quot;).css({&quot;width&quot;:&quot;300px&quot;,&quot;height&quot;:&quot;200px&quot;,&quot;backgroundColor&quot;:&quot;yellow&quot;}); .css(&quot;属性&quot;,&quot;属性值&quot;); .css(&quot;属性&quot;,&quot;属性值&quot;).css(&quot;属性&quot;,&quot;属性值&quot;); .css({&quot;属性&quot;:&quot;属性值&quot;,&quot;属性&quot;:&quot;属性值&quot;}); 2.1.5 操作类样式方法 addClass() addClass(&quot;类样式名字&quot;);添加一个类样式 addClass(&quot;类样式名字1 类样式名字2&quot;); removeClass() removeClass(&quot;类样式名字&quot;);移除类样式 removeClass();移除的是当前元素中所有的类样式 hasClass() hasClass(&quot;类样式名字&quot;);判断当前元素是否应用了某个类样式 toggleClass() toggleClass(&quot;类样式名字&quot;);切换元素的类样式的 2.1.6 获取兄弟元素方法 .next();获取的是当前元素的下一个兄弟元素 $(this).next().css(&quot;backgroundColor&quot;,&quot;green&quot;); .nextAll();获取的是当前元素的后面的所有的兄弟元素 $(this).nextAll().css(&quot;backgroundColor&quot;,&quot;green&quot;); .prev();获取的是当前元素的前一个兄弟元素 $(this).prev().css(&quot;backgroundColor&quot;,&quot;green&quot;); .prevAll();获取的是当前元素的前面的所有的兄弟元素 $(this).prevAll().css(&quot;backgroundColor&quot;,&quot;green&quot;); .siblings();获取的是当前元素的所有的兄弟元素(自己除外) 2.1.7 动画的方法 $(&quot;#dv&quot;).hide();//隐藏 hide()方法中可以写参数:参数类型:1.数字类型,2字符串类型 1数字类型:1000表示的是毫秒 —1秒($(&quot;#dv&quot;).hide(1000);) 2字符串类型: “slow” “normal” “fast”($(&quot;#dv&quot;).hide(&quot;normal&quot;);) $(&quot;#dv&quot;).show();//显示 show()方法中可以写参数:参数类型:1.数字类型,2字符串类型 1数字类型:1000表示的是毫秒 —1秒 2字符串类型: “slow” “normal” “fast” slideUp()、slideDown()、slideToggle() 参数:可以写数字类型 1000毫秒—1秒 参数:字符串: slow normal fast fadeIn()、fadeOut()、fadeToggle() 参数:可以写数字类型 1000毫秒—1秒 参数:字符串: slow normal fast fadeTo() fadeTo(1000，0.3),1s内透明度达到0.3 animate方法 参数：三种 1.是键值对—对象 2.时间—1000毫秒—1秒 3.匿名函数—回调函数 2.1.8 动态添加元素的方法 .append() 把元素插入到某个元素里面的后面(添加的是子元素):$(&quot;#dv&quot;).append(aObj);//把超链接追加到div中 append方法把一个元素中的元素添加到另一个元素中的时候,有点剪切（粘贴）的效果 .appendTo() 把一个元素插入到另一个元素里面(后面是父元素，前面是将要插入的元素) .prepend() 把元素插入到某个元素里面的前面(添加的是子元素)：$(&quot;#dv&quot;).prepend(aObj); .after() 把元素添加到当前元素的后面(添加的是兄弟元素)：$(&quot;#dv&quot;).after(aObj); .before() 把元素添加到当前元素的前面(添加的是兄弟元素)：$(&quot;#dv&quot;).before(aObj); 2.1.9 移除元素的方法 .html(“”) 清空元素中的内容：$(&quot;#dv&quot;).html(&quot;&quot;); .empty() 清空元素中的内容：$(&quot;#dv&quot;).empty(); .remove() 移除元素自身—自杀：$(&quot;#dv&quot;).remove(); .clone() 克隆，复制了这个元素：var spanObj = $(&quot;#dv&gt;span&quot;).clone(); 2.1.10 自定义属性 .attr() 获取元素的固有属性 可以写两个参数：参数1；属性、参数2：属性值 只写一个参数，表示取元素的这个属性的值 .prop() 获取元素的布尔属性和自定义属性，可以真正的获取元素是否选中的状态 可以写两个参数：参数1；属性、参数2：true/false (这里不是字符串true/false) 只写一个参数，表示取元素的这个属性的值 2.1.11 获取元素的宽和高 通过元素的css()方法可以获取元素的宽和高,但是都是字符串类型 var width=parseInt($(&quot;#dv&quot;).css(&quot;width&quot;))*2; var height=parseInt($(&quot;#dv&quot;).css(&quot;height&quot;))*2; 获取宽和高的属性值—-&gt;数字类型 var width=$(&quot;#dv&quot;).width()*2; var height=$(&quot;#dv&quot;).height()*2; 设置元素的宽和高—&gt;参数可以是数字也可以是字符串 $(&quot;#dv&quot;).width(width); $(&quot;#dv&quot;).height(height); 2.1.12 获取left和top的值 .offset().left —&gt; 数字类型 console.log($(&quot;#dv&quot;).offset().left); .offset().top —&gt; 数字类型 console.log($(&quot;#dv&quot;).offset().top); .offset() 传入参数，可以设置left和top的值：$(&quot;#dv&quot;).offset({&quot;left&quot;:200,&quot;top&quot;:200});2.1.13 获取的卷曲出去的距离 scrollLeft() —&gt;数字类型 console.log($(this).scrollLeft()); .scrollTop() —&gt;数字类型 console.log($(this).scrollTop()); 3. 全局的一些方法或属性3.1 链式编程 链式编程:对象.方法().方法().方法();…. 原理：调用完某个方法后返回的还是当前对象 3.2 断链 断链:对象调用方法，返回的不是当前的对象，再调用方法，调用不了，比如：$(&quot;#dv&quot;).html()，返回的是div中的html内容 解决断链—&gt;恢复到断链之前的一个效果–修复断链 .end()方法恢复到断链之前的效果 $(this).prevAll().css(&quot;backgroundColor&quot;,&quot;yellow&quot;).end().nextAll().css(&quot;backgroundColor&quot;,&quot;blue&quot;); 3.3 递归 arguments.callee 相当于递归 隐藏动画中使用到的递归：123$(&quot;div&gt;img&quot;).last(&quot;img&quot;).hide(800,function () &#123; $(this).prev().hide(800,arguments.callee); &#125;); 3.4 绑定多个事件3.4.1 采用链式编程 使用示例：(&quot;#btn&quot;).mouseover(function(){...}).mouseout(function(){...}).click(function(){...}); 3.4.2 bind()方法 第一个参数是事件名字,第二个参数是事件处理函数-匿名函数 多个事件绑定的是同一个事件处理函数：$(&quot;#btn&quot;).bind(&quot;mouseover mouseout&quot;,function () {...}); 绑定多个事件使用示例：$(&quot;#btn&quot;).bind({&quot;click&quot;:function(){...},&quot;mouseover&quot;:function(){...},&quot;mouseout&quot;:function(){...}}); 3.4.3 delegate()方法 参数:3个 1.要绑定事件的元素—p 2.要绑定的事件的名字—click 3.绑定事件的处理函数—匿名函数 使用示例：$(&quot;#dv&quot;).delegate(&quot;p&quot;,&quot;click&quot;,function () {...}); 3.4.4 on()方法 两个参数：1事件的名字，2事件处理函数 $(&quot;#btn&quot;).on(&quot;click&quot;,function () {...}); 三个参数: 1.事件的名字, 2.要绑定事件的元素–p,3事件处理函数 on是父级元素调用，目的:为子级元素去绑定事件 $(&quot;#dv&quot;).on(&quot;click&quot;,&quot;p&quot;,function(){...}); 3.5 解绑事件3.5.1 off()方法 参数:要解绑的事件的名字 $(&quot;#btn1&quot;).off(&quot;click&quot;); 3.5.2 unbind()方法 参数:要解绑的事件的名字 $(&quot;#btn1&quot;).unbind(&quot;click&quot;); 3.5.3 undelegate()方法 2个参数：1要解绑的对象，2要解绑的事件的名字 undelegate(&quot;p&quot;,&quot;click&quot;); 3.5.4 解绑事件的细节问题 对应： bind 和 unbind on 和 off delegate 和 undelegate 下面的代码是把子级元素的点击事件解绑了,父级元素的点击事件还存在 $(&quot;#dv&quot;).off(&quot;click&quot;,&quot;**&quot;);//移除**(某个子元素)的事件 $(&quot;#dv&quot;).off();//移除父级元素和子级元素的所有的事件 如果说父级元素和子级元素都是通过正常的方式绑定事件，通过off解绑的时候：父级元素的事件解绑了，子级元素的事件没有解绑 如果子级元素是通过父级元素调用delegate的方式绑定的事件,父级元素使用off方式解绑事件,这个时候父级元素和子级元素的相同的事件都会被解绑 3.6 触发事件 3三种方式 3.6.1 $(&quot;#btn1&quot;).click(); 3.6.2 trigget()方法 参数：触发事件的名字 $(&quot;#btn1&quot;).trigger(&quot;click&quot;);//触发事件 3.6.3 triggerHandler()方法 参数：触发事件的名字 $(&quot;#btn1&quot;).triggerHandler(&quot;click&quot;);//触发事件 3.7 浏览器默认事件3.7.1 .focus()方法 触发文本框的获取焦点的事件的三种方法 $(&quot;#txt&quot;).focus(); $(&quot;#txt&quot;).trigger(&quot;focus&quot;); $(&quot;#txt&quot;).triggerHandler(&quot;focus&quot;); 第一种触发事件的方式和第二种触发事件的方式是相同的,都会触发浏览器默认的事件(光标在文本框中闪烁) 第三种触发事件的方式不会触发浏览器的默认事件 3.8 获取事件对象3.8.1 arguments 获取函数在调用的时候有几个参数3.8.2 event event.delegateTarget—–&gt;div—&gt;谁代替元素绑定的事件–div event.currentTarget—–&gt;input—&gt;真正是谁绑定的事件 event.target —&gt; input—触发的事件 以上是代码分析，代码如下： 1234$(&quot;#dv&quot;).on(&quot;click&quot;,&quot;input&quot;,function(event) &#123; console.log(arguments) console.log(event) &#125;) 3.8.3 键盘事件 keydown keyup keypress e.keyCode 3.8.4 事件冒泡 事件冒泡：事件从目标元素开始，一层一层向外触发的过程叫事件冒泡。 取消事件冒泡：return false 3.8.5 取消浏览器的默认事件 return false 3.8.6 each()方法 第一个参数是索引,第二个参数是对象 each方法的使用 内部发生了隐式迭代(内部帮助我们循环遍历了每个li) 不同的元素有相同的操作 不同的元素有不同的操作 each循环遍历jquery中的(数组)对象 用法示例 1234567891011121314 //不同的元素不同的设置方式 $(&quot;#uu&gt;li&quot;).each(function (index,element) &#123; //第一个参数是索引,第二个参数是对象 //console.log(arguments[0]+&quot;=====&quot;+arguments[1]); $(element).css(&quot;opacity&quot;,(index+1)/10); &#125;); ``` ## 3.9 多库共存### 3.9.1 释放$- $.noConflict()- 让jquery对$对象进行释放控制权- `var xy=$.noConflict();`以后xy就是曾经的$- 示例： var $=100;//$原本是对象---&gt;变量 xy(function () {xy(&quot;#btn&quot;).click(function () {...}); 1234567### 3.9.2 更改$- 更改以后只能用jQuery来调用所有东西## 3.10 制作插件### 3.10.1- `$.fn.插件名字 = function(参数)&#123;...&#125;`- 示例 $.fn.changeBackgrounColor=function (color) { $(&quot;.cls&quot;).css(&quot;backgroundColor&quot;,color); }; 4. jQuery插件和jQueryUI的使用4.1 jQuery插件 jQuery之家：http://www.htmleaf.com/4.2 jQuery UI 官网：https://jqueryui.com/ 使用： 先下载整个文件 打开index.html文件的网页源代码，找到所需组件的结构 引入jQuery UI 的.css样式表]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue之mpvue]]></title>
    <url>%2F2019%2F11%2F01%2FC-10-mpvue%E4%B9%8Bmpvue%2F</url>
    <content type="text"><![CDATA[1. mpvue(Vue in Mini Program)1.1 简介 美团工程师推出的基于Vue.js封装的用于开发小程序的框架 融合了原生小程序和Vue.js的特点 可完全组件化开发1.2 特点 组件化开发 完成Vue.js开发体验(前提是熟悉Vue) 可使用Vuex管理状态]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>mpvue</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具之Webpack]]></title>
    <url>%2F2019%2F10%2F31%2FG-03-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B9%8BWebpack%2F</url>
    <content type="text"><![CDATA[0.铺垫0.1 在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 0.2 网页中引入的静态资源多了以后有什么问题？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 0.3 如何解决上述两个问题？ 合并、压缩、精灵图、图片的Base64编码。 可以使用的requireJS、webpack解决各个包之间的复杂依赖关系。 1.webpack31.1了解Webpack相关1.1.1 什么是webpack? webpack是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； Webpack是一个模块打包器(bundler)。 在Webpack看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理 它将根据模块的依赖关系进行静态分析，生成对应的静态资源。 webpack能够处理JS文件的互相依赖关系。 webpack能够处理JS的兼容问题，把高级的 浏览器不识别的 语法转为低级的 浏览器能正常识别的语法。 1.1.2 webpack安装 1、全局安装(建议安装3.6.0) npm install webpack -g npm install webpack-cli -g webpack -v：查看是否安装成功 2、局部安装 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 1.2 webpack基本使用 webpack.config.js文件： 代码：1234567const path = require(&apos;path&apos;)module.exports = &#123; entry: path.join(__dirname,&apos;./src/main.js&apos;), 设置入口文件 output: &#123;...&#125;, 设置出口文件 devServer: &#123;...&#125;, 设置自动编译打包 plugins: [...], 放置插件&#125; 1.2.1 文件夹的创建 src文件夹：根文件 主页面(index.html) 入口js文件(main.js) dist文件夹：放置是给用户的文件(产品级的) 1.2.1 文件的引入 1、直接使用npm下载所需文件 2、也无需再像以前那样在head标签里引入所需文件(静态资源) 3、把要使用的文件在通过入口js文件(main.js)以模块的形式引入，再导入入口js文件即可 导入jQuery(3.2.1)：import $ from &#39;jquery&#39; / const $ = require(&#39;jquery&#39;) import XXX from XXX 是ES6中导入模块的方式，require是node里面的方式 浏览器不支持ES6的语法，也不支持node的语法，所以要用webpack进行处理 导入css/less/sass：import &#39;./index.css&#39; /.less/.scss 导入当前目录下的css目录里的某个文件 4、用webpack对入口js文件进行处理(4.0以上版本处理方法不同) webpack 入口文件的路径(.\src\main.js) -o 输出到什么位置的什么文件中(.\dist\bundle.js) 1.3 webpack基本配置1.3.1 为什么要进行配置 为了更方便地使用webpack，配置以后不需要我们每次手动输入指令。 1.3.2 一些基本配置 1、在根目录中创建配置文件(webpack.config) 2、webpack是基于node的，用node的语法将配置文件导出为一个模块 module.exports = {...} 由于使用到path模块，所以要导入：const path = require(&#39;path&#39;) 3、配置入口文件和出口文件 入口文件：entry: path.join(__dirname, &#39;./src/main.js&#39;) 出口文件：output；{path: path.join(__dirname, &#39;./dist&#39;), filename: &#39;bundle.js&#39;} 4、代码示例： 12345678const path = require(&apos;path&apos;)module.exports = &#123; entry: path.join(__dirname,&apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname,&apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 5、此时只需要运webpack命令就可以对main.js文件进行打包 1.4 webpack-dev-sever1.4.1 为什么要使用webpack-dev-sever？ 能够实现自动打包编译，使用这个工具不再需要我们手动输入命令进行打包。 配置文件(默认) webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象 1.4.2 webpack做了什么？ 在控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步： 1、首先，webpack 发现，我们并没有通过命令的形式，给它指定入口和出口 2、webpack就会去项目的根目录中，查找一个叫做 webpack.config.js 的配置文件 3、当找到配置文件后，webpack 会去解析执行这 配置文件，当解析执行完配置文件后，就得到了配置文件中，导出的配置对象 4、当 webpack 拿到 配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建。 1.4.3 webpack-dev-server做了什么？ 1、把这个工具安装到项目的本地开发依赖。 2、安装完毕后，这个工具的用法和webpack命令的用法完全一样 3、由于是在项目中，本地安装的 webpack-dev-server ， 所以无法把它当作脚本命令，在powershell终端中直接运行；（只有那些安装到全局-g的工具，才能在终端中正常执行） 4、注意： webpack-dev-server 这个工具如果想要正常运行，要求在本地项目中，必须安装 webpack 5、webpack-dev-server 帮我们打包生成的 bundle.js 文件，并没有存放到实际的 物理磁盘上；而是直接托管到了电脑的内存中，所以在项目根目录中根本找不到这个打包好的bundle.js; 6、我们可以认为， webpack-dev-server 把打包好的文件，以一种虚拟的形式托管到了项目的根目录中，虽然我们看不到它，但是可以认为和dist、src、node_modules 平级，有一个看不见的文件，叫做 bundle.js 1.4.4 安装 1、安装之前最好在本地安装相应版本的webpack，防止出错。 2、npm i webpack-dev-sever -D：把这个工具安装到项目的开发依赖 3、在package.json文件中的”scripts”下添加如下配置：&quot;dev&quot;:&quot;webpack-dev-server&quot; 4、运行npm run dev —&gt; 这样就开启了webpack-server，每当文件做出修改，都会自动进行打包编译 5、此时打包编译好的文件已经不再是我们自己指定的路径，而是根目录下一个虚拟的文件(/bundle.js)，是存放在内存中的。 6、ctrl + c 退出服务器 7、此时仍需手动去浏览器打开页面(根据运行结果给的地址手动打开页面) 1.5 webpack-plugin 插件可以完成一些loader不能完成的功能。 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。 CleanWebpackPlugin: 自动清除指定文件夹资源 HtmlWebpackPlugin: 自动生成HTML文件并 UglifyJSPlugin: 压缩js文件 1.5.1 实现webpack的实时打包构建 1、方式1： 在package.json中配置自动打开浏览器： &quot;dev2&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot; 上述4个指令（推荐使用的方式） 自动打开、端口为3000、默认打开的根路径是src、启用热重载/热更新 2、热更新：不是每次都生成一个新的文件，而是只变动修改的地方（打补丁）。 作用1：打补丁 方式2热更新的配置需要3步：(在webpack.config.js文件中) 第一步：devSever中的hot属性为true 第二步：导入webpack模块：const webpack = require(&#39;webpack&#39;)，因为webpack带有热加载模块的插件。 第三步：在webpack.config.js配置文件(模块)中添加plugins属性，值为一个数组 在数组中加入new出来的一个热更新的模块对象：plugins:[new webpack.HotModuleReplacementPlugin()] 3、 方式2： 在webpack.config.js配置文件(模块)中添加devSever属性，值为一个对象 该对象有四个属性：open、port、contentBase、hot 值分别为：true、端口号、要指定的根目录、true 代码示例：123456789101112131415161718const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: path.join(__dirname,&apos;./src/main.js&apos;), output: &#123; path: path.join(__dirname,&apos;./dist&apos;), filename: &apos;bundle.js&apos; &#125;, devServer: &#123; open: true, port: 3000, contentBase: scr, hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; 1.5.2 使用html-webpack-plugin插件配置启动页面 1、安装插件 cnpm i html-webpack-plugin -D 2、在webpack.config.js文件中导入包 const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) 3、在plugins属性中添加new出来的一个模块对象 1234plugins: [new htmlWebpackPlugin(&#123; template:path.resolve(__dirname,&apos;src/index.html&apos;), filename: &apos;index.html&apos;&#125;)] 4、package.json文件中的”dev”对应的应该是”webpack-dev-server” 运行npm run dev即可 5、当使用html-webpack-plugin之后，我们不再需要手动处理bundle.js的引用路径了，因为这个插件已经帮我们自动创建了一个合适的script , 并且引用了正确的路径。 1.6 webpack-loader1.6.1 为什么要用loader？ Webpack 本身只能加载JS/JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader进行转换/加载 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块 它本身是一个函数，接受源文件作为参数，返回转换的结果 loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。 1.6.2 安装loader 1、cnpm i style-loader css-loader -D —&gt; 注意安装的版本要与webpack版本相对应 2、在webpack.config.js配置文件(模块)中添加module属性，值为一个对象 该对象内部有一个rules属性，值为一个数组，数组的每一项均为一个对象 内部有test属性和use属性 代码如下：1234567module: &#123; rules: [ // 所有第三方模块的 匹配规则 &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, ]&#125; 3、安装less-loader：cnpm i less-loader -D 4、安装sass-loader：cnpm i sass-loader -D 5、处理 1.6.3 webpack 处理第三方文件类型的过程： 1、发现这个要处理的文件不是JS文件，然后就去配置文件中查找有没有对应的第三方 loader规则 2、如果能找到对应的规则，就会调用对应的loader处理这种文件类型。 3、在调用loader的时候，是从后往前调用的。 4、当最后的一个loader调用完毕，会把处理的结果，直接交给webpack进行打包合并，最终输出到 bundle.js中去 1.7 url-loader1.7.1 为什么使用url-loader 默认情况下webpack无法处理CSS文件中的url地址，不管是图片还是字体库，只要是URL地址，都处理不了。 1.7.2 安装url-loader 1、下载安装： cnpm i url-loader file-loader -D url-loader内部依赖于第三方file-loader 2、配置webpack.config.js文件中的module属性 limit给定的值，是图片的大小，单位是byte，如果引用的图片大于或等于给定的limit值，则不会被转为base64格式的字符串，如果图片小于给定的 limit 值，则会被转为 base64的字符串12&#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]&apos; &#125;, // 处理 图片路径的 loader&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos; &#125;, // 处理字体文件的loader 3、用？来传参 4、不同路径下的两张名字相同的图片，经过自动打包编译处理之后，都在虚拟的根目录下了。 所以一定要在name参数前添加hash值以区分。hash值可以是8位或者是32位，如上面代码示例的那样。 1.8 webpack-loader-Babel1.8.1 为什么要使用Babel？ 在webpack中，默认只能处理一部分ES6的新语法，一些更高级的ES6语法或者ES7 语法，webpack是处理不了的；这时候就需要借助于第三方的loader，来帮助webpack 处理这些高级的语法，当第三方loader把高级语法转为低级的语法之后，会把结果交给webpack去打包到bundle.js中 通过Babel ，可以帮我们将高级的语法转换为低级的语法 1.8.2 下载安装Babel 1、在webpack中，可以运行如下两套命令安装两套包，去安装Babel相关的loader功能： 第一套包： cnpm i babel-core babel-loader babel-plugin-transform-runtime -D —&gt; Babel的转换工具 第二套包： cnpm i babel-preset-env babel-preset-stage-0 -D —&gt; 语法 2、配置webpack.config.js文件中的module属性： { test:/\.js$/, use: &#39;babel-loader&#39;, exclude:/node_modules/ } 3、注意：在配置babel的loader规则的时候，必须把node_modules目录通过 exclude选项排除掉。原因有俩： 如果不排除node_modules，则Babel会把node_modules中所有的第三方JS文件，都打包编译，这样会非常消耗CPU，同时打包速度非常慢； 哪怕最终Babel把所有node_modules中的JS转换完毕了，项目也无法正常运行！ 4、在项目的根目录中，新建一个叫做 .babelrc 的Babel配置文件，这个配置文件属于JSON格式，所以在写 .babelrc 配置的时候，必须符合JSON语法规范：不能写注释，字符串必须用双引号。 在 .babelrc 写如下的配置：可以把 preset 翻译成 【语法】 的意思1234&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]&#125; 5、了解：目前安装的 babel-preset-env是比较新的ES语法， 之前安装的是 babel-preset-es2015, 现在出了一个更新的语法插件，叫做babel-preset-env ，它包含了所有和es***相关的语法。 1.2 学习文档 webpack官网: http://webpack.github.io/ webpack3文档(英文): https://webpack.js.org/ webpack3文档(中文): https://doc.webpack-china.org/ 1.3 安装webpack 1.4 开启项目 初始化项目： 生成package.json文件 1234&#123;&quot;name&quot;: &quot;webpack_test&quot;,&quot;version&quot;: &quot;1.0.0&quot;&#125; 安装webpack npm install webpack -g //全局安装 npm install webpack –save-dev //局部安装 1.5 编译打包应用 创建入口src/js/ : entry.js document.write(&quot;entry.js is work&quot;); 创建主页面: dist/index.html &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 编译js - webpack src/js/entry.js dist/bundle.js 查看页面效果 1.6 添加js/json文件 创建第二个js: src/js/math.js 1234567export function square(x) &#123; return x - x;&#125;export function cube(x) &#123; return x - x - x;&#125; 创建json文件: src/json/data.json 1234&#123; &quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 12&#125; 更新入口js : entry.js 123456import &#123;cube&#125; from &apos;./math&apos;import data from &apos;../json/data.json&apos;//注意data(json文件)会自动被转换为原生的js对象或者数组document.write(&quot;entry.js is work &lt;br/&gt;&quot;);document.write(cube(2) + &apos;&lt;br/&gt;&apos;);document.write(JSON.stringify(data) + &apos;&lt;br/&gt;&apos;) 编译js: 1webpack src/js/entry.js dist/bundle.js 查看页面效果 1.6 使用webpack配置文件 创建webpack.config.js 123456789const path = require(&apos;path&apos;); //path内置的模块，用来设置路径。module.exports = &#123; entry: &apos;./src/js/entry.js&apos;, // 入口文件 output: &#123; // 输出配置 filename: &apos;bundle.js&apos;, // 输出文件名 path: path.resolve(__dirname, &apos;dist&apos;) //输出文件路径配置 &#125;&#125;; 配置npm命令: package.json 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;&#125;, 打包应用 1npm run build 1.7 打包css和图片文件 安装样式的loader 123npm install css-loader style-loader --save-devnpm install file-loader url-loader --save-dev补充：url-loader是对象file-loader的上层封装，使用时需配合file-loader使用。 配置loader 12345678910111213141516171819202122module: &#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader&apos;,// 使用样式 &apos;css-loader&apos;//加载样式 ] &#125;, &#123; test: /\.(png|jpg|gif)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 8192 &#125; &#125; ] &#125; ]&#125; 向应用中添加2张图片: 小图: img/logo.png 大图: img/big.jpg 创建样式文件: src/css/test.css 123body &#123; background: url(&apos;../img/logo.jpg&apos;)&#125; 更新入口js : entry.js - import &#39;../css/test.css&#39; 添加css样式 12345678910#box1&#123; width: 300px; height: 300px; background-image: url(&quot;../image/logo.jpg&quot;);&#125;#box2&#123; width: 300px; height: 300px; background-image: url(&quot;../image/big.jpg&quot;);&#125; index.html添加元素 12&lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;&lt;/div&gt; 执行打包命令： 1npm run build 发现问题： 大图无法打包到entry.js文件中，index.html不在生成资源目录下。 页面加载图片会在所在目录位置查找，导致页面加载图片时候大图路径无法找到 解决办法： 使用publicPath : ‘dist/js/‘ //设置为index.html提供资源的路径,设置完后找所有的资源都会去当前目录下找。 将index.html放在dist/js/也可以解决。 1.8 自动编译打包 利用webpack开发服务器工具 webpack-dev-server 下载 - npm install --save-dev webpack-dev-server webpack配置 123devServer: &#123;contentBase: &apos;./dist&apos;&#125;, package配置 - &quot;start&quot;: &quot;webpack-dev-server --open&quot; 编译打包应用并运行 - npm start 1.9使用webpack插件 常用的插件 使用html-webpack-plugin根据模板html生成引入script的页面 使用clean-webpack-plugin清除dist文件夹 下载 1npm install --save-dev html-webpack-plugin clean-webpack-plugin webpack配置 123456const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //自动生成html文件的插件const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;); //清除之前打包的文件 plugins: [ new HtmlWebpackPlugin(&#123;template: &apos;./index.html&apos;&#125;), new CleanWebpackPlugin([&apos;dist&apos;]),] 创建页面: index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;webpack test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!--打包文件将自动通过script标签注入到此处--&gt;&lt;/body&gt;&lt;/html&gt; 打包运行项目 12npm run buildnpm start]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具之Gulp]]></title>
    <url>%2F2019%2F10%2F31%2FG-02-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B9%8BGulp%2F</url>
    <content type="text"><![CDATA[1. Gulp须知 任务化 基于流 有自己的内存（从内存里输出流到本地） 输入流：从本地读数据到Gulp的内存 输出流：在内部处理完之后，从Gulp的内存六道本地 执行任务是异步（return是关键）的，也可以同步。要确保先后用依赖！ 2. Gulp介绍 中文主页: http://www.gulpjs.com.cn/ gulp是与grunt功能类似的前端项目构建工具, 也是基于Nodejs的自动任务运行器 能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的合并、压缩、检查、监听文件变化、浏览器自动刷新、测试等任务 gulp更高效(异步多任务), 更易于使用, 插件高质量 安装 nodejs, 查看版本: node -v 创建一个简单的应用gulp_test123456789101112|- dist|- src |- js |- css |- less|- index.html|- gulpfile.js-----gulp配置文件|- package.json &#123; &quot;name&quot;: &quot;gulp_test&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 3.安装gulp 全局安装gulp 1npm install gulp -g 局部安装gulp 1npm install gulp --save-dev 配置编码: gulpfile.js 1234567//引入gulp模块var gulp = require(&apos;gulp&apos;);//定义默认任务gulp.task(&apos;任务名&apos;, function() &#123; // 将你的任务的任务代码放在这&#125;);gulp.task(&apos;default&apos;, [&apos;任务&apos;])//异步执行 构建命令: 1gulp 4.使用gulp插件 相关插件: gulp-concat : 合并文件(js/css) gulp-uglify : 压缩js文件 gulp-rename : 文件重命名 gulp-less : 编译less gulp-clean-css : 压缩css gulp-livereload : 实时自动编译刷新 5.重要API gulp.src(filePath/pathArr) : 指向指定路径的所有文件, 返回文件流对象 用于读取文件 gulp.dest(dirPath/pathArr) 指向指定的所有文件夹 用于向文件夹中输出文件 gulp.task(name, [deps], fn) 定义一个任务 gulp.watch() 监视文件的变化 6.处理js 创建js文件 src/js/test1.js 12345678(function () &#123; function add(num1, num2) &#123; var num3 = 0; num1 = num2 + num3; return num1 + num2; &#125; console.log(add(10, 30));&#125;)(); src/js/test2.js 123456(function () &#123; var arr = [2,3,4].map(function (item, index) &#123; return item+1; &#125;); console.log(arr);&#125;)(); 下载插件: 1npm install gulp-concat gulp-uglify gulp-rename --save-dev 配置编码 1234567891011121314var concat = require(&apos;gulp-concat&apos;);var uglify = require(&apos;gulp-uglify&apos;);var rename = require(&apos;gulp-rename&apos;);gulp.task(&apos;minifyjs&apos;, function() &#123; return gulp.src(&apos;src/js/*.js&apos;) //操作的源文件 .pipe(concat(&apos;built.js&apos;)) //合并到临时文件 .pipe(gulp.dest(&apos;dist/js&apos;)) //生成到目标文件夹 .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //重命名 .pipe(uglify()) //压缩 .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);gulp.task(&apos;default&apos;, [&apos;minifyjs&apos;]); 页面引入js浏览测试 : index.html 1&lt;script type=&quot;text/javascript&quot; src=&quot;dist/js/built.min.js&quot;&gt;&lt;/script&gt; 打包测试: gulp 7.处理css 创建less/css文件 src/css/test1.css 12345#div1 &#123; width: 100px; height: 100px; background: green;&#125; src/css/test2.css 12345#div2 &#123; width: 200px; height: 200px; background: blue;&#125; src/less/test3.less 123@base: yellow;.index1 &#123; color: @base; &#125;.index2 &#123; color: green; &#125; 下载插件: 1npm install gulp-less gulp-clean-css --save-dev 配置编码 12345678910111213141516171819202122var less = require(&apos;gulp-less&apos;);var cleanCSS = require(&apos;gulp-clean-css&apos;);//less处理任务gulp.task(&apos;lessTask&apos;, function () &#123;return gulp.src(&apos;src/less/*.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;src/css&apos;));&#125;)//css处理任务, 指定依赖的任务gulp.task(&apos;cssTask&apos;,[&apos;lessTask&apos;], function () &#123;return gulp.src(&apos;src/css/*.css&apos;) .pipe(concat(&apos;built.css&apos;)) .pipe(gulp.dest(&apos;dist/css&apos;)) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(cleanCSS(&#123;compatibility: &apos;ie8&apos;&#125;)) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;);gulp.task(&apos;default&apos;, [&apos;minifyjs&apos;, &apos;cssTask&apos;]); 页面引入css浏览测试 : index.html 123&lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/built.min.css&quot;&gt;&lt;div id=&quot;div1&quot; class=&quot;index1&quot;&gt;div1111111&lt;/div&gt;&lt;div id=&quot;div2&quot; class=&quot;index2&quot;&gt;div2222222&lt;/div&gt; 打包测试: gulp 8.处理html 下载插件: 1npm install gulp-htmlmin --save-dev 配置编码 12345678var htmlmin = require(&apos;gulp-htmlmin&apos;);//压缩html任务gulp.task(&apos;htmlMinify&apos;, function() &#123; return gulp.src(&apos;index.html&apos;) .pipe(htmlmin(&#123;collapseWhitespace: true&#125;)) .pipe(gulp.dest(&apos;dist&apos;));&#125;);gulp.task(&apos;default&apos;, [&apos;minifyjs&apos;, &apos;cssTask&apos;, &apos;htmlMinify&apos;]); 修改页面引入 12&lt;link rel=&quot;stylesheet&quot; href=&quot;css/built.min.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/built.min.js&quot;&gt;&lt;/script&gt; 打包测试: gulp 9.自动编译 下载插件 1npm install gulp-livereload --save-dev 配置编码: 123456789101112var livereload = require(&apos;gulp-livereload&apos;); //在所有的pipe后面加上.pipe(livereload());gulp.task(&apos;watch&apos;, [&apos;default&apos;], function () &#123; //开启监视livereload.listen();//监视指定的文件, 并指定对应的处理任务gulp.watch(&apos;src/js/*.js&apos;, [&apos;minifyjs&apos;])gulp.watch([&apos;src/css/*.css&apos;,&apos;src/less/*.less&apos;], [&apos;cssTask&apos;,&apos;lessTask&apos;]);&#125;); 10.热加载(实时加载) 下载插件：gulp-connect 12345678910111213141、 npm install gulp-connect --save-dev2、 注册 热加载的任务 server，注意依赖build任务 3、注册热加载的任务 //配置加载的选项 connect.server(&#123; root : &apos;dist/&apos;,//提供服务的根路径 livereload : true,//是否实时刷新 port : 5000//开启端口号 &#125;); // 自动开启链接 open(&apos;http://localhost:5000&apos;);//npm install open --save-dev // 监视目标文件 gulp.watch(&apos;src/js/*.js&apos;, [&apos;js&apos;]); gulp.watch([&apos;src/css/*.css&apos;, &apos;src/css/*.less&apos;], [&apos;cssMin&apos;, &apos;less&apos;]); 11.扩展 打包加载gulp插件 前提：将插件下载好。 下载打包插件： gulp-load-plugins npm install gulp-load-plugins –save-dev 引入： var $ = require(‘gulp-load-plugins’)();！！！引入的插件是个方法，必须记住调用。 神来之笔：其他的插件不用再引入了 使用方法： 1234567* 所有的插件用 $ 引出，其他插件的方法名统一为插件的功能名字(即插件名字的最后一部分)：如：concat,connect,cssmin...gulp.task(&apos;lib&apos;, function() &#123; gulp.src(&apos;bower_components/**/*.js&apos;) .pipe(gulp.dest(app.devPath + &apos;vendor&apos;)) .pipe(gulp.dest(app.prdPath + &apos;vendor&apos;)) .pipe($.connect.reload());&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具之Grunt]]></title>
    <url>%2F2019%2F10%2F31%2FG-01-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B9%8BGrunt%2F</url>
    <content type="text"><![CDATA[1.项目构建1. 对项目构建的理解 什么是项目构建? 编译项目中的js, sass, less 合并js/css等资源文件 压缩js/css/html等资源文件 JS语法的检查 …… 构建工具的作用? 简化项目构建, 自动化完成构建。 1.2 构建工具 Grunt Gulp Webpack 2. Grunt快速入门2.1 Grunt介绍 中文主页 : http://www.gruntjs.net/ 是一套前端自动化构建工具，一个基于nodeJs的命令行工具 它是一个任务运行器, 配合其丰富强大的插件 常用功能: 合并文件(js/css) 压缩文件(js/css) 语法检查(js) less/sass预编译处理 其它… 2.2 安装Grunt 安装nodejs, 查看版本 1node -v 创建一个简单的应用grunt_test 12345678910111213 |- build----------构建生成的文件所在的文件夹 |- src------------源码文件夹 |- js---------------js源文件夹 |- css--------------css源文件夹 |- index.html-----页面文件 |- Gruntfile.js---grunt配置文件(注意首字母大写) |- package.json---项目包配置文件 &#123; &quot;name&quot;: &quot;grunt_test&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; ``` * 全局安装 grunt-cli npm install -g grunt-cli 1* 安装grunt npm install grunt –save-dev 1* 运行构建项目命令 grunt //提示 Warning: Task “default” not found 12345678910### 2.3 配置文件* 配置文件: Gruntfile.js * 此配置文件本质就是一个node函数类型模块 * 配置编码包含3步: 1. 初始化插件配置 2. 加载插件任务 3. 注册构建任务 * 基本编码: module.exports = function(grunt){ // 1. 初始化插件配置 grunt.initConfig({ //主要编码处 }); // 2. 加载插件任务 // grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;); // 3. 注册构建任务 grunt.registerTask(&apos;default&apos;, []); }; 123456789101112131415161718192021222324 * 命令: grunt //提示成功, 但没有任何效果(还没有使用插件定义任务)### 2.4 Grunt插件介绍 * grunt官网的插件列表页面 http://www.gruntjs.net/plugins * 插件分类: * grunt团队贡献的插件 : 插件名大都以contrib-开头 * 第三方提供的插件 : 大都不以contrib-开头 * 常用的插件: * grunt-contrib-clean——清除文件(打包处理生成的) * grunt-contrib-concat——合并多个文件的代码到一个文件中 * grunt-contrib-uglify——压缩js文件 * grunt-contrib-jshint——javascript语法错误检查； * grunt-contrib-cssmin——压缩/合并css文件 * grunt-contrib-htmlmin——压缩html文件 * grunt-contrib-imagemin——压缩图片文件(无损) * grunt-contrib-copy——复制文件、文件夹 * grunt-contrib-watch——实时监控文件变化、调用相应的任务重新执行### 2.5 合并js* 使用concat插件* 命令:下载插件 npm install grunt-contrib-concat –save-dev 12* 编码: * src/js/test1.js (function () { function add(num1, num2) { return num1 + num2; } console.log(add(10, 20)); })(); 1* src/js/test2.js (function () { var arr = [2,3,4].map(function (item, index) { return item+1; }); console.log(arr); })(); 12* 配置: Gruntfile.js* 配置任务: concat: { options: { //可选项配置 separator: &apos;;&apos; //使用;连接合并 }, build: { //此名称任意 src: [&quot;src/js/*.js&quot;], //合并哪些js文件 dest: &quot;build/js/built.js&quot; //输出的js文件 } } 1* 加载插件: grunt.loadNpmTasks(‘grunt-contrib-concat’); 1* 注册任务: grunt.registerTask(‘default’, [‘concat’]); 1* 命令: grunt //会在build下生成一个built.js 12345### 2.6 压缩js* 使用uglify插件* 下载 npm install grunt-contrib-uglify –save-dev 12* 配置: Gruntfile.js* 配置任务: pkg : grunt.file.readJSON(‘package.json’), uglify : { options: { //不是必须的 banner: &apos;/*! &lt;%= pkg.name %&gt; - v&lt;%= pkg.version %&gt; - &apos; + &apos;&lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */&apos; }, build: { files: { &apos;build/js/built-&lt;%=pkg.name%&gt;-&lt;%=pkg.version%&gt;.min.js&apos;: [&apos;build/js/built.js&apos;] } } } 1* 加载任务: grunt.loadNpmTasks(‘grunt-contrib-uglify’); 1* 注册任务: grunt.registerTask(‘default’, [‘concat’, ‘uglify’]); 1* 命令: grunt //会在build下生成一个压缩的js文件 12345### 2.7 js语法检查* 使用jshint插件* 命令: npm install grunt-contrib-jshint –save-dev 1* 编码: .jshintrc { “curly”: true, “eqeqeq”: true, “eqnull”: true, “expr” : true, “immed”: true, “newcap”: true, “noempty”: true, “noarg”: true, “regexp”: true, “browser”: true, “devel”: true, “node”: true, “boss”: false, //不能使用未定义的变量 “undef”: true, //语句后面必须有分号 “asi”: false, //预定义不检查的全局变量 “predef”: [ “define”, “BMap”, “angular”, “BMAP_STATUS_SUCCESS”] } 1* 修改src/js/test1.js (function () { function add(num1, num2) { num1 = num1 + num3 return num1 + num2; } console.log(add(10, 20)); })(); 12* 配置 : Gruntfile.js* 配置任务: jshint : { options: { jshintrc : &apos;.jshintrc&apos; //指定配置文件 }, build : [‘Gruntfile.js’, ‘src/js/*.js’] //指定检查的文件 } 1* 加载任务: grunt.loadNpmTasks(‘grunt-contrib-jshint’); 1* 注册任务: grunt.registerTask(‘default’, [‘concat’, ‘uglify’, ‘jshint’]); 1* 命令: grunt //提示变量未定义和语句后未加分号 –&gt;修改后重新编译 1234### 2.8 使用cssmin插件* 安装: npm install grunt-contrib-cssmin –save-dev 12* 编码: * test1.css #box1 { width: 100px; height: 100px; background: red; } 1* test2.css #box2 { width: 200px; height: 200px; background: blue; } 1* index.html 123 * 配置 : Gruntfile.js* 配置任务: cssmin:{ options: { shorthandCompacting: false, roundingPrecision: -1 }, build: { files: { &apos;build/css/output.min.css&apos;: [&apos;src/css/*.css&apos;] } } } 1* 加载任务: grunt.loadNpmTasks(‘grunt-contrib-cssmin’); 1* 注册任务: grunt.registerTask(‘default’, [‘concat’, ‘uglify’, ‘jshint’, ‘cssmin’]); 1* 命令: grunt //在build/css/下生成output.min.css 123456### 2.9 使用watch插件（真正实现自动化） * 命令: npm install grunt-contrib-watch --save-dev* 配置 : Gruntfile.js* 配置任务: watch : { scripts : { files : [&apos;src/js/*.js&apos;, &apos;src/css/*.css&apos;], tasks : [&apos;concat&apos;, &apos;jshint&apos;, &apos;uglify&apos;, &apos;cssmin&apos;], options : {spawn : false} } } 1* 加载任务: grunt.loadNpmTasks(‘grunt-contrib-watch’); 1* 注册任务: grunt.registerTask(‘default’, [‘concat’, ‘uglify’, ‘jshint’, ‘watch’]); 改进：grunt.registerTask(‘myWatch’, [‘default’,’watch’]); 1* 命令: grunt //控制台提示watch已经开始监听, 修改保存后自动编译处理]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
        <category>Grunt</category>
      </categories>
      <tags>
        <tag>Grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之类与继承]]></title>
    <url>%2F2019%2F10%2F30%2FE-03-ES6%E4%B9%8B%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[1. 类1.1 定义类 语法：class 类名{构造函数、方法(静态方法/普通方法)} 1234567891011121314151617181920Class Animal &#123; //静态方法 static showInfo() &#123; console.log(&apos;wang~&apos;); &#125; //构造函数 constructor(name) &#123; this.name = name; &#125; // 方法 showName() &#123; console.log(this.name); &#125;&#125;//实例化let dog = new Animal(&apos;haha&apos;);// 调用方法dog.showName();// 调用静态方法Animal.showInfo(); 静态方法 就是用static修饰词修饰的方法。 静态方法只能通过类名调用，不可以使用实例对象调用。 1.2 类的继承（extends） 语法：class 类名 extends 父类{构造函数、方法(静态方法/普通方法)} 123456789101112131415161718Class Dog extends Animal &#123; //构造函数 constructor(name,color) &#123; super(name);// super用来调用父类 this.color = color; &#125; // 方法 showColor() &#123; console.log(this.color); &#125;&#125;//实例化let dog1 = new Dog(&apos;dudu&apos;);// 调用方法dog1.showColor();dog1.showName(); // 继承了父类的方法// 静态方法的继承(通过类名调用)Dog.showInfo();]]></content>
      <categories>
        <category>前端</category>
        <category>ECMAScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>类与继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之扩展]]></title>
    <url>%2F2019%2F10%2F30%2FE-02-ES6%E4%B9%8B%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[1. 字符串相关扩展 几个常用的API 1.1 includes(); 判断字符串中是否包含指定的定的字串（有的话返回true，否则false） 可以传一个参数（匹配的子串）或两个参数（第二个参数代表从指定位置开始匹配） 一个参数：console.log(&#39;hello world&#39;.includes(&#39;world&#39;)) —-&gt; true 两个参数：console.log(&#39;hello world&#39;.includes(&#39;world&#39;,7)) —-&gt; false 1.2 startswith(); 判断字符串是否以特定的子串开始 示例： let url = &#39;admin/index.php&#39; console.log(url.startswith(&#39;admin&#39;)—-&gt; true 1.3 endswith(); 判断字符串是否以特定的子串开始 示例：console.log(url.endswith(&#39;php&#39;)—-&gt; true 1.4 !模板字符串(！重要) 反引号表示模板，模板中的内容可以有格式，通过${}方式填充数据。 ${}里面也支持一些简单的表达式运算/函数调用 示例：1234567891011121314// 声明一个对象let obj = &#123; username : &apos;lisi&apos;, age : &apos;12&apos;, gender : &apos;male&apos;&#125;// 声明一个模板let tpl = ` &lt;div&gt; &lt;span&gt;S&#123;obj.username&#125;&lt;/span&gt; &lt;span&gt;S&#123;obj.age&#125;&lt;/span&gt; &lt;span&gt;S&#123;obj.gender&#125;&lt;/span&gt; &lt;/div&gt;` 2. 函数的相关扩展2.1 参数默认值 普通给参数默认值 12345function foo(param) &#123; let p = param || &apos;hello&apos;; console.log(p)&#125;foo(&apos;hi&apos;); es6中给参数默认值：function foo(p = &#39;hello&#39;) { console.log(p)} 2.2 参数解构赋值 示例： 12345//此处传了一个默认值 function foo(&#123;username=&apos;lisi&apos;,age=&apos;13&apos;&#125;=&#123;&#125;) &#123; console.log(username,age); &#125; foo(&#123;username=&apos;zasa&apos;,age=&apos;15&apos;&#125;); 2.3 rest(剩余)参数 示例：function foo(a,...param){console.log(param);}，调用foo(1,2,3,4,5); param 是一个数组，将传入没显示的参数放在里面。上述例子中param = [2,3,4,5] 作用：把单个参数变成数组。 2.4 …扩展运算符 作用：与rest参数相反，把数组拆成单个。 示例： 123456789// 实现下列函数功能function foo(a,b,c,d,e)&#123; console.log(a+b+c+d+e);&#125;let arr = [1,2,3,4,5];// 普通情况foo.apply(null,arr);// es6的扩展运算符foo(...arr); 具体应用：合并数组(arr3 = [1,2,3,4,5,6]) let arr1 = [1,2,3]; let arr2 = [4,5,6]; let arr3 = [...arr1,...arr2]; 2.5 箭头函数 用法示例：let foo = (形参) =&gt; {代码} —&gt; 调用：foo(实参) 多个参数小括号不能省略，多行代码大括号不能省略 传一个参数（小括号可以省略）单行代码（大括号可以省略）示例: let foo = v =&gt; v; 等价于let foo(v) {console.log(v);}—&gt; 调用：foo() 传多个参数单行代码（大括号可以省略）示例：let foo = (a,b) =&gt; console.log(a+b); 传多个参数多行代码示例：let foo = (a,b) =&gt; {let c = 1;console.log(a+b+c);} 大括号 函数体不用大括号: 默认返回结果 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回。 匿名函数（遍历示例）：forEach()的第一个参数表示值，第二个参数表示索引。 123456789 let arr = [12,34,56]//常规遍历arr.forEach(function(element,index)&#123; console.log(element,index);&#125;)// 箭头函数arr.forEach((element,index)=&gt;&#123; console.log(element,index);&#125;) 箭头函数注意事项1： 箭头函数中this取决于函数的定义，而不是调用 箭头函数的this看外层的是否有函数.如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是全局（相当于window的node.js里面的）。 更换this可以与普通函数一样用call(obj)。使用call调用时，this就是call的最后一个参数。 箭头函数注意事项2： 箭头函数不可以new，可以如下操作： 12let foo = () =&gt; &#123;this.num = 123;&#125;new foo(); 箭头函数不可以使用arguments获取参数列表，可以使用rest参数代替，如下操作：let foo = (...param) =&gt; {console.log(param);}，调用foo(123,456)。]]></content>
      <categories>
        <category>前端</category>
        <category>ECMAScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之变量]]></title>
    <url>%2F2019%2F10%2F30%2FE-02-ES6%E4%B9%8B%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1. 变量的声明1.1 let let声明不存在预解析。先使用后声明会报错！ let声明的变量不允许重复(在同一个作用域内)。 ES6引入了块级作用域：块内部定义的变量，在外部是不可以访问的 一个大括号({})就可以表示是一个块级作用域。 如：{let flag = 111}，这里的let就不能被外部访问。 for循环括号中用let声明的变量只能在循环体中使用。 在块级作用域内部，变量也只能先声明再使用。 1.2 const let的规则，const一样适用 const用来声明常量 const声明的常量不允许重新赋值 const声明的常量必须初始化 2. 变量的解构赋值2.0 普通赋值 示例：let a = 1;let b = 2;let c = 3;或者 let a = 1,b = 2,c = 3; 2.1 数组的解构赋值 示例：let [a,b,c] = [1,2,3]; 以逗号分隔，按照顺序一一对应。 带默认值：let [a=1,b,c] = [,2,];，不指定使用默认值，指定则使用新值。 没有带默认值，也没有指定的值为undefined。 2.2 对象的解构赋值 自定义对象解构赋值示例：let {foo,bar} = {foo: &quot;hello&quot;,bar: &quot;hi&quot;}; 以逗号分隔，按照对象名称一一对应，与顺序无关。 示例：let {sin,cos,random} = Math;，三个都会被赋值。 对象属性别名（如果有了别名，原来的名字就无效了） 示例：let {foo:abc,bar} = {bar: &quot;hello&quot;,foo: &quot;hi&quot;};，使用时应该：conslog.log(abc,bar); ！注意：给值时使用原来的名字，使用时使用新名字！ 指定别名并给默认值：let {foo:abc=&quot;hi&quot;,bar} = {bar: &quot;hello&quot;};，不指定使用默认值，指定则使用新值 没有带默认值，也没有指定的值为undefined。 2.3 字符串的解构赋值 示例：let [a,b,c,d] = &quot;hello&quot;; 将字符串分开与前面的按照顺序一一对应，多的自动截掉，少的为undefined。 获取字符串长度(length属性)： 用对象的方法：let {length} = &#39;hello&#39;; console.log(length); 或者：console.log(&#39;hello&#39;.length);]]></content>
      <categories>
        <category>前端</category>
        <category>ECMAScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之Node基本操作]]></title>
    <url>%2F2019%2F10%2F30%2FF-02-Node%E4%B9%8BNode-js%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 关于js的基础问题 1、javascript本质上是什么？就是一门编程语言，解释执行的。 2、浏览器的内核包括两部分核心：1、DOM渲染引擎；2、js解析器（js引擎） 3、js运行在浏览器中的内核中的js引擎内部。 4、是否js只能运行在浏览器中？不是的。 5、实现动态网站的技术：java php .net python nodejs……。 6、基于Node.js和第三方工具electron可以开发桌面应用程序。 7、REPL read-eval-print-loop 读取代码-执行-打印结果-循环这个过程。 8、在REPL环境中，_表示最后一次执行结果; .exit 可以退出REPL环境。 2. Global(全局成员)概述 node API: https://nodejs.org/dist/latest-v12.x/docs/api/ Global地址：https://nodejs.org/dist/latest-v12.x/docs/api/globals.html 2.1 普通的一些API2.1.1 文件路径 __filename：包含文件名称的全路径 例如：console.log(__filename); __dirname：文件的路径（不包含文件名称） 例如：console.log(__dirname); 2.1.2 定时函数 定时函数，用法与浏览器中的定时函数类似 2.1.3 访问全局成员 在Node.js中没有window对象，但是有一个类似的对象global，访问全局成员的时候可以省略global&gt; 例如：global.console.log(123456); 2.1.4 process process.argv：argv是一个数组，默认情况下，前两项数据分别是：Node.js环境的路径；当前执行的js文件的全路径 从第三个参数开始表示命令行参数 process.arch：当前系统的架构（64位或者32位） 2.1.5 核心的API会在下面内容中详细记录 node.js核心 3 模块化开发3.1 模块化相关介绍 1.传统非模式化开发的缺点： 命名冲突 文件依赖 2.前端标准的模块化规范： AMD - requirejs【国外的】 CMD - seajs【淘宝的】 文件加载：从服务器经过网络传输到浏览器端，代码才能执行。前端的文件加载一般是异步的。 3.服务器端的模块化规范： CommonJS - Node.js就是它的一个实现 文件加载：只需要从磁盘加载到内存中。所以服务端的文件加载是同步的。 4.模块化的相关规则： 如何定义模块：一个js文件就是一个模块，模块内的成员都是相互独立的 模块成员的导出和引入(下面详细记录) 3.2 服务器端模块化3.2.1 引入模块：require() 使用1：var module = require(&#39;./文件名&#39;);：代表引入同级目录里的一个件，并定义了一个变量接收返回值。 使用2：require(&#39;./文件名&#39;);，不接收返回值(global导出需要使用这种方式入) 模块文件的加载实际上会被缓存，文件多次引入，不会重新加载，用的是第一次缓的内容。 模块文件引入时，js文件的后缀可以省略。 模块文件后缀三种情况：.js、.json、.node(比较少) 不加文件后缀时三种模块加载的优先级：.js –&gt; .json –&gt; .node 3.2.2 导出模块：exports/module 1.exports：exports.sum = sum;将可以让别的模块直接使用的变量用export修饰 引入时：首先这样引入模块var module = require(&#39;./文件名&#39;)，再这样引入模块成员var ret = module.sum()。 2.module：module.exports.sum; 引入时：首先这样引入模块var module = require(&#39;./文件名&#39;)，再这样引入模块成员var ret = module(); 3.global：global.flag = flag;。!很少会用 引入时：首先这样引入模块require(&#39;./文件名&#39;);，再这样引入模块成员console.log(global.flag); 模块成员的导出最终以module.exports为准 如果要导出单个的成员或者比较少的成员，一般我们使用exports导出； 如果要导出的成员比较多，一般我们使用module.exports的方式 这两种方式不能同时使用 exports与module的关系： module.exports = exports = {}; 3.2.3 模块文件的后缀 三种情况：.js .json .node 加载优先级(不加文件后缀时的优先级)：.js -&gt; .json -&gt; .node 3.2.4 模块分类 自定义模块 系统核心模块 fs 文件操作 http 网络操作 path 路径操作 querystring 查询参数解析 url、url解析 … node API: https://nodejs.org/dist/latest-v12.x/docs/api/ 4. node.js核心14.1 Buffer4.1.1 Buffer(缓冲区) 从结构上看Buffer非常像一个数组，Buffer是用来存储二进制数据的,它的元素(示)为16进制的两位数。 实际上一个元素就表示内存中的一个字节。 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。 也就是可以直接通过Buffer来创建内存中的空间。 4.1.2 Buffer的操作 使用Buffer保存字符串 let str = &quot;你好 wcy&quot;; let buf = Buffer.from(str , &quot;utf-8&quot;); 创建指定大小的Buffer对象 let buf = Buffer.alloc(1024*8); 4.1.3 Buffer的方法详细使用建议查看文档 构造方法： Buffer.from(字符串)：将一个字符串中内容保存到一个buffer中 Buffer.alloc(size)：创建一个指定大小的buffer对象 Buffer.allocUnsafe(size)：创建一个指定大小的buffer对象，可以包含敏感据 静态方法： Buffer.concat()：拼接缓冲区(将一组Buffer对象合并为一个Buffer对象) Buffer.isEncoding(‘utf8’)：判断是否是某种编码 Buffer.isBuffer()：判断是否为Buffer对象 Buffer.byteLength()：获取buf的长度(英文),返回指定编码的字节长度，默认utf86 实例方法： buf.toString()： 将buffer转换为一个字符串 buf.write()； 向缓冲区中写入字符串(可以指定起始位置和写入个数) buf.fill()：将指定值填入到缓冲区的指定位置 buf.copy()：复制缓冲区 buf.slice()： 对缓冲区切片 toJson() 把buf对象转成json形式的字符串 toJSON方法不需要显式调用，当JSON.stringify方法调用的时候会自动调用toJSON方法 const json = JSON.stringify(buf); 4.2 路径操作首先引入path模块：const path = require(&#39;path); path.basename()：获取路径的最后一部分(文件名)) console.log(path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;)); —&gt; quux.html path.dirname / ：获取路径 console.log(path.dirname(&#39;/abc/qqq/www/abc&#39;)); —&gt; /abc/qqq/www console.log(__dirname); —&gt; 当前文件所在的文件夹(此路径不包含文件名) path.extname()：获取扩展名称 console.log(path.extname(&#39;index.html&#39;)); —&gt; .html 路径的格式化处理 path.format()：(obj-&gt;string) path.parse()：(string-&gt;obj) 代码示例：123456789101112let obj = path.parse(__dirname);console.log(obj);// &#123;// root: &apos;D:\\&apos;,// dir: &apos;D:\\fontDemo\\1.heima-demo\\05.node&apos;,// base: &apos;node1&apos;,// ext: &apos;&apos;,// name: &apos;node1&apos;// &#125;console.log(path.format(obj));// D:\fontDemo\1.heima-demo\05.node\node1 path.isAbsolute()：判断是否为绝对路径 console.log(path.isAbsolute(&#39;C:/foo/bar/...&#39;)); —&gt; true console.log(path.isAbsolute(&#39;/foo/bar/&#39;)); —&gt; true console.log(path.isAbsolute(&#39;./foo/bar/&#39;)); —&gt; false path.join()：拼接路径 （..表示上层路径；.表示当前路径）,在连接路径的时候会格式化路径 console.log(path.join(&#39;/foo&#39;,&#39;bar&#39;,&#39;baz/asdf&#39;,&#39;quux/&#39;,&#39;../../&#39;)); —&gt; \foo\bar\baz\ path.normalize()：规范化路径 console.log(path.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;)); —&gt; \foo\bar\baz\asdf path.relative()：计算相对路径 console.log(path.relative(&#39;/d/o/t/a&#39;, &#39;/d/o/i/b&#39;)); —&gt; ....\i\b path.resolve()：解析路径 console.log(path.resolve(&#39;w&#39;, &#39;s_f/png/&#39;, &#39;../gif/image.gif&#39;)); —&gt; 当前文件所在的文件夹的路径 + \w\s_f\gif\image.gif path.delimiter()：环境变量分隔符(windows中使用; linux中使用:) console.log(path.delimiter); —&gt; ; path.sep()：路径分隔符(windows是\， Linux是/) console.log(path.sep); —&gt; \ 5. node.js核心25.1 底层思想 node.js采用的异步I/O思想 基于回调函数的编码风格 5.1.1 异步I/O input/output：网络响应和请求的过程 1、文件操作 2、网络操作 5.1.2 浏览器中存在的异步操作 1、定时任务 2、事件处理 3、Ajax回调处理 js的运行时单线程的(可能会阻塞)，引入事件队列机制 5.1.3 Node.js中异步执行的任务 1、文件I/O(文件读写操作) 2、网络I/O(网络的请求响应处理) Node.js中的事件模型与浏览器中的事件模型类似：单线程+事件队列 5.2 文件系统（File System） 进行文件操作时，首先引入fs模块：const path = require(&#39;fs); 文件操作：打开文件 –&gt; 读取文件 –&gt; 写入文件 –&gt; 关闭文件5.2.1 fs模块 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给程的客户端。 在Node通过fs模块来对系统中的文件进行操作，fs模块是node中已经继承好了，需要在使用npm下载，直接引入即可 引入fs模块：var fs = require(&quot;fs&quot;); 5.2.2 同步和异步调用 fs模块中的大部分操作都提供了两种方法，同步方法和异步方法。(同步方法sync，异步方法没有sync，都需要回调函数) 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 5.2.3 查看文件状态 fs.stat()：是异步任务，在事件队列中 参数1：文件路径 参数2：回调函数（第一个参数是err，第二个参数是stat对象） 异步的返回值是不存在的：let ret = fs.stat(&#39;./data.txt&#39;) ---&gt; ret为undefined stat对象的常用方法 stat.isFile()：判断是否是文件 stat.isDirectory()：判断是否是目录 stat对象的常用属性有： atime：文件访问时间 ctime：文件的状态信息发生变化的时间（比如文件的权限） mtime：文件数据发生变化的时间 birthtime：文件创建的时间 fs.statSync()：同步操作 同步操作的返回值与stat对象的性值是一致的 5.2.4 读文件操作1(小文件) fs.readFile() 参数1：路径 参数2：编码方式(‘utf8’常用)，可有可无 参数3：回调函数（第一个参数是err，第二个参数是data数据） 没有参数2(编码方式)，获取到的data是一个Buffer实例对象。 有编码方式，获取到的data直接是字符串。 通过回调函数的返回值获取数据 fs.readFileSync() 参数与异步相同 通过返回值获取数据： let ret = fs.readFileSync(&#39;路径&#39;,&#39;utf8&#39;) ret即为获取到的数据。 5.2.5 写文件操作1(小文件) fs.writeFile() 参数1：路径 参数2：要写入的内容 参数3：字符编码 参数4：回调函数(一个参数err,用来处理异常) ！注意：覆盖式写入，写入的内容会覆盖原有的内容。 fs.writeFileSync(strpath,’tom and jerry’); 5.2.6 大文件操作(流式操作) 1、确定读取的路径 和 要写入的路径 let spath = path.join(...); let dpath = path.join(...); 2、创建读写流： 读：fs.createReadStream() let readStream = fs.createReadStream(spath); 写：fs.createWriteStream() let writeStream = fs.createWriteStream(dpath); 3、基于事件的处理方式:(网络请求的事件) readStream.on() 参数1：事件名称 —&gt; ‘data’/‘end’，这个是固定的 data事件在读取文件的时候发生。 end事件在文件读取操作结束以后发生。 参数2：事件处理函数(data事件参数chunk:一块数据，因为每次读取一块) writeStream.write() 代码示例：123readStream.on(&apos;data&apos;,(chunk)=&gt;&#123; writeStream.write(chunk);&#125;) 4、pipe方式：直接把输入流(磁盘–&gt;内存)和输出流(内存–&gt;磁盘) readStream.pipe(writeStream); —&gt; fs.createReadStream(spath).pipe(fs.createWriteStream(dpath)); 5.2.7 目录操作 1、创建目录：fs.mkdir() / fs.mkdirSync() 异步参数： 参数1：路径 参数2：目录名 参数3：回调函数(参数err) 同步参数： 参数1：路径 参数2：目录名 2、读取目录：fs.readdir() / fs.readdirSync() 异步参数： 参数1：路径 参数2：回调函数(参数1：err，参数2：files(文件列表–&gt;是一个数组，不包括当前目录和上层目录)) 通过回调函数的返回值获取数据 同步参数： 参数1：路径 通过返回值接收数据：let files = fs.readdirSync(__dirname); 3、删除目录：fs.rmdir() / fs.rmdirSync() 异步参数： 参数1：路径(要删除的目录) 参数2：回调函数(参数err) 同步参数： 参数：路径(要删除的目录) 5.2.8 打开和关闭文件 打开文件 fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) 关闭文件 fs.close(fd,callback) fs.closeSync(fd); 打开状态 r：读取文件, 文件不存在则出现异常 r+：读写文件, 文件不存在则出现异常 rs：在同步模式下打开文件用于读取 rs+：在同步模式下打开文件用于读写 w：打开文件用于写操作 , 如果不存在则创建，如果存在则截断 wx：打开文件用于写操作 , 如果 存在 则打开失败 w+：打开文件用于读写 ,如果不存在则创建 ,如果存在则截断 wx+：打开文件用于读写 , 如果 存在 则打开失败 a：打开文件用于追加 , 如果不存在则创建 ax：打开文件用于追加 , 如果路径存在则失败 a+：打开文件进行读取和追加 , 如果不存在则创建该文件 ax+：打开文件进行读取和追加 , 如果路径存在则失败]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>核心API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之终端的基本使用]]></title>
    <url>%2F2019%2F10%2F30%2FF-02-Node%E4%B9%8B%E7%BB%88%E7%AB%AF%E5%92%8C%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1. 终端的基本使用1.1 打开应用win + R —&gt; 弹出一个窗口，向里面输入下列内容。 cmd：打开DOS命令窗口 notepad：打开记事本 mspaint：打开画图 calc：打开计算机 write：打开写字板 sysdm.cpl：打开环境变量设置窗口 1.2 常用命令win + R —&gt; 弹出一个窗口，向里面输入cmd —&gt; 到想去的目录里输入下列内容。 1.2.1 关于目录 md 目录名：创建目录 ls：查看当前目录下的内容 rmdir(rd)：删除目录，目录内没有文档 rd /s/q 目录名：删除目录及目录里的内容（/s代表子目录，/q代表安静的删除【删除时不给提示】） cd ..：返回上一级目录 1.2.2 关于文件 echo on &gt; 文件名(a.text)：创建空文件 echo 要写入的内容 &gt; 文件名(a.text)：向文件中写入内容（覆盖之前的内容） echo 要写入的内容 &gt;&gt; 文件名(a.text)：向文件中追加内容 cat 文件名：查看文件内容 cat &gt; 文件名 ---&gt; 会出现一个提示符让你输入内容 ---&gt; 按ctrl + c退出：向文件中写入内容（覆盖之前的内容） cat &gt; 文件名 ---&gt; 会出现一个提示符让你输入内容 ---&gt; 按ctrl + c退出：向文件中追加内容 rm 文件名：删除文件 del 文件名：删除文件 2. node.js开发环境准备2.1 普通安装方式 官方网站：https://nodejs.org/en/ 中文官网：http://nodejs.cn/ 左边是稳定版本，右边是新特性的 2.2 多版本安装方式 1.卸载已有的Node.js。 2.下载nvm（https://github.com/coreybutler/nvm-windows）。 3.在C盘创建目录dev： 在dev目录中创建两个子目录nvm和nodejs 将nvm包解压，解压文件放入nvm中并修改nvm的配置文件。 4.修改nvm的配置文件。 右键解压后的install.cmd —&gt; 以管理员身份运行出现一个黑窗口，直接按回车 —&gt; 将配置文件另存到nvm目录下。 进行如下修改： root: D:\AllDevelop\Dev\nvm(nvm的路径) path: D:\AllDevelop\Dev\nodejs(nodejs的路径) 5.配置nvm和nodejs的环境变量 输入sysdm.cpl，打开窗口 —&gt; 高级 —&gt; 环境变量 —&gt; 系统变量 在系统变量里添加加NVM_HOME变量，值为nvm的路径 再添加NVM_SYMLINK变量，值为nodejs的路径。 6.把配置好的两个环境变量加到PATH中 %NVM_HOME% %NVM_SYMLINK% 7.cmd打开命令窗口： nvm version：查看是否安装好（出现版本号则正确） nvm：查看nvm的命令 nvm常用命令： nvm list：查看当前安装了哪些nodejs版本。 nvm install node版本号 [操作系统(不加就默认自己这个操作系统)]：安装指定版本的nodejs。 nvm install latest：安装最新版本的nodejs。 nvm use 版本号：使用指定版本的node。 8.用nvm安装nodejs环境 原本位置的nodejs文件夹变成了一个快捷方式，目标指向你所使用的那个版本的node。 9.可以使用node命令了 node -v：查看当前使用的node版本。 3. node 简介3.1 介绍 Node.js是一个能够在服务器端运行JavaScript的开放源代码、 跨平台JavaScript运行环境。 Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。 Node大部分基本模块都用JavaScript编写。 Node主要用于编写像Web服务器一样的网络应用，这和 PHP 和 Python 是类似的。 Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。 核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、 TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。 使用框架可以加速开发。常用的框架有Express.js、Socket.IO 和Connect等。Node.js的程序可以在Microsoft Windows、 Linux、Unix、Mac OS X等服务器上运行。 Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。 3.2 用途 Web服务API，比如REST 实时多人游戏 后端的Web服务，例如跨域、服务器端的请求 基于Web的应用 多客户端的通信，如即时通信 4. COMMONJS规范4.1 出现环境4.1.1 ECMAScript标准的缺陷 没有模块系统 标准库较少 没有标准接口 ！缺乏管理系统4.1.2 模块化 如果程序设计的规模达到了一定程度，则必须对其进行模块化。 模块化可以有多种形式，但至少应该提供能够将代码分割为多个源文件的机制。 CommonJS 的模块功能可以帮我们解决该问题。4.1.3 CommonJS规范 CommonJS规范的提出，主要是为了弥补当前JavaScript没有模块化标准的缺陷。 CommonJS规范为JS指定了一个美好的愿景，希望JS能够在任何地方运行。 CommonJS对模块的定义十分简单： 模块引用 、模块定义 、模块标识 4.2 模块4.2.1 模块引用 require()方法：这个方法接收模块标识，以此将一个模块引入到当前运行环境中。 模块引用的示例代码： var math = require(&#39;math&#39;); 4.2.2 模块定义 exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出的出口。 在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。 在Node中一个文件就是一个模块。 4.2.3 模块标识 模块标识其实就是模块的名字，也就是传 递给require()方法的参数，它必须是合 驼峰命名法的字符串，或者是以.、..开头的 相对路径、或者绝对路径。 模块的定义十分简单，接口也十分简洁。每个模块具有独立的空间，它们互不干扰，在引用时也干净利落。 4.2.4 node的模块实现 Node中虽然使用的是CommonJS规范，但是其自身也对规范做了一些取舍。 在Node中引入模块，需要经历如下3个步骤：路径分析 —&gt; 文件定位 —&gt; 编译执行 在Node中，模块分为三类：一类是底层由 C++编写的内建模块；一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。 4.3 包（package）4.3.1 包是什么？ 将多个模块组合为一个完整的功能，就是一个包。包实际上就是一个压缩文件，解压以后还原为目录。 CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。 4.3.2 包规范 CommonJS的包规范由 包结构 和 包描述文件 两个部分组成。 包结构：符合规范的目录，应该包含如下文件： bin- 二进制的可执行文件，一般都是一些工具包中才有 lib- js文件 doc- 文档 test- 测试代码 package.json- 包的描述文件 包描述文件：用于表达非代码相关的信息，它是一个JSON格式的文件(package.json)，位于包的根目录下，是包的重要组成部分。 package.json：它是一个json格式的文件，在它里面保存了包各种相关的信息。 package.json中的一些字段：name(包名)、version(版本)、dependencies(依赖)、main(包的主要的文件)、bin(运行的代码)4.3.3 安装/卸载包 全局安装 -g 全局安装的包位于Node.js环境的node_modules目录下，全局安装的包一般用于命令行工具。 本地安装 本地安装的包在当前目录下的node_modules里面，本地安装的包一般用于实际的开发工作。 可以用npm安装/卸载包4.3.4 自定义包 包的规范 package.json必须在包的顶层目录下 二进制文件应该在bin目录下 JavaScript代码应该在lib目录下 文档应该在doc目录下 单元测试应该在test目录下 package.json字段分析 name：包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格 description：包的简要说明 version：符合语义化版本识别规范的版本字符串 keywords：关键字数组，通常用于搜索 maintainers：维护者数组，每个元素要包含name、email（可选）、 web（可选）字段 contributors：贡献者数组，格式与maintainers相同。包的作者应 该是贡献者数组的第一个元素 bugs：提交bug的地址，可以是网站或者电子邮件地址 licenses：许可证数组，每个元素要包含type（许可证名称）和url （链接到许可证文本的- 地址）字段 repositories：仓库托管地址数组，每个元素要包含type（仓库类 型，如git）、url（仓- 库的地址）和path（相对于仓库的路径，可 选）字段 dependencies：生产环境包的依赖，一个关联数组，由包的名称和版 本号组成 devDependencies：开发环境包的依赖，一个关联数组，由包的名称和版本号组成 4.4 npm（Node Package Manager node的包管理器）4.4.1 npm是什么？ CommonJS包规范是理论，NPM是其中一种实践。 对于Node而言，NPM帮助其完成了第三 方模块的发布、安装和依赖等。借助NPM， Node与第三方模块之间形成了很好的一个生态系统。 通过npm可以对node中的包进行上传、下载、搜索等操作。 npm会在安装完node以后，自动安装。 4.4.2 npm命令 帮助说明：npm 查看npm的版本：npm -v 搜索模块包：npm search 包名 安装包： npm install 包名：在当前目录安装指定的包(本地安装) npm install -g 包名：全局安装模式安装包（一般都是一些工具） npm install -g 包名@版本号：安装包的时候指定版本 更新包：不太好用 npm update -g 包名 npm update -g 包名@latest：更新到最新版本 卸载包：npm uninstall -g 包名 删除包：npm r/remove 包名 初始化一个包： npm init npm init -y 初始化一个包以后，执行入口文件: node . npm run test 执行入口文件 添加依赖： --save：向生产环境添加依赖 --save-dev：向开发环境添加依赖 开发环境(平时开发使用的环境 —&gt; DevDependencies) 生产环境(项目部署上线之后的服务器环境 —&gt; dependencies) 从本地安装：npm install 文件路径 从镜像源安装：npm install 包名 –registry=地址 设置镜像源：npm config set registry 地址 4.5 yarn4.5.1 安装yarn 安装yarn工具：npm install -g yarn 性能优越，解决了npm存在的一些问题。(facebook的) 4.5.2 yarn命令 1、初始化包 npm init yarn init 2、安装包 npm install xxx --save yarn add xxx 3、移除包 npm uninstall xxx yarn remove xxx 4、更新包 npm update xxx yarn upgrade xxx 5、安装开发依赖的包 npm install xxx --save-dev yarn add xxx --dev 6、全局安装 npm install -g xxx yarn global add xxx 7、设置下载镜像的地址 npm config set registry url yarn config set registry url 8、安装所有依赖 npm install yarn install 9、执行包 npm run yarn run 5. nrm (镜像源的管理)5.1 为什么使用nrm5.1.1 为什么使用nrm npm下载包的地址：registry.npmjs.org 是一个国外的地址，为了提高安装包的体验(让速度更快)，所以使用nrm这个工具 注意：nrm只是单纯地提供了几个下载包的路径，并能够让我们在这几个地址之间很方便的切换。 5.1.2 nrm的安装 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意：在nrm中cnpm只是一个地址。装包的时候使用的依然是npm]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>node环境</tag>
        <tag>终端</tag>
        <tag>包</tag>
        <tag>npm</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS预处理器之Less]]></title>
    <url>%2F2019%2F10%2F29%2FB-16-CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E4%B9%8BLess%2F</url>
    <content type="text"><![CDATA[1.Less初识1.1 less介绍 less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。 LESS 既可以在 客户端 上运行 ，也可以借助Node.js在服务端运行。 less的中文官网：http://lesscss.cn/ bootstrap中less教程：http://www.bootcss.com/p/lesscss/ 1.2 使用 第一种：运行时编译 在body标签后面引入less文件：&lt;script src=&quot;less/less.min.js&quot;&gt;&lt;/script&gt; 修改包裹less的style标签的类型：&lt;style type=&quot;text/less&quot;&gt;less代码&lt;/style&gt; 这种方法不好，我们一般希望的是预编译！ 第二种：使用考拉编译less（koala 官网:www.koala-app.com） 使用外部样式表引入css文件：&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/02.css&quot;/&gt; 打开考拉，把css文件拖进去(拖文件的目录而不是文件)，然后点击刷新即可。 这种方法是线下编译，运行与less没有关系。 2.Less语法2.1 less中的注释 以//开头的注释，不会被编译到css文件中。 以/**/包裹的注释会被编译到css文件中。 2.2 less中的变量 使用@来申明一个变量，例如：@pink：pink; 1.作为普通属性值只来使用：直接使用@pink 2.作为选择器和属性名：@{selector的值}的形式 3.作为URL：@{url} 变量的延迟加载： less里面的变量都是块级作用域，一个大括号代表一个作用域。 less中变量的延时加载：就是它会等作用域中所有的值都加载完毕，再去给变量赋值。 例如：由于@var: 2和@var: 3是比three: @var优先加载的，所以最终@var的值是3，然后再赋值给three中的变量。12345678910111213141516171819&lt;!-- less --&gt;@var: 0;.class &#123;@var: 1; .brass &#123; @var: 2; three: @var;//3 @var: 3; &#125;one: @var; &#125;&lt;!-- less编译结果(css) --&gt;.class &#123; one: 1;&#125;.class .brass &#123; three: 3;&#125; 2.3 less中的嵌套规则 基本嵌套规则(父子嵌套)：子在父内。 &amp;的使用(平级嵌套)：例如要用伪类时，使用&amp;就不会有空格。 2.4 less中的混合(minxin) 一般使用时会在css文件夹里放一个mixin文件夹，专门用来放混合。用@import &quot;mixin/juzhong.less&quot;; 混合就是将一系列属性从一个规则集引入到另一个规则集的方式。 1.普通混合 定义混合：.混合名{一些声明}，定义一个混合以点开头。 调用混合：混合名;。 缺点：会使原生的css文件变得很大。 2.不带输出的混合 定义混合：.混合名(){一些声明}，在混合名后面加上小括号，在css中就不会输出混合自己了。 调用混合：混合名;。 3.带参数的混合 定义混合：.混合名(形参1,形参2,...){一些包含变量的声明} 调用混合：混合名(实参1,实参2,...);，带参混合调用时一定要传入实参，否则报错。 4.带参数并且有默认值的混合 定义混合：.混合名(形参1:默认值,形参2:默认值,...){一些包含变量的声明} 调用混合：调用混合：混合名()/混合名(实参1,实参2,...);，可以传入实参(使用传入的实参)，也可以不传入(使用默认值)。 5.带多个参数的混合 略。见4 6.命名参数 调用混合时使用的：混合名(形参n: 实参);，给指定形参传入实参。 7.匹配模式(重点) 自定义三角形。 @import &quot;./triangle.less&quot;;，导入 8.arguments变量 arguments是一个实参列表，伪数组（具有length属性的对象）。 代码示例：123456.border(@w,@style,@c)&#123; border: @arguments;&#125;#wrap .sjx&#123; .border(1px,solid,black)&#125; 2.5 less运算 在less中可以进行加减乘除的运算 在less里面计算的双方有一方带单位即可。 代码示例： 1234@rem:100rem;#wrap .sjx&#123;width:(100 + @rem)&#125; 2.6 less避免编译 语法：~&quot;不需要编译的代码&quot;。 代码示例： 1234*&#123; margin: 100 * 10px; padding: ~&quot;cacl(100px + 100)&quot;;&#125; 这里cacl()是js中计算的。 2.7 less继承 语法1： #wrap{.inner{&amp;:extend(.juzhong all);}}，这种方法推荐使用，all就是继承居中类的所有状态(包括hover等状态)。 #wrap{.inner:extend(.juzhong)}，这种方法不推荐使用。 引入外部css文件（引入混合）。 继承与混合的区别： 继承可以做到混合做不到的功能（比如css选择器中的组合选择器[,]，因为混合的本质是复制粘贴）。 继承的性能比混合高，灵活度比混合低。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS预处理器</category>
      </categories>
      <tags>
        <tag>预处理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之布局扩展]]></title>
    <url>%2F2019%2F10%2F28%2FB-15-CSS3%E4%B9%8B%E5%B8%83%E5%B1%80%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[CSS3之变形]]></title>
    <url>%2F2019%2F10%2F28%2FB-14-CSS3%E4%B9%8B%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[1. 2d变形 transform 属性允许你修改CSS视觉格式模型的坐标空间. transform 属性 , 只对 block 级元素(一般都是div)生效！ 变形与过渡一般一起使用。 1.1 ！旋转（rotate） transform:rotate(角度); 正值:顺时针旋转 rotate(360deg) 负值:逆时针旋转 rotate(-360deg) 只能设单值。正数表示顺时针旋转，负数表示逆时针旋转。 1.2 ！平移（translate） 带单位！ X方向平移:transform: translateX(tx) Y方向平移:transform: translateY(ty) 二维平移：transform: translate(tx[, ty])； 如果ty没有指定，它的值默认为0。 可设单值，也可设双值。 translateX、 translateY分开单独设置的话只有靠后面的一个会生效。 正数表示XY轴正向位移，负数为反向位移。设单值表示只X轴位移，Y轴坐标不变。例如transform: translate(100px);等价于transform: translate(100px,0); 1.3倾斜/斜切（skew） transform:skewX(45deg); X方向倾斜:transform: skewX(angle) skewX(45deg):参数值以deg为单位，代表与y轴之间的角度。 Y方向倾斜:transform: skewY(angle) skewY(45deg):参数值以deg为单位，代表与x轴之间的角度。 二维倾斜:transform: skew(ax[, ay]); 如果ay未提供，在Y轴上没有倾斜。 skew(45deg,15deg):参数值以deg为单位。 第一个参数代表与y轴之间的角度。 第二个参数代表与x轴之间的角度。 单值时表示只X轴扭曲，Y轴不变，如transform: skew(30deg);等价于transform: skew(30deg, 0);。 考虑到可读性，不推荐用单值，应该用transform: skewX(30deg);。skewY表示只Y轴扭曲，X轴不变 。 正值:拉正斜杠方向的两个角 负值:拉反斜杠方向的两个角 1.4 缩放（scale） transform:scale(2); X方向缩放:transform: scaleX(sx); Y方向缩放:transform: scaleY(sy); 二维缩放 :transform: scale(sx[, sy]); (如果sy 未指定，默认认为和sx的值相同) 。 要缩小设0.01～0.99之间的值，要放大设超过1的值。 例如： 缩小一倍可以transform: scale(.5); 放大一倍可以transform: scale(2); 只想X轴缩放，可以用scaleX(.5)相当于scale(.5, 1)。 只想Y轴缩放，可以用scaleY(.5)相当于scale(1, .5)。 正值:缩放的程度。 负值:不推荐使用（有旋转效果）。 单值时表示只X轴,Y轴上缩放力度一样，如transform: scale(2);等价于transform: scale(2,2);。 1.5 基点的变换 transform-origin CSS属性更改一个元素变形的基点。 基点的变换对平移没有影响（因为位移参照的是自己原来的位置）！ transform-origin属性可以使用一个，两个或三个值来指定，其中每个值都表示一个偏移量。 没有明确定义的偏移将重置为其对应的初始值。 取值： 关键字：left、center、right、top、bottom 百分比：自身尺寸的百分比。 数值 1.6 矩阵（matrix）（了解即可） 在 2D变换 中，矩阵变换函数 matrix() 接受 6个值，语法形式：transform: matrix(a, b, c, d, e, f); ，这相当于，对元素应用一个变换矩阵。 旋转 对某一元素应用旋转变换 rotate(θ)，等价于矩阵变换函数 matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)。 平移 对某一元素应用旋转变换 translate(X, Y)，等价于使用矩阵变换函数 matrix(1, 0, 0, 1, X, Y)。 倾斜 对某一元素应用倾斜变换 skew(α, β)，等价于使用矩阵变换函数matrix(1, tanβ, tanα,1, 0, 0)。 缩放 对某一元素应用缩放变换 scale(scaleX, scaleY)，等价于使用矩阵变换函数 matrix(scaleX, 0, 0, scaleY, 0, 0)。 1.7 ！变换组合 变换组合的顺序不同，变换结果不同（因为底层原理是矩阵，矩阵的运算是不可逆的）。 变换组合时,底层是矩阵，计算方向是从右往左进行计算的。 移动/缩放/旋转/斜切 —&gt; 组合 顺序不同，结果不同 执行顺序从右往左 理解： 方便理解可以按照从左往右的顺序进行变换。 缩放/旋转时坐标系也跟着缩放。 2. 3d变形 在浏览器中，X轴是从左到右，Y轴是从上到下，Z轴是从里到外。 3d变形中有缩放、平移、旋转，没有倾斜/斜切（因为没有意义）。 3d场景的两个要点： 近大远小：由景深实现。 层次感：由transfrom-style实现。 2.1 3D旋转 CSS3中的3D旋转主要包括四个功能函数 rotateX(angle) rotateY(angle) rotateZ(angle)等价于rotate(angle) rotate3d(x,y,z,angle) x, y, z分别接受一个数值(number),用来计算矢量方向(direction vector)，矢量方向是三维空间中的一条线, 从坐标系原点到x, y, z值确定的那个点，元素围绕这条线旋转angle指定的值。 怎么判断绕着谁转？绕着圆心到指定点所形成的射线进行旋转。 2.2 3D平移 transform: translateZ(length)是3D Transformation特有的，其他两个2D中就有。 translateZ: 它不能是 百分比 值，那样的移动是没有意义的。 例如：transform: translate3d(translateX[50%],translateY[50%],translateZ[值]);中translateZ 也不能是百分比值，那样的没有变形了。 2.3 3D缩放 transform: scale3d(scaleX,scaleY,scaleZ); 单独使用scaleZ()是没有意义的，使用scale3d时使用的。 如果只设置scaleZ(number)，你会发现元素并没有被扩大或压缩，scaleZ(number)需要和translateZ(length)配合使用，number乘以length得到的值，是元素沿Z轴移动的距离，从而使得感觉被扩大或压缩 。 例如： transform: translateZ(100px) scaleZ(2);往前走100px。 transform: scaleZ(2) translateZ(100px);往前走200px，相当于transform: translateZ(200px); 2.4景深（perspective） 景深介绍： 简单理解：景深就是我们的肉眼距离显示器的距离，景深越大，元素离我们越远，效果就不好。在CSS3中，perspective用于激活一个3D空间，属性值就是景深大小（默认none无景深）。 应用景深的元素称为“舞台元素”，舞台元素的所有后代元素都会受影响，（如果后代元素中也添加了perspective属性，效果会叠加而不是覆盖）。景深是设置给包裹元素的，作用给包裹里面的设置了3d变换的子元素的。 子元素的变换（X/Y）为正值：按着头/右手往里推，提着脚/左手往外拉。 景深: （英语：Depth of field, DOF）景深是指相机对焦点前后相对清晰的成像范围。在光学中，尤其是录影或是摄影，是一个描述在空间中，可以清楚成像的距离范围。虽然透镜只能够将光聚 到某一固定的距离，远离此点则会逐渐模糊，但是在某一段特定的距离内，影像模糊的程度是肉眼无法察觉的，这段距离称之为景深。当焦点设在超焦距处时，景深 会从超焦距的一半延伸到无限远，对一个固定的光圈值来说，这是最大的景深。（了解即可） 景深的两种方式： transform: perspective(depth);这样写是作用于自身的，不是作用于子元素。 transform里面有一个perspective(depth)函数。 此时应该跟变换组合一起使用：transform: perspective(depth) rotateX(度数);）。 使用perspective()函数，那么他必须被放置在transform属性的首位，如果放在其他函数之后，则会被忽略。 depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。1000px被认为是个正常值 一般不会使用！ perspective: depth; 同perspective()函数一样，depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。 他们唯一的区别是，perspective属性是被用于元素的后代元素，而不是元素本身；就是说，为某个元素设置perspective属性后，是对这个元素的子元素起作用，而不是这个元素本身。 与灭点的关系(原理)： 景深越大，灭点越远，元素变形越小； 景深越小，灭点越近，元素变形越大。 作用： 让3d场景有近大远小的效果（我们肉眼距离屏幕的距离）。 是一个不可继承的属性，但是作用于后代元素 景深基点：perspective-origin 控制视角的位置，是由两个属性控制的。 默认值：perspective-origin:50% 50%; 这个属性来设置你在X, Y轴坐标确定的那个点来看这个元素，Z轴是被perspective属性设置的。 同perspective属性，也是设置在父元素上，对后代元素起作用。 景深叠加： 爷父子中，如果爷父都设置的有景深，作用到子身上以后不是父身上的景深了，而且不同的浏览器叠加计算的方式也不同。 所以要尽量避免景深叠加！ 2.5 灭点 指的是立体图形各条边的延伸线所产生的相交点。透视点的消失点。 一点透视、二点透视、多点透视、成角透视 2.6 transform-style 这个属性指定了子元素如何在空间中展示，可以营造有层级的3d舞台。 只有两个属性值：flat（默认）和preserve-3d flat 表示所有子元素在2D平面呈现； preserve-3d 表示所有子元素在3D平面呈现。 是一个不可继承属性，它作用于子元素。 如果被扁平化，则子元素不会独立的存在于三维空间。 因为该属性不会被（自动）继承，所以必须为元素所有非后代节点设置该属性。 景深负责近大远小的感觉，transform-style则负责层次感。 2.7 backface-visibility backface-visibility属性用来设置，是否显示元素的背面，默认是显示的。 backface-visibility: keyword; keyword有两个值，hidden和visible，默认值是visible。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>变形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之动画]]></title>
    <url>%2F2019%2F10%2F28%2FB-13-CSS3%E4%B9%8B%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[1. 介绍 人类具有视觉暂留的特性，人的眼睛在看到一幅画或一个物体后，在0.34秒内不会消失。 动画原理：通过把人物的表情、动作、变化等分解后画成许多动作瞬间的画幅，利用视觉暂留的原理，在一幅画还没有消失前，播放下一幅画。就会给人造成一种流畅的视觉变化效果。 css3动画：使元素从一种样式逐渐变化为另一种样式的效果 animation属性是一个简写属性形式: （可以用来描述可动画的属性） 可动画属性的列表：https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties 简写属性animation: 123456789animation： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-fill-mode animation-play-state 在每个动画定义中，顺序很重要：可以被解析为 的第一个值被分配给animation-duration, 第二个分配给 animation-delay。 2.使用 2.2、2.3、2.4、2.6、2.7 是动画内的属性；2.5、2.8是动画外的属性 2.1 关键帧（@keyframes） 整个关键帧是作用于动画帧的 语法： 12345 @keyframes animiationName&#123; keyframes-selector&#123; css-style; &#125;&#125; animiationName:必写项，定义动画的名称。 keyframes-selector：必写项，动画持续时间的百分比。 from：0% to：100% css-style：css声明 例如： 123456789101112131415161718// ！这里的百分比代表的是时间点 @keyframes move&#123; 0%&#123; transform: translateY(-100px); &#125; 25%&#123; transform: translateY(-90px); &#125; 50%&#123; transform: translateY(0px); &#125; 75%&#123; transform: translateY(90px); &#125; 100%&#123; transform: translateY(100px); &#125; &#125; animation-timing-function作用于一个关键帧周期每个阶段。使用step会少走一步 关键帧代表的是整个动画周期。 2.2 animation-name 关键帧的名字，与transition-property(产生过渡动画的属性)有区别。 animation-name属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 值: none：特殊关键字，表示无关键帧。 keyframename：标识动画的字符串。 2.3 animation-duration animation-duration属性指定一个动画周期的时长。 默认值为0s，表示无动画。 值： 一个动画周期的时长，单位为秒(s)或者毫秒(ms)，无单位值无效。 注意：负值无效，浏览器会忽略该声明，但是一些早期的带前缀的声明会将负值当作0s 2.4 animation-timing-function animation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。 对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期，即从关键帧开始，到关键帧结束。 动画的默认效果：由慢变快再变慢 linear：线性过渡，等同于贝塞尔曲线（0,0,1,1） ease：平滑过渡，等同于贝塞尔曲线（0.25,0.1,0.25,1.0） ease-in：由慢到快，等同于贝塞尔曲线（0.42,0,1,1） ease-out：由快到慢，等同于贝塞尔曲线（0,0,0.58,1） ease-in-out：由慢到快再到慢，等同于贝塞尔曲线（0.42,0,0.58,1） cubic-bezier(1,1,2,3) steps(n,[start|end]) 传入一到两个参数，第一个参数意思是把动画分成 n 等分，然后动画就会平均地运行。 第二个参数 start 表示从动画的开头开始运行，相反，end 就表示从动画的结尾开始运行， 默认值为 end。 2.5 animation-delay 定义动画开始前等待的时间,以秒或毫秒计(属于动画外的范畴)。 值: 从动画样式应用到元素上到元素开始执行动画的时间差。 可用单位为秒(s)和毫秒(ms)。 如果未设置单位，定义无效！ 2.6 animation-iteration-count 定义了动画执行的次数（属于动画内的范畴），重复的是关键帧！ 只作用于动画内的属性，对animation-delay无效(不起作用)! 值 infinite：无限循环播放动画。 &lt;number&gt;： 动画播放的次数不可为负值。 2.7 animation-direction 定义了动画执行的方向。 值： normal：每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，这是默认值。 alternate：动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向。 比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭代。 reverse：反向运行动画，每周期结束动画由尾到头运行。 ！反转的是关键帧和animation-timing-function。 alternate-reverse：反向交替， 反向开始交替。 2.8 animation-fill-mode 属于动画外的范畴，定义动画在动画外的状态。 用来控制元素在动画外（from之前，to之后）的状态 值： animation-fill-mode: none; animation-fill-mode: backwards; from之前的状态与from保持一致（动画开始时从from开始的，延时也是在from位置开始的，动画结束后回到原来位置） animation-fill-mode: forwards; to之后的状态与to保持一致（动画结束后停留在结束时的位置） animation-fill-mode: both; 延时从from位置开始，结束时停留在结束时的位置。 2.9 animation-play-state 定义了动画执行的运行和暂停 值： running：当前动画正在运行（默认值）。 paused：当前动画以被停止。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之过渡]]></title>
    <url>%2F2019%2F10%2F28%2FB-12-CSS3%E4%B9%8B%E8%BF%87%E6%B8%A1%2F</url>
    <content type="text"><![CDATA[1. transition介绍1.1 注意！ ！过渡在CSS3中比较重要。 并不是所有的属性都有过渡。 查看地址：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties 元素先有变化（在指定情况下发生变化时）才会过渡。 1.2 概述 众所周知，css效率极高，其变化的过程往往都是在一瞬间完成，速度极快。 CSS transition 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义。 1.3 简写属性transition transition是一个简写属性，用于 transition-property,transition-duration,transition-timing-function, 和transition-delay。 CSS过渡由简写属性 transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间 。 默认值： transition-delay: 0s transition-duration: 0s transition-property: all transition-timing-function: ease ！注意 在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay。 只写一个时间，会给周期；延时会使用默认值（不延时）。 给多个属性设置不同的过渡周期/延时：每个属性前面写一个/两个时间（其它的使用默认值），前一个属性与后一个属性之间用逗号隔开。 推荐抒写顺序：transition: 过渡时间 过渡样式 过渡形式 延迟时间 [，过渡时间 过渡样式 过渡形式 延迟时间] 兼容性 transition 可以不用厂商前缀，不过鉴于标准刚刚稳定，对于基于 Webkit的浏览器仍然需要厂商前缀。如果想兼容旧版本的浏览器那么也需要厂商前缀（例如Firefox 15 及之前版本, Opera 12 及之前版本)。 2.使用2.1 transition-property 指定应用过渡属性的名称，指定多个过渡属性时不同属性用逗号隔开。 默认值：all，表示所有可被动画的属性都表现出过渡动画。 可以指定多个 property 。 属性值： none：没有过渡动画。 all：所有可被动画的属性都表现出过渡动画。 IDENT：属性名称 （可以指定多个）。 2.2 transition-duration 属性以秒或毫秒为单位指定过渡动画所需的时间，不同属性不同时间时用逗号隔开。 默认值：0s ，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。 如果指定的时长个数小于属性个数，那么时长列表会重复。 如果时长列表更长，那么该列表会被裁减。 两种情况下，属性列表都保持不变。 属性值 以毫秒或秒为单位的数值 类型。 表示过渡属性从旧的值转变到新的值所需要的时间。 如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。 ！一定要加单位(不能写0 一定要写0s 1s,0s,1s)！ 2.3 transition-timing-function CSS属性受到 transition的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。 实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 默认值：ease 可以规定多个timing function,通过使用 transition-property属性，可以根据主列表(transition property的列表)给每个CSS属性应用相应的timing function。 如果timing function的个数比主列表中数量少，缺少的值被设置为初始值（ease）。 如果timing function比主列表要多，timing function函数列表会被截断至合适的大小。这两种情况下声明的CSS属性都是有效的。 属性值： 1、ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)。 2、linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)。 3、ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)。 4、ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0)。 5、ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)。 6、cubic-bezier： 贝塞尔曲线（https://cubic-bezier.com/#.17,.67,.83,.67） 7、是跳动着变化的。 step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(,[,[start|end]]?)– 第一个参数：必须为正整数，指定函数的步数– 第二个参数：指定每一步的值发生变化的时间点（默认值end） 2.4 transition-delay transition-delay属性规定了在过渡效果开始作用之前需要等待的时间，不同属性延时不同时间时用逗号隔开。 默认值：0s 可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性。 如果指定的时长个数小于属性个数，那么时长列表会重复。 如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变 属性值：值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。 取值为正时会延迟一段时间来响应过渡效果。 取值为负时会导致过渡立即开始。 2.5 当属性值的列表长度不一致时 transition-property: background,width,height; transition-duration: 3s,2s; transition-delay:3s,2s; transition-timing-function:linear; transition-property: background,width,height; transition-duration: 3s,2s,3s; transition-delay:3s,2s,3s; transition-timing-function:linear,ease,ease; ！超出的情况下是会被全部截掉的！ ！不够的时候，关于时间的会重复列表，transition-timing-function的时候使用的是默认值(ease)。 2.6 检测过渡是否完成 当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是webkitTransitionEnd。 每一个拥有过渡的属性在其完成过渡时都会触发一次transitionend事件。 在transition完成前设置 display: none，事件同样不会被触发。 详细代码： 1234567window.onload=function()&#123; var testNode = document.querySelector(&quot;#test&quot;); //dom2事件 testNode.addEventListener(&quot;transitionend&quot;,function()&#123; alert(&quot;over&quot;) &#125;)&#125; 3. 过渡的天坑3.1 坑1 此坑是由异步和css的快速解析造成的(浏览器的渲染机制造成的)。 如下一段代码： 1234567891011121314151617181920212223242526272829body&#123; width: 60%; height: 60%; border: 1px solid; margin: 100px auto 0;&#125;#test&#123; width: 100px; height: 100px; background: pink; text-align: center; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto; transition-property: width; transition-duration: 2s; transition-timing-function: linear;&#125;body:hover #test&#123; transition-property: height; width: 200px; height: 200px;&#125; 上述代码中的注意点（分析）： 鼠标移入body时，width会瞬间变成200px(因为来不及过渡，过渡就变成了height)，height会发生过渡。 鼠标移除body时，widyh会发生过渡(从200px到100px的过渡),而height不会再发生过渡（因为body没有处于hover状态）。 3.1 坑2 此坑与解析有关 ！transition在元素首次渲染还没有结束的情况下是不会被触发的。 如下一段代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 body&#123; width: 60%; height: 60%; border: 1px solid; margin: 100px auto 0; &#125; #test&#123; width: 100px; height: 100px; background: pink; text-align: center; position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto; transition-property: width; transition-duration: 2s; transition-timing-function: linear; &#125; // 在body标签后加此内容，过渡是不会触发的。 &lt;script type=&quot;text/javascript&quot;&gt; var test = document.querySelector(&quot;#test&quot;); test.style.width=&quot;300px&quot;;&lt;/script&gt; // 在body标签后的script标签中加此内容，过渡会触发。 window.onload=function()&#123; setTimeout(function()&#123; var test = document.querySelector(&quot;#test&quot;); test.style.width=&quot;300px&quot;; &#125;,3000) &#125; // 在body标签后的script标签中加此内容，过渡不会触发。 window.onload=function()&#123; var test = document.querySelector(&quot;#test&quot;); test.style.width=&quot;300px&quot;; test.style.width=&quot;100px&quot;; &#125; // 在body标签后的script标签中加此内容，过渡不会触发。 window.onload=function()&#123; var test = document.createElement(&quot;div&quot;); test.id=&quot;test&quot;; document.documentElement.appendChild(test); setTimeout(function()&#123; test.style.width=&quot;300px&quot;; &#125;,2000) &#125; 上述代码中的注意点（分析）： 第一段代码不会产生过渡 分析：因为这两行代码是同步代码，解析时就会执行(alert等只是会阻塞)，此时页面并没有渲染完毕，过渡在页面首次渲染之前(实际上只是在初始化)，所以不会发生。 第二段代码会产生过渡 分析：因为这段代码是异步代码（单独的window.onload或者是单独的定时器也可以），解析时页面已经渲染完毕. 第三段代码不会产生过渡 分析：因为宽度没有改变（上面的样式直接被下面的样式覆盖）。 第四段代码不会产生过渡 分析：因为是新加进去的节点，所以过渡时页面并没有渲染完毕，所以不会发生过渡。（如果把过渡的代码放入定时器中过渡就可以发生了）]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>过渡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB之基础]]></title>
    <url>%2F2019%2F10%2F25%2FF-01-MongoDB%E4%B9%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. MongoDB简介1.1 数据库（Database） 概述： 数据库是按照数据结构来组织、存储和管理数据的仓库。 程序都是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行中的数据都会丢失。所以就需 要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性。 数据库就是数据持久化的最佳选择。 数据库就是存储数据的仓库。 分类： 关系型数据库 – MySQL、Oracle、DB2、SQL Server 、… – 关系数据库中全都是表。 非关系型数据库 – MongoDB、Redis 、…) – 键值对数据库 – 文档数据库MongoDB 1.2 MongoDB 简介 MongoDB是为快速开发互联网Web应用 而设计的数据库系统。 MongoDB的设计目标是极简、灵活、作为Web应用栈的一部分。 MongoDB的数据模型是面向文档的，所谓文档是一种类似于JSON的结构，简单理解 MongoDB这个数据库中存的是各种各样的 JSON。（BSON） 下载 官网：https://www.mongodb.com 下载地址：https://www.mongodb.org/dl/win32/ MongoDB的版本偶数版本为稳定版，奇数 版本为开发版。 MongoDB对于32位系统支持不佳，所以 3.2版本以后没有再对32位系统的支持。 2. MongoDB基本操作2.1 介绍 MongoDB是一个NoSQL的数据库。 MongoDB是一款文档型数据库。 数据库指的就是一个存储数据的仓库，数据库可以使我们完成对数据的持久化的操作。 MongoDB数据库中存储的数据的基本单位就是文档，MongoDB中存储的就是文档，所谓文档其实就是一个“JSON”。 MongoDB中的“JSON”我们称为BSON，比普通的JSON的功能要更加的强大。 MongoDB数据库使用的是JavaScript进行操作的，在MongoDB含有一个对ES标准实现的引擎，在MongoDB中所有ES中的语法中都可以使用。 2.2 MongoDB的基本的指令 启动服务器：mongod --dbpath 路径 --port 端口号 启动客户端：mongo 2.3 MongoDB的CRUD的操作 基本操作 use 数据库：进入指定的数据库 show dbs：显示所有的数据库 show collections：显示数据库中所有的集合 db： 显示当前所在的数据库 向数据库中插入文档(这里collection指的是集合名) db.collection.insert() insert()可以向集合中插入一个或多个文档。 当向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id，该属性用来作为文档的唯一标识。 _id可以自己指定，如果指定了数据库就不会在添加了。如果指定_id ，也必须确保它的唯一性。 示例： 1234567891011&lt;!-- 用insert()插入一个数据 --&gt;db.students.insert(&#123;name:&quot;wcy&quot;,age:20,gender:&quot;男&quot;&#125;);&lt;!-- 用insert()插入多个数据 --&gt;db.students.insert([ &#123;name:&quot;way&quot;,age:19,gender:&quot;男&quot;&#125;, &#123;name:&quot;wby&quot;,age:20,gender:&quot;女&quot;&#125;, &#123;name:&quot;wcy&quot;,age:21,gender:&quot;女&quot;&#125;]); db.collection.insertOne() 向集合中插入一个文档。 db.collection.insertMany() 向集合中插入多个文档。 查询数据库中的文档(这里collection指的是集合名) db.collection.find() 可以根据指定条件从集合中查询所有符合条件的文档。 find({}) 表示查询集合中所有的文档 返回的是一个数组。 示例： 123&lt;!-- 用find()查询数据 --&gt;db.students.find(&#123;age:19 , name:&quot;way&quot;&#125;);db.students.find(&#123;age:21&#125;); db.collection.findOne() 查询第一个符合条件的文档 返回的是一个对象 db.collection.find().count() 查询符合条件的文档的数量 修改数据库中的文档 db.collection.update(查询条件,新对象) 可以修改、替换集合中的一个或多个文档 update()默认情况下会使用新对象来替换旧的对象 update()默认只会修改一个 如果需要修改指定的属性，而不是替换需要使用修改操作符来完成修改。$set 可以用来修改文档中的指定属性$unset 可以用来删除文档的指定属性 示例： 1234567891011121314151617 // 替换db.students.update(&#123;name:&quot;wby&quot;&#125;,&#123;age:20&#125;); // 修改 db.stus.update( &#123;&quot;_id&quot; : ObjectId(&quot;59c219689410bc1dbecc0709&quot;)&#125;, &#123;$set:&#123; gender:&quot;男&quot;, address:&quot;流沙河&quot; &#125;&#125; ) // 删除 db.stus.update( &#123;&quot;_id&quot; : ObjectId(&quot;59c219689410bc1dbecc0709&quot;)&#125;, &#123;$unset:&#123; address:1 &#125;&#125; ) db.collection.updateOne() 修改集合中的一个文档 db.collection.updateMany() 修改集合中的多个文档 db.collection.replaceOne() 替换集合中的一个文档 删除集合中的文档 db.collection.remove() 删除集合中的一个或多个文档（默认删除多个） db.collection.deleteOne() 删除集合中的一个文档 db.collection.deleteMany() 删除集合中的多个文档 清空一个集合 db.collection.remove({}) 删除一个集合 db.collection.drop() 删除一个数据库 db.dropDatabase() 一般数据库中的数据都不会删除，所以删除的方法很少调用。]]></content>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之其它]]></title>
    <url>%2F2019%2F10%2F24%2FE-06-ES6%E4%B9%8B%E5%85%B6%E5%AE%83%2F</url>
    <content type="text"><![CDATA[1. 字符串扩展1.1 介绍 includes(str) : 判断是否包含指定的字符串 startsWith(str) : 判断是否以指定字符串开头 endsWith(str) : 判断是否以指定字符串结尾 repeat(count) : 重复指定次数1.2 使用 2. 数值扩展2.1 介绍 二进制与八进制数值表示法: 二进制用0b, 八进制用0o Number.isFinite(i) : 判断是否是有限大的数 Number.isNaN(i) : 判断是否是NaN Number.isInteger(i) : 判断是否是整数 Number.parseInt(str) : 将字符串转换为对应的数值 Math.trunc(i) : 直接去除小数部分 3. 数组扩展3.1 介绍 Array.from(v) : 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3) : 将一系列值转换成数组 find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素 findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标 4. 对象扩展4.1 介绍 Object.is(v1, v2) 判断2个数据是否完全相等 Object.assign(target, source1, source2..) 将源对象的属性复制到目标对象上 直接操作 __proto__ 属性 let obj2 = {}; obj2.__proto__ = obj1; 5. 深度克隆5.1 介绍 数据类型：数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型 基本数据类型： 特点： 存储的是该对象的实际数据 对象数据类型： 特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里 复制数据 基本数据类型存放的就是实际的数据，可直接复制 let number2 = 2; let number1 = number2; 克隆数据：对象/数组 区别： 浅拷贝/深度拷贝 判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用 知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用 let obj = {username: &#39;kobe&#39;} let obj1 = obj; // obj1 复制了obj在栈内存的引用 常用的拷贝技术 arr.concat(): 数组浅拷贝 arr.slice(): 数组浅拷贝 JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝 但不能处理函数数据 浅拷贝包含函数数据的对象/数组 深拷贝包含函数数据的对象/数组 6. Set和Map数据结构6.1 介绍 Set容器 : 无序不可重复的多个value的集合体 Set() Set(array) add(value) delete(value) has(value) clear() size Map容器 : 无序的 key不重复的多个key-value的集合体 Map() Map(array) set(key, value)//添加 get(key) delete(key) has(key) clear() size 7. for of 循环7.1 介绍 for(let value of target){}循环遍历 遍历数组 遍历Set 遍历Map 遍历字符串 遍历伪数组]]></content>
      <categories>
        <category>前端</category>
        <category>ECMAScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之常用]]></title>
    <url>%2F2019%2F10%2F24%2FE-05-ES6%E4%B9%8B%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. let关键字1.1 介绍 作用：与var类似, 用于声明一个变量 特点: 在块作用域内有效 不能重复声明 不会预处理, 不存在提升 应用: 循环遍历加监听 使用let取代var是趋势 1.2 代码示例2. const关键字2.1 介绍 作用：定义一个常量 特点: 不能修改 其它特点同let 应用：保存不用改变的数据2.2 3. 变量的解构赋值3.1 总结 理解：从对象或数组中提取数据, 并赋值给变量(多个) 对象的解构赋值：let {n, a} = {n:&#39;tom&#39;, a:12} 数组的解构赋值：let [a,b] = [1, &#39;wcy&#39;]; 用途：给多个形参赋值。3.2 4. 模板字符串4.1 介绍 作用：简化字符串的拼接 模板字符串必须用 ` ` 包含 变化的部分使用${xxx}定义4.2 5. 简化的对象写法5.1 介绍 省略同名的属性值 省略方法的function 例如:1234567let x = 1;let y = 2;let point = &#123; x, y, setX (x) &#123;this.x = x&#125;&#125;; 5.26. 箭头函数6.1 介绍 作用: 定义匿名函数 基本语法: 没有参数：() =&gt; console.log(&#39;xxxx&#39;) 一个参数：i =&gt; i+2 大于一个参数：(i,j) =&gt; i+j 函数体不用大括号: 默认返回结果 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回。 使用场景：定义回调函数。 箭头函数的特点： 简洁。 箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this。 扩展理解： 箭头函数的this看外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。6.2 7. 三点运算符7.1 用途 rest(可变)参数： 用来取代arguments 但比arguments灵活,只能是最后部分形参参数。1234567function add(...values) &#123; let sum = 0; for(value of values) &#123; sum += value; &#125; return sum;&#125; 扩展运算符： let arr1 = [1,3,5]; let arr2 = [2,...arr1,6]; arr2.push(...arr1); 7.2 8. 形参默认值8.1 介绍 当不传入参数的时候默认使用形参里的默认值。 1234function Point(x = 1,y = 2) &#123;this.x = x;this.y = y;&#125; 8.29. Promise对象9.1 介绍 理解： Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作) 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称’回调地狱’) ES6的Promise是一个构造函数, 用来生成promise实例 使用promise基本步骤(2步)： 创建promise对象： 调用promise的then() promise对象的3个状态： pending：初始化状态 fullfilled：成功状态 rejected：失败状态 应用： 使用promise实现超时处理 使用promise封装处理ajax请求9.2 10. Symbol10.1 介绍前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境 概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象) 特点： Symbol属性对应的值是唯一的，解决命名冲突问题 Symbol值不能与其他数据进行计算，包括同字符串拼串 for in, for of遍历时不会遍历symbol属性。 使用： 调用Symbol函数得到symbol值 let symbol = Symbol(); let obj = {}; obj[symbol] = &#39;hello&#39;; 传参标识 let symbol = Symbol(&#39;one&#39;); let symbol2 = Symbol(&#39;two&#39;); console.log(symbol);// Symbol(&#39;one&#39;) console.log(symbol2);// Symbol(&#39;two&#39;) 内置Symbol值 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。Symbol.iterator 对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲)10.2 11. Iterator遍历器11.1 概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制 作用： 1、为各种数据结构，提供一个统一的、简便的访问接口； 2、使得数据结构的成员能够按某种次序排列 3、ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。 作原理： 创建一个指针对象，指向数据结构的起始位置。 第一次调用next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值} value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 当遍历结束的时候返回的value值是undefined，done值为false 生具备iterator接口的数据(可用for of遍历) 1、Array 2、arguments 3、set容器 4、map容器 5、String … 12. Generator函数12.1 概念： ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据， 用来生成遍历器对象 可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果 点： function 与函数名之间有一个星号 内部用yield表达式来定义不同的状态 generator函数返回的是指针对象(接11章节里iterator)，而不会执行函数内部逻辑 调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done:false/true} 再次调用next方法会从上一次停止时的yield处开始，直到最后 yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 13. async函数13.1async函数(源自ES2017) 概念： 真正意义上去解决异步回调的问题，同步流程表达异步操作 本质： Generator的语法糖 语法： async function foo(){await 异步操作;await 异步操作 } 特点： 不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行。 返回的总是Promise对象，可以用then方法进行下一步操作。 async取代Generator函数的星号*，await取代Generator的yield。 语意上更为明确，使用简单，经临床验证，暂时没有任何副作用。 14. class14.1 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new来创建类的实例 通过extends来实现类的继承 通过super调用父类的构造方法 重写从父类中继承的一般方法 15. Module JS模块化]]></content>
      <categories>
        <category>前端</category>
        <category>ECMAScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5之常用]]></title>
    <url>%2F2019%2F10%2F24%2FE-01-ES5%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. ECMA简介 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范。 JavaScript 是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思。 JS包含三个部分： ECMAScript（核心） 扩展==&gt;浏览器端 BOM（浏览器对象模型） DOM（文档对象模型） 扩展==&gt;服务器端 Node ES的几个重要版本 ES5 : 09年发布 ES6(ES2015) : 15年发布, 也称为ECMA2015 ES7(ES2016) : 16年发布, 也称为ECMA2016 (变化不大) 2. ES5 常用点2.1 严格模式 理解: 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：”严格模式”（strict mode）。 这种模式使得Javascript在更严格的语法条件下运行。 目的/作用 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 消除代码运行的一些不安全之处，为代码的安全运行保驾护航。 为未来新版本的Javascript做好铺垫。 使用 在全局或函数的第一条语句定义为: &#39;use strict&#39;; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用。 语法和行为改变 必须用var声明变量。 禁止自定义的函数中的this指向window。 创建eval作用域。 对象不能有重名的属性。 2.2 JSON对象 JSON：传输数据的一种格式。JSON字符串只有JSON对象和JSON数组两种形式。 JSON.stringify(obj/arr) js对象(数组)转换为json对象(数组) JSON.parse(json) json对象(数组)转换为js对象(数组) 2.3 Object扩展ES5给Object扩展了好一些静态方法, 常用的2个： Object.create(prototype, [descriptors]) 作用: 以指定对象为原型创建新的对象。 为新的对象指定新的属性, 并对属性进行描述： – value：指定值 – writable：标识当前属性值是否是可修改的, 默认为false – configurable：标识当前属性是否可以被删除 默认为false – enumerable：标识当前属性是否能用for in 枚举 默认为false Object.defineProperties(object, descriptors) 作用: 为指定对象定义扩展多个属性。 get ：用来获取当前属性值得回调函数。 set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值。 存取器属性：setter,getter一个用来存值，一个用来取值。 Object本身的两个方法： get propertyName(){} 用来得到当前属性值的回调函数 set propertyName(){} 用来监视当前属性值变化的回调函数 2.4 Array扩展 Array.prototype.indexOf(value): 得到值在数组中的第一个下标 Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标 Array.prototype.forEach(function(item, index){}) : 遍历数组 Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组，返回加工之后的值 Array.prototype.filter(function(item, index){}) : 遍历过滤出一个新的子数组， 返回条件为true的值 2.5 Function扩展 Function.prototype.bind(obj)： 作用: 将函数内的this绑定为obj, 并将函数返回 面试题: 区别bind()与call()和apply()? 都能指定函数中的this call()/bind()传入的参数是值，apply()传入的参数是数组 call()/apply()是立即调用函数 bind()是将函数返回]]></content>
      <categories>
        <category>前端</category>
        <category>ECMAScript</category>
        <category>ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zepto之基础]]></title>
    <url>%2F2019%2F10%2F23%2FD-02-Zepto%E4%B9%8BZepto%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. zepto入门1.1 什么是zepto？ 概念：移动端开发框架,是jquery的轻量级代替品；API及语句同jquery相似，但文件更小(可压缩至8KB)。 是目前功能完备的库中，最小的一个。 zepto是轻量级的JavaScript库，专门为移动端定制的框架。 与jquery有着类似的API，俗称：会jquery就会用zepto。 1.2 zepto的特点 针对移动端。 轻量级，压缩版本只有8kb左右。 响应，执行快。 语法，API大部分同jquery一样，学习难度低，上手快。 同jquery一样以$作为核心函数和核心对象。 目前API完善的框架中体积最小的一个 1.3 zepto官网 http://zeptojs.com/(官网) https://github.com/madrobby/zepto(github下载地址) 2. zepto与jquery的前世今生2.1 相同点 zepto与jquery 都是优秀的js函数库 语法，API大部分都一样（zepto是按照jquery的思路来设计的） zepto相当于jquery的子集 同jquery一样都是以$为核心函数 2.2 不同点 jquery: 针对的更多的是PC端 体积较重 API较为完善 zepto: 针对的是移动端 体积较轻 有自己独特的移动端事件 3. zepto core(核心)3.1 核心函数 jQuery核心函数$ 1.作为函数调用：(参数) 参数为函数function 参数为选择器字符串 参数为DOM code 参数为html标签字符串 2.作为对象使用：(方法) 发送ajax请求($.ajax()、$.get()、$.post()) 其他api方法($.each()、$.isArray()、$.isFunction()、$.trim()、…) zepto： 以上jquery的特性zepto同样适用 3.2 与jquery相同的API jQuery对象 1.概念：jquery核心函数$()调用返回的对象就是jquery对象,而且时一个伪数组（可能有只有一个）； 2.使用： addClass() removeClass() show() find() append() add() css() index() … 3.3 与jquery不同的API attr与prop jQuery：attr与prop的区别 1、prop多用在标签的固有属性，布尔值属性。比如：a标签的href，class，selected等。 2、attr多用在自定义属性上。 3、在jquery中如果用attr去获取布尔值属性且该布尔值属性在标签体内没有定义的时候，会返回undefined zepto： 在zepto中用attr也可以获取布尔值属性。 prop在读取属性的时候优先级高于attr，布尔值属性的读取还是建议用prop。 坑！——zepto中removeProp()的方法。在1.2及以上才支持。 DOM操作 jQuery： jquery中插入DOM元素的时候添加配置对象（属性选择器：id，class…)的时候不会显示。 配置对象：就是在主体上再添加一些修饰。 zepto： 插入DOM元素的时候添加配置对象的时候可以添加进去，并且添加的配置对象的内容会直接反应在标签属性内，且可以操作，影响对应的DOM元素。 each方法: $.each(collection, function(index, item){ … }) jQuery： 可以遍历数组,以index，item的形式， 可以遍历对象，以key-value的形式 不可以遍历字符串。 不可以遍历json字符串 zepto: 可以遍历数组,以index，tiem的形式， 可以遍历对象，以key-value的形式， 可以遍历字符串同对数组的遍历方法一样以index-item的形式。 offset()的区别 jQuery： 获取匹配元素在当前视口的相对偏移。 返回的对象包含两个整型属性：top 和 left。此方法只对可见元素有效。 获取width，height时为undefined。 zepto: 获得当前元素相对于视口的位置。 返回一个对象含有： top, left, width和height(获取的宽高是盒模型可见区域的宽高)。 获取宽高的区别 jQuery获取宽高的方法: width(),height(),.css() —&gt; 返回的是content内容区的宽高，没有单位px; .css(‘width’) —&gt; 可以获取content内容区的宽高，padding，border的值，有单位px; 也可以利用innerHeight(),outerHeight(),innerWidth(),outerWidth()等来获取padding和border的值。 zepto: 用width(),height()是根据盒模型决定的，并且不包含单位px，包含padding的值,border的值。 zepto中没有innerHeight(),innerWidth()，outerHeight(),outerWidth() 用.css(‘width’)获取的是content的宽高。也可以用.css(‘padding’)，.css(‘border-width’)单独获取padding，border的值。 事件委托 jQuery： 在jquery中事件委托只是找相应的event.target触发元素进行的回调函数执行,其他的并不关心。 live： 三个参数：触发元素 触发的事件类型 触发事件的回调函数 1.7以后已经不 支持live了。 $(&#39;#a&#39;).live(&#39;click&#39;,function(){alert(&#39;a&#39;);}) delegate： 三个参数：触发元素 触发的事件类型 触发事件的回调函数 $(&#39;#box&#39;).delegate(&#39;.a&#39;,&#39;click&#39;,function(){alert(&#39;delegate&#39;);}) zepto: 在zepto的官网表示已经废除了live，delegate等。 用on(): 三个参数：触发的事件类型 触发元素 触发事件的回调函数 $(&#39;#box&#39;).on(&quot;click&quot;,&#39;.b&#39;,function(){alert(&#39;b事件&#39;);}); 委托的事件先被依次放入数组队列里，然后由自身开始往后找直到找到最后，期间符合条件的元素委托的事件都会执行。 坑!在zepto中事件委托,同时满足以下四个会踩坑！ 1、委托在同一个父元素,或者触发的元素的事件范围小于同类型事件(冒泡能冒到自身范围) 2、同一个事件 3、委托关联 操作的类要进行关联 4、绑定顺序—从当前的位置往后看 了解：重排比重绘要快得多，因为重排是主线程，重绘线程还未来得及开启，就已经重排了。 事件委托: 将子元素的事件委托给父元素。 原理：冒泡原理 好处：只需要绑定一次，新添加的子元素也可以拥有这个事件（一次绑定，终生受用）。 绑定在父元素身上，子元素触发（event.target指向触发事件的子元素）。 隐藏元素 jQuery： jquery可以获取隐藏元素的宽高 用width()和height() zepto: zepto无法获取隐藏元素宽高。 4. zepto事件机制4.1 touch Event 同jQuery类似事件： on() —&gt; 绑定事件处理程序。 off() —&gt; 方法移除用目标oon绑定的事件处理程序。 bind() —&gt; 为每个匹配元素的特定事件绑定事件处理函数，可同时绑定多个事件，也可以自定义事件。 one() —&gt; 为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。只执行一次。 trigger() —&gt; 触发有bind定义的事件（通常是自定义事件，自定义事件是在页面加载的时候触发的）。 unbind() —&gt; bind的反向操作，删除匹配元素所绑定的bind事件。 zepto 的 touch方法 tap() —&gt; 点击事件 利用在document上绑定touch事件来模拟tap事件的，并且tap事件会冒泡到document上 singleTap() —&gt; 单击事件 doubleTap() —&gt; 双击事件 longTap() —&gt; 当一个元素被按住超过750ms触发。 swipe, swipeLeft, swipeRight, swipeUp, swipeDown —&gt; 当元素被划过(同一个方向滑动距离大于30px)时触发。(可选择给定的方向)在一个方向滑动大于30px即为滑动。否则算点击。 touch-action: none;/* 用通配符设置这个为auto以后btn点击事件不能触发了，设置none以后滑动事件不能触发了，所以可以只静止#btn，而不是用通配符*/。 4.2 Event zepto有自己的一套事件机制，并且对不同的浏览器做了兼容的内部的封装处理。 新版本的zepto中舍弃了bind，delegate，die，同样jquery中舍弃了live，delegate等 统一使用on，off等标准事件来绑定事件。 5. form5.1 serialize() 在Ajax post请求中将用作提交的表单元素的值编译成 URL-encoded 字符串。—key(name)/value 5.2 serializeArray() 将用作提交的表单元素的值编译成拥有name和value对象组成的数组。 不能使用的表单元素，buttons，未选中的radio buttons/checkboxs 将会被跳过。 5.3 submit() 为 “submit” 事件绑定一个处理函数，或者触发元素上的 “submit” 事件。 当参数function没有给出时，触发当前表单“submit”事件，并且执行默认的提交表单行为，除非阻止默认行为。 6. ajax细节剖析 请求验证码案例分析]]></content>
      <categories>
        <category>前端</category>
        <category>js库</category>
        <category>Zepto.JS</category>
      </categories>
      <tags>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular之基础]]></title>
    <url>%2F2019%2F10%2F23%2FD-01-AngularJS%E4%B9%8BAngular%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. AngularJS入门1.1 AngularJS是什么? Google开源的前端JS结构化框架： https://angularjs.org/ AngularJS特性和优点： 双向数据绑定。 声明式依赖注入。 解耦应用逻辑, 数据模型和视图。 完善的页面指令。 定制表单验证。 Ajax封装。 与jQuery的比较： jQuery：是一个JS函数库，封装简化dom操作。 Angular：是一个JS结构化框架，主体不再是DOM, 而是页面中的动态数据。 AngularJS能做什么项目 构建单页面(SPA)Web应用或Web App应用 单页面应用（SPA）：single page application 单页面应用的特点： – 1.将所有的活动局限于一个页面。 – 2.当页面有部分数据发生了变化不会去刷新整个页面，而是局部刷新 – 3.利用ajax技术，路由。 应用： – 饿了吗: https://www.ele.me/home/ – 微信网页版: https://wx.qq.com/ – 知乎周报: https://zhuanlan.zhihu.com/Weekly – 后台管理应用: 阿里云, 土豆后台, 唯品会… 1.2 开发一个Angular应用的步骤 引入AnaularJS文件：&lt;script type=’text/javascript’ src=”路径”&gt;&lt;/script&gt; 使用AngularJS的语法。 使用ng-inspector插件（不必须）。 2. 四个重要概念2.1 双向数据绑定 数据绑定：数据从一个地方A转移(传递)到另一个地方B, 而且这个操作由框架来完成。 双向数据绑定：双向数据绑定: 数据可以从View(视图层)流向Model（模型）, 也可以从Model流向View。 视图(View): 也就是我们的页面(主要是Andular指令和表达式) 模型(Model) : 作用域对象(当前为$rootScope), 它可以包含一些属性或方法 当改变View中的数据, Model对象的对应属性也会随之改变: ng-model指令 数据从View —&gt; Model 当Model域对象的属性发生改变时, 页面对应数据随之更新: 表达式中的数据从Model —&gt; View 2.2 依赖注入(DI) 依赖对象：完成某个特定的功能需要某个对象才能实现，这个对象就是依赖对象。 依赖注入：依赖的对象以形参的形式被注入进来使用，这种方式就是依赖注入。 ！！！构造函数的形参必须是特定的名称($scope), 否则Angular无法注入，会抛出异常。 隐式声明依赖注入：模块名.contrller(‘作用域对象名’,function ($scope) {一些变量和方法}); 显式声明依赖注入：模块名.controller(‘作用域对象名’，[‘$scope’,function (a) {一些变量和方法}]); angular的 ‘$scope’对象就是依赖对象，并且是依赖注入的形式进行使用。 回调函数的event的就是依赖对象，回调函数有形参就是依赖注入。 2.3 MVC模式2.4 M-V-VM模式3. 三个重要对象3.1 作用域(scope) 作用域对象: 一个js实例对象, ng-app指令默认会创建一个根作用域对象($rootScope) 它的属性和方法与页面中的指令或表达式是关联的。 3.2 控制器(controller) 控制器: 用来控制AngularJS应用数据的 实例对象 ng-controller : 指定控制器构造函数, Angular会自动new此函数创建控制器对象 同时Angular还有创建一个新的域对象$scope, 它是$rootScope的子对象 在控制器函数中声明$scope形参, Angular会自动将$scope传入。 3.3 模块(module) 1.创建模块对象： 语法：angular.module: (ng-app = “模块名”) 1.可以在全局位置创建、注册、获取Angular模块。 2.所有模块都必须使用这个机制注册才能在应用中生效。 3.创建模块示例：var myModule = angular.module(‘模块名’,[放置第三方模块，没有就写空数组]); 2.使用模块对象：定义控制器、定义服务、定义指令、… 3.4 一起使用详情 1.创建模块对象：用全局变量angular对象 语法：angular.module: (ng-app = “模块名”) 1.可以在全局位置创建、注册、获取Angular模块。 2.所有模块都必须使用这个机制注册才能在应用中生效。 3.创建模块示例：var myModule = angular.module(‘模块名’,[放置第三方模块，没有就写空数组]); 2.生成作用域对象： 语法：controller(名称，constructor【构造函数】); —&gt; 返回值是模块对象. 1.用法示例：mymodule.contrller(‘作用域对象名’,function ($scope) {一些变量和方法});【这种方法叫隐式声明依赖注入】。 2.给要创建模块的元素添加：ng-controller = “生成的作用域对象名”。 3.也可以链式调用。 3.补充： $scope：构造函数中必须传入$scope形参，而且这个形参必须是$scope。 1.形参只能写固定的变量名$scope。 2.一旦文件压缩，将不能使用，会报错。 3.推荐写法：controller(名称，[‘$scope’,function (a) {一些变量和方法}]); 【这种方法叫显式声明依赖注入】 。 4. 两个页面语法4.1 表达式 使用Angular表达式： 语法: 作用: 显示表达式的结果数据。 是单向数据绑定，用来显示数据的，从作用域对象的指定属性名上取值。 注意: 表达式中引用的变量必须是当前域对象有的属性(包括其原型属性)。 通常有一个返回值，可以放在任何需要值得地方，比如函数调用的参数，一个变量名，一个运算…。 操作的数据： 基本类型数据: number/string/boolean undefined, Infinity, NaN, null解析为空串: “”, 不显示任何效果 对象的属性或方法 数组 表达式和语句的区别： 1、表达式：通常有一个返回值，可以放在任何需要值得地方，比如函数调用的参数，一个变量名，一个运算。 2、语句：通常表示一个完整的执行单位，一段完整的js可执行的代码，有的语句也可以用表达式来执行，叫做表达式语句。 3、区别：语句用封号结尾，有些语句我们没有加封号，比如console.log虽然我们没有加封号，但也是语句，因为js引擎会自动解析并且加上封号。js引擎在解析的时候会自动的加上封号。 4、特例：if语句，就不用加封号 可也是完整的语句。 4.2 指令 Angular指令介绍： Angular为HTML页面扩展的: 自定义标签属性或标签。 与Angular的作用域对象(scope)交互,扩展页面的动态表现力。 Angular常用指令： ！构造函数中的方法和变量都必须写成：$scope.变量名 / $scope.方法名。 ng-app: 指定模块名，angular管理的区域。(ng-app(指令) : 告诉angular核心它管理当前标签所包含的整个区域,并且会自动创建$rootScope根作用域对象) 使用1：在body标签(当前作用域的标签)中添加：ng-app = &quot;模块名&quot; 使用2：没有模块的时候在body标签(当前作用域的标签)中添加：ng-app ng-model： 双向绑定，输入相关标签。(ng-model : 将当前输入框的值与谁关联(属性名:属性值), 并作为当前作用域对象($rootScope)的属性) 使用：在标签中添加：ng-model = &quot;变量名&quot; ng-model是双向数据绑定。 ng-init： 初始化数据 使用：在当前作用域的标签内添加：ng-init = &quot;变量名 = &#39;初始值&#39;&quot; ng-init 用来初始化当前作用域变量，单向数据绑定（内存到页面）。 ng-click： 调用作用域对象的方法（点击时） 使用：在标签中添加：ng-click = &quot;方法名()&quot; ng-controller: 指定控制器构造函数名，内部会自动创建一个新的子作用域（外部的） 使用：给要创建模块的元素添加：ng-controller = &quot;作用域对象名&quot; ng-bind： 解决使用表达式时显示数据闪屏（在很短时间内显示语法） 使用：在标签中添加：ng-bind = &quot;表达式里面的内容&quot; ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域. $index(索引), $first, $last, $middle, $odd, $even —–&gt; 剩下的对应的都是布尔值. 使用：ng-repeat = &quot;一个变量（例如：person，相当于var person） in persons&quot; ng-show: 布尔类型， 如果为true才显示 使用：在标签中写上: ng-show = &quot;布尔值/返回布尔值的变量名（方法名）&quot;，标签中的内容就会【true】/不会【false】显示 ng-hide: 布尔类型， 如果为true就隐藏 使用：在标签中写上: ng-hidden = &quot;布尔值/返回布尔值的变量名（方法名）&quot;，标签中的内容就不会【true】/会【false】显示 ng-class: 动态引用定义的样式 {aClass:true, bClass:false} 使用：在标签中添加 :`ng-class = ng-style = {类名1: true/falase , 类名2：true/falase}` `ng-class = &quot;对象名&quot;` `ng-class = ng-style = {类名1: $odd , 类名2：$evev} // 隔行变色` ng-style: 动态引用通过js指定的样式对象 {color:’red’, background:’blue’} 使用：在标签中添加: ng-style = {属性名: &#39;属性值&#39;} 或者 ng-style = &quot;对象名【如：myStyle】&quot; ng-click: 点击监听, 值为函数调用, 可以传$event 使用：在标签中添加: ng-click = &quot;方法名()&quot; ng-mouseenter: 鼠标移入监听, 值为函数调用, 可以传$event 使用：在标签中添加: ng-mouseenter = &quot;方法名()&quot; ng-mouseleave: 鼠标移出监听, 值为函数调用, 可以传$event 使用：在标签中添加: ng-mouseleave = &quot;方法名()&quot; 5. 面试题 面试题1：开发的两种方式及区别： 1.声明式：注重结果。声明式是对命令的局部包装。（像考试的选择/填空题） 2.命令式：注重过程。（像考试的解答题） 面试题2： $(function(){}) = document.ready 文档（结构）加载完毕。 window.onload 整个页面加载完毕，包括图片。]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS2.1之字体与文本]]></title>
    <url>%2F2019%2F10%2F22%2FB-26-CSS2-1%E4%B9%8B%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[1. 字体1.0 字体：font 是否可继承：是 用法：font: 加粗 斜体 小型大写 大小/行高 字体 使用顺序：前边几个加粗、斜体和小型大写的顺 序无所谓，也可以不写，但是 大小和字体 必须写且必须写到后两个。 1.1 字体大小：font-size 默认值：浏览器默认字体大小 是否可继承：是 常用取值： /* &lt;length&gt;，长度值 */ font-size: 12px; font-size: 0.8em; 可取值： /* &lt;absolute-size&gt;，绝对大小值 */ font-size: xx-small; font-size: x-small; font-size: small; font-size: medium; font-size: large; font-size: x-large; font-size: xx-large; /* &lt;relative-size&gt;，相对大小值 */ font-size: larger; font-size: smaller; /* &lt;length&gt;，长度值 */ font-size: 12px; font-size: 0.8em; /* &lt;percentage&gt;，百分比值(占父元素字体大小的百分比) */ font-size: 80%; font-size: inherit; // 继承100% 1.2 字体样式：font-style 默认值：font-style: normal; 是否继承：是 取值： font-style: normal; // 常规字形 font-style: italic; // 斜体（常规字形的倾斜） font-style: oblique; // 倾斜体 font-style: oblique 40deg; // 倾斜指定度数 1.3 字体加粗：font-weight 默认值：font-weight: normal; 是否继承：是 常用取值： font-weight: normal; font-weight: bold; font-weight: lighter; font-weight: bolder; 可取值： /* Keyword values */ font-weight: normal; font-weight: bold; /* Keyword values relative to the parent */ font-weight: lighter; font-weight: bolder; /* Numeric keyword values */ font-weight: 1 font-weight: 100; font-weight: 100.6; font-weight: 123; font-weight: 200; font-weight: 300; font-weight: 321; font-weight: 400; font-weight: 500; font-weight: 600; font-weight: 700; font-weight: 800; font-weight: 900; font-weight: 1000; /* Global values */ – font-weight: inherit; – font-weight: initial; – font-weight: unset; 1.4 字体族：font-family 默认值：浏览器默认字体 是否继承：是 常用取值：font-family: Arial, Helvetica, sans-serif; 可取值：略 1.5 小型大写字母：font-variant（不是css2.1的内容） 默认值：font-variant: normal; 是否继承：是 常用取值：font-variant:small-caps 可取值：(文档上这样写的) font-variant: normal; font-variant: no-common-ligatures proportional-nums; font-variant: common-ligatures tabular-nums; font-variant: small-caps slashed-zero; 2. 文本2.1 文本颜色：color 默认值：浏览器默认文本颜色(黑色) 是否继承：是 常用取值：色彩关键字、rgb()、rgba() 可取值： 色彩关键字 color: pink; rgb() // 红-绿-蓝（red-green-blue (RGB)）模式` color: #ff0033; color: rgb(255, 0, 51);也可以百分比 hsl() // 色相-饱和度-明度模式` color: hsl(120, 60%,70%); 第一个是数值，后两个是百分比 rgba() // 红-绿-蓝-阿尔法模式(a 表示透明度：0=透明；1=不透明) color: rgba(255,0,0,0.4); hsla() // 色相-饱和度-明度-阿尔法模式(a 表示透明度：0=透明；1=不透明) color: hsla(240,100%,50%, 0.7); 2.2 水平对齐方式：text-align 默认值：text-align: start; 是否继承：是 常用取值： text-align: center; 可取值： text-align: start; // 如果内容方向是左至右，则等于left，反之则为right。 text-align: end; // 如果内容方向是左至右，则等于right，反之则为left。 text-align: left; // 行内内容向左侧边对齐。 text-align: right; // 行内内容向右侧边对齐。 text-align: center; // 行内内容居中。 text-align: justify; // 文字向两侧对齐，对最后一行无效。 text-align: justify-all; // 和justify一致，但是强制使最后一行两端对齐。 text-align: match-parent; // 和inherit类似，区别在于start和end的值根据父元素的direction确定，并被替换为恰当的left或right。 2.3 垂直对齐方式：vertical-align 一般设置垂直居中用：line-height = height ； 注意 vertical-align 只对行内元素、表格单元格元素生效：不能用它垂直对齐块级元素。 默认值：浏览器默认对齐方式 是否继承：是 常用取值： vertical-align: bottom; vertical-align: middle; vertical-align: top; 可取值： /* Keyword values */ 相对父元素的值: vertical-align: baseline; // 使元素的基线与父元素的基线对齐。 vertical-align: sub; // 使元素的基线与父元素的下标基线对齐。 vertical-align: super; // 使元素的基线与父元素的上标基线对齐。 vertical-align: text-top; // 使元素的顶部与父元素的字体顶部对齐。 vertical-align: text-bottom; // 使元素的底部与父元素的字体底部对齐。 vertical-align: middle; // 使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐。 相对行的值: vertical-align: top; // 使元素及其后代元素的顶部与整行的顶部对齐。 vertical-align: bottom; // 使元素及其后代元素的底部与整行的底部对齐。 /* values */ vertical-align: 10em; vertical-align: 4px; /* values */ vertical-align: 20%; 2.4 首行缩进：text-indent 默认值：不缩进 是否继承：是 常用取值： text-indent: 3mm; text-indent: 40px; 可取值： /* 长度值 */ text-indent: 3mm; text-indent: 40px; /* 百分比值取决于其包含块（containing block）的宽度*/ text-indent: 15%; /* 关键字 */ text-indent: 5em each-line; text-indent: 5em hanging; text-indent: 5em hanging each-line; 2.5 文本修饰：text-decoration 默认值：`text-decoration: none 是否继承：是 常用取值：(下划线、顶划线、删除线或者闪烁) text-decoration: none; text-decoration: underline; text-decoration: overline; text-decoration: line-through; 用法示例： text-decoration: underline red; // 红色下滑直线 text-decoration: wavy overline lime; // 绿色上划波浪线 text-decoration: line-through; // 黑色直的删除线 text-decoration: none; // 没有任何修饰 text-decoration: blink; // 闪烁 text-decoration: dashed underline overline; // 上下都有的黑色虚线 2.6 字符间距(英)：letter-spacing 默认值：letter-spacing: normal; // 于间距 0 是否继承：是 常用取值： letter-spacing: 0.3em; letter-spacing: 3px; 可取值： 关键字letter-spacing: normal; 长度letter-spacing: 0.3em; letter-spacing: 3px; letter-spacing: .3px; 2.7字符间距(中)：word-spacing 默认值：word-spacing: normal; // 于间距 0 是否继承：是 常用取值： word-spacing: 0.3em; word-spacing: 3px; 可取值： 关键字 word-spacing: normal; 长度 word-spacing: 0.3em; word-spacing: 3px; word-spacing: .3px; 百分比：通过指定受影响字符的宽度的百分比的方式来增加的间距。！我还不清楚怎么用 2.8 空白：white-space white-space CSS 属性是用来设置如何处理元素中的空白。 默认值：浏览器默认字体 是否继承：是 常用取值：font-family: Arial, Helvetica, sans-serif; 可取值： white-space: normal; // 连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 white-space: nowrap; // 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 white-space: pre; // 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素时才会换行。 white-space: pre-wrap; // 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时才会换行。 white-space: pre-line; // 连续的空白符会被合并。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时会换行。 white-space: break-spaces;// 与 pre-wrap的行为相同，除了：！！！ ！任何保留的空白序列总是占用空间，包括在行尾。 ！每个保留的空格字符后都存在换行机会，包括空格字符之间。 ！这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。 2.9 行高：line-height line-height CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度。 ！！！行高指的是行框的高，字体的大小指的是行内框的高。 （在前端开发中，如果要处理大量的文本，建议把行高设置的要比字体大） 默认值：line-height: normal;(浏览器默认，约为1.2) 是否继承：是 常用取值：常用line-height = height,h或者在设置font时：font-size/line-height 可取值： 关键词 normal line-height: normal; &lt;百分比&gt; line-height: 150%; // 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小。百分比值可能会带来不确定的结果 &lt;数字&gt; line-height: 2.5; // 无单位数字&lt;数字&gt;乘以该元素的字体大小,这是设置line-height的推荐方法 &lt;长度&gt; line-height: 3em; // 以 em 为单位的值可能会产生不确定的结果 line-height: 32px;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS2.1</category>
      </categories>
      <tags>
        <tag>字体</tag>
        <tag>文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS2.1之垂直水平居中]]></title>
    <url>%2F2019%2F10%2F22%2FB-24-CSS2-1%E4%B9%8B%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1. 普通盒子水平垂直居中1.1 水平居中 普通盒子水平居中: margin: 0 auto; 盒子中的文本水平居中: text-align: center; 1.2 已知宽高的元素水平垂直居中： 方案： a.给父盒子开启相对定位：position: relative; b.给要垂直水平剧中的盒子开启绝对定位，并设置位置： position: absolute; left: 50%; top: 50%; margin-left: -50px; // 这里是 margin-left = 盒子宽度的一半 margin-top: -50px; // 这里是 margin-top = 盒子高度的一半 局限性：设置其它过渡动画时可能会受影响。 1.3 已知高度的元素水平垂直居中 开启绝对定位的子元素的宽高默认占父元素的100%；正常的div不给宽高，宽占父元素的100%，高度由内容撑开。 方案： a.给父盒子开启相对定位：position: relative; b.给要垂直水平剧中的盒子开启绝对定位，并设置位置： position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; margin: auto; 原理： 绝对定位盒子的特性：高宽由内容撑开. 水平方向上： left(0) + right(0) + width(100) + padding(0) + margin(0) = 包含块padding区域的尺寸(400) 垂直方向上： top(0) + bottom(0) + height(100) + padding(0) + margin(0) = 包含块padding区域的尺寸(600) 1.4 未知高度的元素水平垂直居中 方案： a.给父盒子开启相对定位：position: relative; b.给要垂直水平剧中的盒子开启绝对定位，并设置位置： position: absolute; left: 50%; top: 50%; transform: translate3d(-50%,-50%,0); 2. 图片在盒子中水平垂直居中2.1 普通图片在盒子中水平垂直居中 方案1： a.给div设置：text-align: center;，此时图片水平居中； b.给盒子添加after伪元素，并设置#wrap:after{...}，此时图片下移了一段距离但不在正中间； content: &quot;&quot;; display: inline-block; height: 100%; vertical-align: middle; c.最后给图片设置：vertical-align: middle;，这时图片就在盒子中水平垂直居中了。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS2.1</category>
      </categories>
      <tags>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS2.1之一些小点]]></title>
    <url>%2F2019%2F10%2F21%2FB-22-CSS2-1%E4%B9%8B%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. 定位参照于谁来定位 没有定位: 包含块 相对定位: 元素本来的位置 固定定位: 视口 绝对定位：相对于包含块进行定位(没有开启定位的父元素，就相对于初始包含块进行定位；有开启定位的祖先元素，就相对于包含块进行定位)。 初始包含块是一个大小位置与视口相同的矩形，但并不等于视口，绝对定位也不是相对于浏览器视口进行定位的。 包含块：开启定位的祖先元素从内边距开始（内边距+内容去）的矩形区域。 2. width width属性的默认值是：auto (不写width属性与写 width:auto;效果一样) width属性的可继承性：否 width属性的值auto和100%的区别： auto包含了外边距，如果再加外边距，宽度不会变 100% 不包含外边距，如果再加外边距的话，宽度会变 另外： left、top、right、bottom、width、height 的默认值为auto； margin、padding 的默认值为0； boder-width ：如果不存在border-style 3. 百分比 不仅宽高可以使用百分比。 宽：占父元素宽度的百分之几。 高：占父元素高度的百分之几。 内外边距也可以使用百分比来表示： 内边距padding：不管是几个百分比值，都是padding = 父元素宽度的百分之几。 外边距margin：不管是几个百分比值，都是margin = 父元素宽度的百分之几。 百分比参照于谁？ width、margin、padding:包含块的width height:包含块的height left:包含块的width top :包含块的height 4. 浮动 浮动：img标签是一个行内块元素，浮动的初衷是让文字环绕图片。 注意： ！浮动提升半层，也就是说只是盒模型部分的脱离了文档流不占位置，其它的还在文档流中占位置。 ！当上面的元素浮动以后，下面的元素顶上来，但是没有浮动的元素的非盒模型内容被往外挤，而不是被遮挡。 5. 滚动条 滚动条出现规则： 页面内元素高度过高，自动出现系统滚动条（浏览器的滚动条）。 给html标签或者body标签中的其中一个加上overflow: scroll; ，滚动条出现在系统上（出现的是浏览器的滚动条）。 同时给html标签和body标签加上overflow: scroll; ，滚动条不仅出现在系统上（出现的是浏览器的滚动条），body上也出现滚动条。 移动端开发时一般都会静止系统的默认滚动条，使用自定义的body身上的滚动条。 静止系统默认滚动条： 1234html,body&#123; height: 100%; overflow: hidden;&#125; 用绝对定位模拟固定定位 静止系统滚动条，让body出现滚动条。 1.禁止系统滚动条 2.将滚动条加给body 3.让body的尺寸变为视口的尺寸 12345678910111213141516171819202122232425&lt;!-- css代码 --&gt;html&#123; height: 100%; overflow: hidden;&#125;body &#123; height: 100%; overflow: scroll; /*auto也可以*/&#125;#test &#123; position: absolute; left: 50px; top: 50px; width: 100px; height: 100px; background-color: pink;&#125; &lt;!-- html代码 --&gt;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;div style=&quot;height: 1000px;&quot;&gt; zi &lt;br /&gt;zi &lt;br /&gt;zi &lt;br /&gt; zi &lt;br /&gt;zi &lt;br /&gt;zi &lt;br /&gt; zi &lt;br /&gt;zi &lt;br /&gt;zi &lt;br /&gt;&lt;/div&gt; 6.]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS2.1</category>
      </categories>
      <tags>
        <tag>css2.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js之初识vue]]></title>
    <url>%2F2019%2F10%2F21%2FC-01-Vue%E4%B9%8B%E5%88%9D%E8%AF%86vue%2F</url>
    <content type="text"><![CDATA[1. vue初识1.1 什么是Vue.js Vue.js 是目前最火的一个框架，React是最流行的一个框架(React除了开发网站，还可以开发手机App) Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并称为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。(Vue有配套的第三方类库，可以整合起来做大型项目的开发) 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道； 1.2 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 提高开发效率的发展历程：原生JS –&gt; jQuery之类的类库 –&gt; 前端模板引擎 –&gt; Angular.js / Vue.js (能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，前端程序员只需要关心数据的业务逻辑，不用再关心DOM是如何渲染的了】) 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力。 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 1.3 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node中的express； 库(插件)：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 1.从jQuery切换到Zepto 从EJS切换到art-template 1.4 Node(后端)中的MVC与前端中的MVVM之间的区别 MVC是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层分为了三部分： Module View VM ViewModule 为什么有了MVC还要有MVVM？详情见图解 2. vue指令 vue2.0里面不可以把id给body 1234567891011121314&lt;script&gt; var vm = new Vue(&#123; el:&quot;#app2&quot;, data: &#123;&#125;, methods: &#123;&#125;, computed: &#123;&#125; // 计算属性 filters: &#123;&#125;, // 私有过滤器 directives: &#123;&#125;, // 自定义私有指令 components: &#123;&#125;, // 自定义组件 watch:&#123;&#125;, // 监视data中指定数据的变化，触发对应的处理函数 render: function()&#123;...&#125;, // 使用render函数渲染组件 生命周期的各个钩子函数 &#125;) &lt;/script&gt; vue里面提供的标签 component：组件的占位符，:is属性值为组件名 —&gt; 用于组件切换 template：有一个id属性与Vue.omponent中的template属性进行绑定 —&gt; 用于放置模板内容 transition：绑定动画的钩子函数 —&gt; 用于放置发生动画的元素 transitionGroup：有appear和tag属性 —&gt; 用于放置用v-for循环的动画列表 router-link：有to(值为路径)属性和tag属性 —&gt; 用于渲染改变路径(控制组件)的元素 router-view：相当于占位符 —&gt; 用于渲染对应路径的组件 2.1 Vue基本代码和MVVM之间对应 Vue实例所控制的这个元素区域，就是MVVM中的 V(视图层)。 new 出来的vm对象，就是MVVM中的 VM调度者。 Vue实例中的 data 就是MVVM中的 M。 代码示例及详细解析如下： 12345678910111213141516171819202122&lt;!-- html代码 --&gt;&lt;body&gt; &lt;!-- 后面new 的Vue实例，会控制这个元素中的所有内容。Vue实例所控制的这个元素区域，就是MVVM中的 V --&gt; &lt;div id=&quot;app&quot;&gt;&lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- js代码 --&gt; &lt;!-- 1.导入vue包 ，导入包之后，在浏览器内存中就多了一个Vue构造函数 --&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/scrit&gt; &lt;script&gt; &lt;!-- 2.创建一个vue实例 --&gt; &lt;!-- 这里new出来的vm对象，就是MVVM中的 VM调度者 --&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, // 表示当前new的这个Vue实例，要控制页面上的哪个区域 &lt;!-- *这里 data 就是MVVM中的 M*。 --&gt; data: &#123; // data属性中，存放的是el中要用到的数据 msg: &apos;欢迎学习Vue！&apos; // 通过vue提供的指令，很方便就能把数据渲染到页面上(前端的Vue之类的框架，不提倡手动操作DOM元素) &#125; &#125;); &lt;/scrit&gt;&lt;/body&gt; 2.2 指令2.2.1 插值表达式 语法： 用法示例：&lt;p&gt;&lt;/p&gt; 不会覆盖p标签中原有的内容，只会替换自己的合格占位符，不会清空元素内容。如：&lt;p&gt;这些内容可以显示这些内容也可以显示&lt;/p&gt; 如果网络比较慢，会出现闪烁的问题。 2.2.2 v-cloak 使用 v-cloak 能够解决插值表达式闪烁的问题。 用法示例：&lt;p v-cloak&gt;&lt;/p&gt; 并设置css样式：[v-cloak] {display: none;} 原理是：内容加载出来以后v-cloak属性会自动移除 2.2.3 v-text v-text 会覆盖元素中原本的内容(会清空元素内容)。 默认 v-text 是没有闪烁问题的。 用法示例：&lt;p v-text=&quot;msg&quot;&gt;一些会被覆盖的内容&lt;/p&gt; 2.2.4 v-html v-html 是用来显示html内容的 用法示例：&lt;p v-html=&quot;msg&quot;&gt;msg: &lt;h1&gt;这是html文本，但能正常显示为标题&lt;/h1&gt;&lt;/p&gt; 2.2.5 v-bind: v-bind 是Vue中提供的提供的属性绑定机制。 用法示例：&lt;input type=&quot;button&quot; value=&quot;&quot; v-bind:tittle=&quot;mytitle&quot;&gt;&lt;/p&gt; v-bind: 指令可以被简写为 :要绑定的属性 v-bind 中，可以写合法的js表达式，如：&lt;input type=&quot;button&quot; value=&quot;&quot; v-bind:title=&quot;mytitle + &#39;123&#39;&quot;&gt;mytitle是一个在Vue实例中的变量&lt;/p&gt; v-bind在绑定表单元素的value属性时，可以实现单向数据绑定。 2.2.6 v-on: v-on: 是Vue中提供的事件绑定机制。 用法示例：&lt;input type=&quot;button&quot; value=&quot;&quot; v-on:click=&quot;show&quot;&gt;show是一个在Vue实例中的方法&lt;/p&gt; v-on: 指令可以被简写为 @要绑定的事件 事件修饰符： .stop —&gt; 阻止冒泡 用法示例：&lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click.stop=&quot;btnHandler&quot;&gt;btn在.inner的div中,btnHandler和divHandler是在Vue实例中的方法&lt;/p&gt; .prevent —&gt; 阻止默认事件 用法示例：&lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;阻止链接跳转,linkClick是在Vue实例中的方法&lt;/p&gt; .capture —&gt; 添加事件侦听器时使用事件捕获模式 用法示例：&lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click.capture=&quot;btnHandler&quot;&gt;btn在.inner的div中,btnHandler和divHandler是在Vue实例中的方法&lt;/p&gt; .self —&gt; 只当事件在该元素本身(比如不是子元素)触发时回调 用法示例： &lt;input type=&quot;button&quot; value=&quot;戳它&quot; @click.self=&quot;btnHandler&quot;&gt;btn在.inner的div中,btnHandler和divHandler是在Vue实例中的方法&lt;/p&gt; .once —&gt; 事件只触发一次 用法示例1： (只阻止一次默认行为) &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent.once=&quot;linkClick&quot;&gt;阻止链接跳转,linkClick是在Vue实例中的方法&lt;/p&gt; .self 和 .stop 的区别：.self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为；.stop是真正阻止冒泡的行为的。 2.2.7 v-model 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定。 v-model 只能运用在表单元素(input[radio、text、address、email、…])、select、checkbox、textarea等中。 用法示例：&lt;input type=&quot;text&quot; style=&quot;width:100%;&quot; v-model=&quot;msg&quot;&gt;msg是一个在Vue实例中的变量&lt;/p&gt; 2.2.8 :style 直接在元素上通过 :style 的形式，书写样式对象 &lt;h1 :style=&quot;{color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;}&quot;&gt;这是一个标题&lt;/h1&gt; 将样式对象(对象就是无序键值对的集合)定义到data中，并直接引用到:style中。 &lt;h1 :style=&quot;h1StyleObj&quot;&gt;h1StyleObj:{color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;}&lt;/h1&gt; 在:style中通过数组，引用多个data上的样式对象 &lt;h1 :style=&quot;[h1StyleObj,h1StyleObj2]&quot;&gt;h1StyleObj2与h1StyleObj并列&lt;/h1&gt; 2.2.9 v-for和 key属性 v-for：循环 使用语法：v-for=&quot;(val, key, i) in list&quot;，键、值、索引，有就写，没有就不写。 list可以是普通数组、对象数组、对象， 还可以是数字 使用示例： list是普通数组(迭代数组)：&lt;li v-for=&quot;(item,i) in list&quot;&gt;索引：-&lt;/li&gt; list是对象数组(迭代数组)：&lt;li v-for=&quot;(item,i) in list&quot;&gt;id:-name:&lt;/li&gt; list是对象(迭代对象中的属性)：&lt;li v-for=&quot;(val,key,i) in list&quot;&gt;索引：键：值：&lt;/li&gt; list是数字(迭代数字)：&lt;li v-for=&quot;i in 5&quot;&gt;这是第次循环&lt;/li&gt; 2.2.0+的版本里，当在组件中使用v-for循环时，key属性是必须的 key是标识唯一身份的，用于数据的绑定(记住数据的键/id) key在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果v-for有问题，必须在使用 v-for的同时，指定唯一的 字符串/数字 类型 :key 值。 2.2.10 v-if v-if：切换元素是隐藏还是显示(true显示) v-if的特点： 每次都会重新删除或创建元素 有较高的切换性能消耗 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if 使用实例：&lt;h3 v-if=&quot;flag&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; 2.2.11 v-show v-show：切换元素是隐藏还是显示(true显示) v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 有较高的初始渲染消耗 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show 使用实例：&lt;h3 v-show=&quot;flag&quot;&gt;这是用v-show控制的元素&lt;/h3&gt; 2.2.12 补充 数组的一些方法： forEach some filter findIndex 这些都属于数组的新方法，都会对数组中的每一项，进行遍历，执行相关的操作； arr.some(回调函数) —&gt; return true的时候，遍历将会终止 arr.findIndex(回调函数) —&gt; 找到某一项return true，停止遍历 arr.filter(回调函数) —&gt; 返回的仍是一个数组(经过回调函数筛选的一个数组) arr.forEach(回调函数) —&gt; 完整的遍历 jquery中： $(“:contains(str)”)：获取包含特定字符串的项 2.3 Vue过滤器 概念：Vue.js 允许自定义过滤器，可被用作一些常见的文本格式化。 过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。 过滤器应该被添加在 JavaScript 表达式的尾部，由管道符(|)指示。 过滤器并没有修改原数据，只是在中间做了一层处理(比如相机)。 过滤器中的 function ，第一个参数，已经被规定死了，永远都是过滤器管道符前面 传递过来的数据(可以省略)。 2.3.1 全局过滤器 所谓的全局过滤器，就是所有的VM实例都共可以使用的。 一个过滤器可以同时传递多个参数。 也可以一次性调用多个过滤器。 使用示例： 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; msg1 | test &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; msg | msgFormat(&quot;聪明&quot;,&quot;123&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; msg | msgFormat(&quot;聪明&quot;,&quot;123&quot;) | test &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; Vue.filter(&apos;msgFormat&apos;,function(msg,arg,arg2)&#123; // return msg.replace(&quot;单纯&quot;,&quot;聪明&quot;) // return msg.replace(/单纯/g,&quot;聪明&quot;) return msg.replace(/单纯/g,arg+arg2) &#125;) Vue.filter(&quot;test&quot;,function(msg1)&#123; return msg1 + &quot;=====&quot; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, data:&#123; msg: &quot;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的人&quot;, msg1: &quot;wcy&quot; &#125;, method:&#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 时间格式化过滤器： 1234567891011121314Vue.filter(&quot;dateFormat&quot;,function(dateStr,pattern = &quot;&quot;)&#123; var dt = new Date(dateStr) var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() if(pattern.toLowerCase() === &quot;yyyy-mm-dd&quot;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125;&#125;) 2.3.2 私有过滤器 又称局部过滤器 在vm实例中加一个filters属性(与methods类似)，把过滤器写在里面即可。 12345filters: &#123; dateFormat: function(dateStr, pattern = &apos;&apos;) &#123; ... &#125;&#125; 补充：填充字符串(使用ES6中的字符串新方法来填充字符串) 头部填充：String.prototype.padStart(maxLength, fillString=’’) 例如：hour.toString.padStart(2,&quot;&quot;); 尾部填充：String.prototype.padEnd(maxLength, fillString=’’) 2.4 键盘修饰符2.4.1 Vue已经提供的键盘修饰符 建议查看文档！ .enter —&gt; @keyup.enter = “方法” .tab —&gt; @keyup.tab = “方法” … 2.4.2 自定义键盘修饰符 第一种：.键码 —&gt; @keyup.113 = “方法” 第二种：Vue.config.keyCodes.键名 = 对应的键码 —&gt; @keyup.键名 = “方法” 2.5 自定义指令 Vue 1.x 中 自定义元素指令【已废弃,了解即可】 2.5.1 自定义全局指令 Vue.directive() directive不需要带s 参数1：指令的名称 在定义的时候，指令的名称前面不需要加 v- 前缀, 在调用的时候，必须在指令名称前加上 v-前缀。 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 在每个函数中，第一个参数永远是el ，表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象。 bind、inserted、updated，它们三个的执行时机不一样，详细说明在下面的代码中 代码示例： 1234567891011Vue.directive(&apos;focus&apos;, &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 el.focus() // 在此处执行不生效(这时候，调用 focus 方法没有作用)，因为一个元素只有插入DOM之后，才能获取焦点 &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125;&#125;) 简写：&quot;fontsize&quot;: function(el) {...}，这个function等同于把代码写到了bind和update中 2.5.2 自定义私有指令3. Vue实例的生命周期32.6.1 什么是生命周期 从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 3.2 什么是生命周期钩子 就是生命周期事件的别名而已 生命周期钩子 = 生命周期函数 = 生命周期事件 3.3 主要的生命周期函数分类 三类：创建期间、运行期间、销毁期间 3.3.1 创建期间的生命周期函数 beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性 created：实例已经在内存中创建OK，此时data和methods已经创建OK，此时还没有开始编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 3.3.2 运行期间的生命周期函数 beforeUpdate：状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的 数据 还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成 了新，界面已经被重新渲染好了！ 3.3.3 销毁期间的生命周期函数 beforeDestroy：实例销毁之前调用，在这一步，实例仍然完全可用。 destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 3.4 整个生命周期的详细分析 1、new Vue： 表示开始创建一个Vue的实例对象 2、init：（事件和生命周期） 表示刚初始化了一个Vue空的实例对象，此时这个对象身上只有默认的一些生命周期函数和默认的事件，其它的东西都未创建。 a、beforeCreate：在beforeCreate生命周期函数执行的时候，data和methods中的数据都还没有初始化 3、init：（注入和验证） 初始化data和methods b、created： 在created中，data和methods都已经被初始化好了 如果要调用methods中的方法，或者操作data中的数据，最早只能在created中操作。 4、if-render：（是否指定元素和模板–渲染） 这里表示Vue开始编辑模板，把Vue代码中的那些指令进行执行，最终在内存中生成一个编译好的最终模板字符串，然后把这个字符串模板渲染为内存中的DOM。 此时只是在内存中渲染好了模板，并没有把模板挂载到真正的页面中去 c、beforeMount： beforeMount函数执行的时候，模板已经再内存中编译好了，但是尚未挂载页面中去。 此时页面还是旧的 5、Creat-replaace：（替换虚拟DOM） 这一步将编译好的模板真实地替换到浏览器的页面中去。 d、mounted： 只要执行完了mounted，就表示整个Vue实例已经初始化完毕了。 如果要通过某些插件操作页面上的DOM节点，最早要在mounted中进行。 6、Mounted –&gt; 数据更新 –&gt; Virtual DOM re-render –&gt; Mounted 此时组件已经脱离了创建阶段，进行到了运行阶段。 这些是组件运行阶段的生命周期函数(beforeUpdate和updated)，这两个事件会根据data数据的改变，有选择性的触发0次到多次。 数据更新：数据更新然后到下一步。 e、beforeUpdate：当执行beforeUpdate的时候，data数据是最新的，页面尚未和最新的数据保持同步 Virtual DOM re-render：这一步执行的是先根据data中最新的数据在内存中重新渲染一份内存DOM树，再把新的DOM树渲染到真实的页面上去，这时候就完成了数据从data(Model层)-&gt; view(视图层)的更新 f、Updated：updated事件执行的时候，页面和data数据已经保持同步了，都是最新的 g、beforeDestroy： 当执行beforeDestroy钩子函数的时候，Vue实例就已经从运行阶段进入到了销毁阶段。 当执行beforeDestroy的时候，实例身上所有的data和所有的methods及过滤器、指令等都处于可用状态，此时还没有真正执行销毁的过程。 7、Teardown（解除绑定，销毁组件以及事件监听器） 8、Destroyed —&gt; h、destroyed： 当执行到destroyed函数的时候，组件已经完全被销毁了，此时组件中所有的数据、方法、指令、过滤器等都已经不可用了。 9、代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=&quot;app&quot;&gt; &lt;input @click=&quot;msg=&apos;way&apos;&quot; type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;p id=&quot;p&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;wcy&quot; &#125;, methods: &#123; show()&#123; console.log(&quot;执行了show方法！&quot;); &#125; &#125;, beforeCreate() &#123; console.log(this.msg) // undefined // this.show() 报错，说show不存在 &#125;, created() &#123; console.log(this.msg) // wcy this.show() // 执行了show方法！ &#125;, beforeMount() &#123; console.log( document.getElementById(&apos;p&apos;).innerText // &#123;&#123; msg &#125;&#125; ); &#125;, mounted() &#123; console.log( document.getElementById(&apos;p&apos;).innerText // wcy ); &#125;, beforeUpdate() &#123; // 数据不更新，该函数不执行 console.log( document.getElementById(&apos;p&apos;).innerText // wcy ); console.log(&apos;data中的 msg数据是：&apos; + this.msg) // data中的 msg数据是：way &#125;, updated() &#123; // 数据不更新，该函数不执行 console.log( document.getElementById(&apos;p&apos;).innerText // way ); console.log(&apos;data中的msg 数据是：&apos; + this.msg) // data中的msg 数据是：way &#125;, bedoreDestoryed() &#123;&#125;, destoryed() &#123;&#125; &#125;) 4. vue-resource4.1 vue-resource介绍 vue-resource 实现 get, post, jsonp请求 除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 测试的URL请求资源地址 get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp 4.2 JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 4.3 使用时注意事项 引入： vue-resource依赖于Vue，所以先后顺序要注意 引入vue-resource之后，在Vue身上挂载了一个this.$http.请求方式的属性 get请求： 参数1：url地址 参数2：可选的参数 在get()后面.then(成功的回调函数,失败的回调函数) 当发起get请求之后，通过.then来设置成功的回调函数 post请求： 参数1：url地址 参数2：要发给服务器的数据(这个数据是以对象的形式) 参数3：在post()后面.then(成功的回调函数,失败的回调函数) 手动发起的post请求默认没有表单格式，所以服务器处理不了，要设置{emulateJSON: true} jsonp请求： 参数1：url地址 参数2：成功的回调函数 当发起jsonp请求：之后，通过.then来设置成功的回调函数 全局配置： root：请求的数据接口根域名，则在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 / ，否则不会启用根路径做拼接。 Vue.http.options.root = &#39;http://vue.studyit.io/&#39;; emulateJSON：Vue.http.options.emulateJSON = true; 5. vue动画 为什么要有动画？动画能够提高用户体验，帮助用户更好的理解页面中的功能。 5.1 使用过渡类名 使用： 1、使用transition元素(是一个标签)，把 需要被动画控制的元素包裹起来 2、使用过渡类名 类名：一个进入/离开的动画分为两个时间点和一个时间段 时间点1：v-enter / v-leave 时间点2：v-enter-to / v-leave-to 时间段：v-enter-active / v-leave-active 其中：- v-enter和v-leave-to效果一样，v-enter-to和v-leave效果一样。 代码示例如下： transform与transition并不是写在同一个类中的 123456789101112// html：v-if是为了控制初始状态是显示还是隐藏&lt;transition&gt;&lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt;&lt;/transition&gt;// css：.v-enter,.v-leave-to &#123; opacity: 0; transform: translateX(150px);&#125;.v-enter-active,.v-leave-active&#123; transition: all 0.8s ease;&#125; 5.2 修改v-前缀 给transition元素(是一个标签)加一个name属性。 例如：用类名的时候就要把前缀v-换成my- &lt;transition name=&quot;my&quot;&gt;&lt;h6 v-if=&quot;flag2&quot;&gt;这是一个H6&lt;/h6&gt;&lt;/transition&gt; 5.3 动画钩子函数实现半场动画 钩子函数的参数1：el —&gt; 表示要执行动画的那个DOM元素，是个原生的JS DOM对象 before-enter=&quot;beforeEnter&quot; 此时动画尚未开始，可以在beforeEnter中设置元素开始动画之前的起始样式 enter=&quot;enter&quot; 开始之后的样式 必须要加一个el.offsetWidth(也可以是offsetLeft/offsetTop等)，否则没有动画效果 传参时传入done，并在这里调用，等于afterEnter函数的引用，在enter中它的调用时必须的，否则动画会延迟。 after-enter=&quot;afterEnter&quot; 动画完成之后，会调用afterEnter enter-cancelled=&quot;enterCancelled&quot; before-leave=&quot;beforLeave&quot; leave=&quot;leave&quot; after-leave=&quot;afterLeave&quot; leave-cancelled=&quot;leaveCancelled&quot; 钩子函数书写位置如下： 12345678910111213&lt;transition // 上半场(入场) v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; // 下半场(出场) v-on:before-leave=&quot;beforLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;/transition&gt; 初始位置分析：下一次点击的时候，开始执行下一个动画的生命周期，下一个执行周期给了初始位置（瞬间到原始位置） 5.4 列表动画 在实现列表过渡的时候，如果需要过渡的元素，是通过v-for循环渲染出来的，不能使用transition包裹，需要使用transitionGroup 如果要为v-for循环创建的元素设置动画，必须为每一个元素设置 :key 属性 给ransition-group添加appear属性，实现页面刚展示出来时候，入场时候的效果 (不写出场动画不显示) 通过为transition-group元素，设置tag属性，指定transition-group渲染为指定的元素，如果不指定 tag属性，默认渲染为span标签。 代码示例： 12345&lt;transition-group appear tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; 可以配合类名使用，也可以配合钩子函数 6. 组件化6.1 创建全局组件6.1.1 创建方式 通过template属性，指定了组件要展示的HTML结构 1、使用Vue.extend来创建全局的Vue组件，与template配合使用 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;mycom1&gt;&lt;/mycom1&gt;&lt;/div&gt;// 方式1var com1 = Vue.extend(&#123; template:&apos;&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;&apos;&#125;)Vue.compontent(&apos;mycom1&apos;,com1)// 方式2Vue.compontent(&apos;mycom1&apos;,Vue.extend(&#123; template: &apos;&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;&apos;&#125;)) 2、使用Vue.component(‘组件的名称’, 创建出来的组件模板对象) 创建出来的组件模板对象可以写在页面结构里，代码如下：123456789101112131415161718// 写法1 Vue.component(&apos;mycom2&apos;,&#123; template: &apos;&lt;div&gt;&lt;h3&gt;这是直接使Vue.component创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;&apos; &#125;)// 写法2 &lt;div id=&quot;app&quot;&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;/div&gt; &lt;template id=&quot;tmp&quot;&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; Vue.component(&apos;mycom3&apos;, &#123; template: &apos;#tmp&apos; &#125;) &lt;/script&gt; 6.1.1 关于命名 如果使用Vue.component定义全局组件的时候，组件名称使用了驼峰命名，则在引用组件的时候，需把 大写的驼峰改为小写的字母，同时两个单词之前使用 - 连接。 如果不使用驼峰，则直接拿名称来使用即可。 6.2 创建私有组件6.2.1 组件的创建 1、给vm实例添加components属性，并给创建的对象（组件名称）添加template属性，属性值为使用template元素定义件的HTML模板结构的选择器(例如：#tem) 2.1、在被控制的#app外面,使用template元素定义组件的HTML模板结构,并给一个id/类名… 2.2、也可以直接在template属性中写模板结构（字符串类型） 3、代码示例：12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;// 创建组件方式1&lt;template id=&quot;tmp&quot;&gt; &lt;h1&gt;这是私有的login组件&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; var login = &#123; template: &apos;&lt;h1&gt;这是私有的login组件&lt;/h1&gt;&apos; &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 方式2 login // 方式1 login: &#123; template: &apos;#tmp&apos; &#125; &#125; &#125;);&lt;script&gt; 6.2.2 渲染组件 方式1：组件名以标签的形式放到指定位置 不会覆盖页面中其它的内容 方式2：用render函数进行渲染 会覆盖掉#app区域 6.3 组件中的data和methods 1、组件可以有自己的data数据。 2、组件的data和实例的data有点不一样,实例中的data可以为一个对象,但组件中的data必须是一个方法。 3、组件中的data除了必须为一个方法之外,这个方法内部还必须返回一个对象(数据在这个对象中)才行。 这种做法是非常必要的，因为一个组件可能会被用多次，这样可以使数据之间不相互影响。 代码示例：1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;div&gt; &lt;input @click=&quot;increment&quot; type=&quot;button&quot; value=&quot;+1&quot;&gt;&lt;br&gt; &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;/div&gt;// var dataObj = &#123;num: 0&#125;Vue.component(&apos;counter&apos;,&#123; template: &apos;#tem&apos;, data: function() &#123; // return dataObj 这样写组件中的数据一个改变其它的也会改变 return &#123;num: 0&#125; // 每次创建组件，num都是从0开始的互不影响 &#125;, methods: &#123; increment() &#123; this.num++ &#125; &#125;&#125;) 4、组件中的data数据,使用方式和实例中的data使用方式完全一样!!!数据使用在模板中 5、代码示例： 12345678Vue.component(&apos;my&apos;,&#123; template: &apos;&lt;h1&gt;这是组件中的数据的组件--&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&apos;, data: function() &#123; return &#123; msg: &apos;这是组件的中data定义的数据&apos; &#125; &#125;&#125;) 6.4 不同组件之间的切换6.4.1 组件切换方式1 用v-if和v-else配合flag即可实现不同组件的切换。 这种方法只能实现两个组件切换 代码示例：（登录组件与注册组件的切换）123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;input @click=&quot;flag=true&quot; type=&quot;button&quot; value=&quot;登录&quot;&gt; &lt;input @click=&quot;flag=false&quot; type=&quot;button&quot; value=&quot;注册&quot;&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else=&quot;flag&quot;&gt;&lt;/register&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&apos;login&apos;,&#123; template: &quot;&lt;h3&gt;登录组件&lt;/h3&gt;&quot; &#125;) Vue.component(&apos;register&apos;,&#123; template: &quot;&lt;h3&gt;注册组件&lt;/h3&gt;&quot; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; flag: false &#125;, methhods: &#123;&#125; &#125;)&lt;/script&gt; 6.4.1 组件切换方式2 Vue提供了component,来展示对应名称的组件。 component是一个占位符, :is属性可以用来指定要展示的组件的名称。 代码示例：123456789101112131415161718&lt;input @click=&quot;showName=&apos;login&apos;&quot; type=&quot;button&quot; value=&quot;登录&quot;&gt;&lt;input @click=&quot;showName=&apos;register&apos;&quot; type=&quot;button&quot; value=&quot;注册&quot;&gt;&lt;component :is=&quot;showName&quot;&gt;&lt;/component&gt;&lt;script&gt; Vue.component(&apos;login&apos;,&#123; template: &quot;&lt;h3&gt;登录组件&lt;/h3&gt;&quot; &#125;) Vue.component(&apos;register&apos;,&#123; template: &quot;&lt;h3&gt;注册组件&lt;/h3&gt;&quot; &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; showName: register &#125;, methhods: &#123;&#125; &#125;)&lt;/script&gt; 6.4.1 动画切换 用transition标签包裹方式2中的component标签 通过transition标签的mode属性,设置组件切换时候的模式(out-in / in-out)，不传mode属性会出两个同时出现的画面。 在style标签里通过过渡类的方式指定动画 / 用动画的钩子函数 代码示例：123&lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;showName&quot;&gt;&lt;/component&gt;&lt;/transition&gt; 6.5 组件之间的传值6.5.1 父组件向子组件传值 本质：先在子组件上用v-bind绑定父组件数据的变量名，然后在子组件中使用绑定的属性名即可(需要这个属性名放在子组件的props属性的数组中去)。【我的理解】 子组件中，默认无法访问到父组件中的data上的数据和methods中的方法。 子组件中的data数据，并不是通过父组件传递过来的，而是子组件自身私有的。比如：子组件通过 Aja请求回来的数据，都可以放到data身上；data 上的数据，都是可读可写的。 父组件可以在引用子组件的时候，通过属性绑定（v-bind:）的形式，把需要传递给子组件的数据，以性绑定的形式传递到子组件内部，供子组件使用。例如：&lt;com1 :parentmsg=&quot;msg&quot;&gt;&lt;/com1&gt;parentmsg属性，先在props数组中定义一下，这样才能使用这个数据。 注意： 组件中的所有props中的数据，都是通过 父组件传递给子组件的。props中的数据，都是只的，无法重新赋值。 代码示例：1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;com1 :parentmsg=&quot;msg&quot;&gt;&lt;/com1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;123 啊-父组件中的数据&quot; &#125;, methods: &#123;&#125;, components: &#123; com1: &#123; data() &#123; return &#123; title: &quot;123&quot;, content: &quot;qqq&quot; &#125; &#125;, template: &quot;&lt;h1&gt;这是子组件---&#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;&quot;, props: [&apos;parentmsg&apos;], methods: &#123; change() &#123; this.message = &quot;被修改了!&quot; &#125; &#125; &#125; &#125;, &#125;)&lt;/script&gt; 6.5.2 父组件向子组件传方法 本质：先在子组件上用v-on绑定父组件的方法名字，点击子组件调用子组件的方法，子组件方法的内又调用父组件。这样就达到了父组件向子组件传递方法的目的。【我的理解】 父组件向子组件传递方法，使用的是事件绑定机制；v-on，当自定义了一个事件属性之后，子组件就够通过某些方式来调用传递进去的这个方法了。 &lt;com2 @func=&quot;show&quot;&gt;&lt;/com2&gt;：show是父组件方法的名字 当点击子组件的按钮的时候，如何拿到父组件传递过来的func方法，并调用这个方法？？？ emit 英文原意： 是触发，调用、发射的意思。 this.$emit(@绑定的名字, 要传入父组件方法的数据) 代码示例：123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;app&quot;&gt; &lt;com2 @func=&quot;show&quot;&gt;&lt;/com2&gt;&lt;/div&gt;&lt;template id=&quot;tmp&quot;&gt; &lt;div&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;input @click=&quot;myclick&quot; type=&quot;button&quot; value=&quot;这是子组件中的按钮&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var com2 = &#123; template: &quot;#tmp&quot;, data() &#123; return &#123; songmsg: &#123;name: &apos;小头儿子&apos;, age: 6&#125; &#125; &#125;, methods: &#123; myclick() &#123; this.$emit(&apos;func&apos;,this.songmsg) &#125; &#125; &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; datamsgFormSon: null &#125;, methods: &#123; show(data) &#123; this.datamsgFormSon = data console.log(data); &#125; &#125;, components: &#123; com2 &#125; &#125;)&lt;/script&gt; 6.6 ref获取DOM元素和组件 给标签一个ref属性，可以通过this.$refs.ref属性值获取到这个元素/组件 获取元素及其内容 获取组件及其数据 获取组件并调用组件的方法 7. 路由 安装vue-router路由模块 7.1 什么是路由 注意：组件创建 –&gt; 组件注册 –&gt; 组件渲染 必须按照顺序进行！7.1.1 什么是路由？ 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源。 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现。 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）。 url中的hash(#)：http://www.cnblogs.com/joyho/articles/4430148.html 7.1.2 路由的安装 1、直接下载/CDN：然后用script标签导入 &lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/path/to/vue-router.js&quot;&gt;&lt;/script&gt; 2、npm install vue-router：然后导入模块，通过Vue.use使用 import Vue from ‘vue’ import VueRouter from ‘vue-router’ Vue.use(VueRouter) 7.2 路由的基本使用 1、创建路由对象：var r = new VueRouter({}) routes属性：是一个数组，用来放置所有的路由规则 2、将路由规则对象，注册到vm实例上 用来监听URL地址的变化，然后展示对应的组件 给vm实例对象添加router属性，值为创建的路由对象 —&gt; {router: routerObj} 3、router-link： router-link默认渲染为一个a标签，可以通过tag属性更改 4、router-view： 占位符，用来放置路由规则匹配到的组件 5、代码示例：123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 组件的模板对象 var login = &#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; &#125; var register = &#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125; // 创建路由对象 var routerObj = new VueRouter(&#123; // 路由匹配规则 routes: [ &#123;path: &apos;/&apos;,redirect: &apos;/login&apos;&#125;, &#123;path: &apos;/login&apos;, component: login&#125;, &#123;path: &apos;/register&apos;, component: register&#125; ] &#125;) // 创建vm实例 var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, method: &#123;&#125;, router: routerObj &#125;)&lt;/script&gt; 7.3 路由规则及参数传递 路由规则：每个路由规则都是一个对象且有两个必须的属性。 属性1：path —&gt; 表示监听哪个路由链接地址。 属性2：component —&gt; 表示如果路由是前面匹配到的path，则展示component属性对应的那个组件。 注意：component的属性值必须是一个组件的模板对象，不能是组件的引用名称。 使用query方式传递参数 如果在路由中，使用查询字符串给路由传递参数，则不需要修改路由规则的path属性 &lt;router-link to=&quot;/login?id=10&amp;name=zs&quot;&gt;登录&lt;/router-link&gt; 可以通过this.$route.query.id/name获取到查询字符串，也可以不加this 使用params方式传递参数 在路由规则中传参，在router-link中传值 routes: [{ path: &#39;/login/:id/:name&#39;, component: login }] &lt;router-link to=&quot;/login/12/ls&quot;&gt;登录&lt;/router-link&gt; 可以通过this.$route.params.id/name获取到查询字符串，也可以不加this redirect重定向： {path: ‘/‘,redirect: ‘/login’}：根路径下显示login路径的内容 {path: ‘/‘,redirect: ‘’}：手动在地址栏输入 7.4 设置选中路由高亮显示 方式1： 原理：router-link展示的元素身上有一些默认的类：router-link-exact-active / router-link-active 激活类的默认值是router-link-active 利用类名设置样式 方式2： 在路由对象中用linkActiveClass属性指定类名，设置/修改激活类的值 linkActiveClass: &#39;myactive&#39; 7.5 路由嵌套 1、创建父组件对象和子组件对象 3、创建路由对象 2、注册父组件(routes中的component) 在路由规则中添加children属性，值为包含子组件路由规则的数组 使用children属性实现子路由的同时，子路由的path前面不要带 / ，否则永远以根路径开始请求，这样不方便用户去理解URL地址。 注意：如果不使用children属性，子组件的坑不起作用，会覆盖显示 3、渲染子组件(children中的component) 父组件的模板字符串里渲染子组件 4、渲染父组件 在vm实例绑定的作用域中渲染父组件 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 渲染父组件 &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=&quot;tmp&quot;&gt; &lt;div&gt; &lt;h1&gt;这是account组件&lt;/h1&gt;// 渲染子组件 &lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/account/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;// 创建父子组件对象 var account = &#123; template: &apos;#tmp&apos; &#125; var login = &#123; template: &apos;&lt;h3&gt;这是login组件&lt;/h3&gt;&apos; &#125; var register = &#123; template: &apos;&lt;h3&gt;这是register组件&lt;/h3&gt;&apos; &#125;// 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/account&apos;, component: account,// 在路由规则中添加children属性 children: [ &#123;path:&apos;login&apos;, component: login&#125;, &#123;path:&apos;register&apos;, component: register&#125; ] &#125; ] &#125;) // vm实例对象 var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router: router &#125;) &lt;/script&gt; 7.6 命名视图 使用命名视图可以实现一个页面放置多个组件 代码：1234567891011&lt;router-view&gt;&lt;/router-view&gt; // 默认name为default&lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;routes: [ &#123;path: &apos;/&apos;, components: &#123; &apos;default&apos;: header, &apos;left&apos;: left, &apos;main&apos;: main &#125;&#125;] 7.7 watch监听 在vm实例中添加watch属性(等同于methods)，值是一个对象 对象内部数据以键值对的形式 键：要监听的元素 值：事件处理函数 在监听路由等抽象东西的时候很有优势 7.7.1 监听元素变化 代码示例：12345678watch:&#123; &apos;firstName&apos;: function(newVal, oldVal) &#123; this.name = newVal + &apos;-&apos; + this.lastName &#125;, &apos;lastName&apos;: function(newVal,oldVal) &#123; this.name = this.firstName + &apos;-&apos; + newVal &#125;&#125; 7.7.2 监听路由变化 $route.path: 获取路径 代码示例：123456789watch: &#123; &apos;$route.path&apos;: function(newVal,oldVal) &#123; if(newVal === &apos;/login&apos;) &#123; alert(&apos;欢迎来到登录界面&apos;) &#125; else if(newVal === &apos;/register&apos;) &#123; alert(&apos;欢迎来到登录界面&apos;) &#125; &#125;&#125; 7.8 computed计算属性 在vm实例中添加computed属性(等同于methods)，值是一个对象 对象内部数据以键值对的形式 键：定义一个data中没有的新的变量(需要经计算得到值的变量) 值：事件处理函数(计算类的) 代码示例： 123456789data: &#123; firstName: &apos;&apos;, lastName: &apos;&apos;&#125;,computed: &#123; &apos;name&apos;: function() &#123; return this.firstName + &apos;-&apos; + this.lastName &#125;&#125; 注意1：计算属性在引用的时候，一定不要加 () 去调用，直接把它当作普通属性去使用就好了。 注意2：只要计算属性这个function内部，所用到的任何data中的数据发送了变化，就会立即重新计算这个 计算属性的值。 计算属性的求值结果，会被缓存起来方便下次直接使用； 如果计算属性方法中，任何数据都没有发生过变化，则不会重新对计算属性求值。 7.8.1 watch、computed和methods之间的对比 computed`属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用。 methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体。 8. vue与webpack结合使用8.1 在webpack中导入vue8.1.1 导入完整包处理组件 1、下载安装vue：npm i vue -S 2、把原来的script标签中的vue代码写到入口js文件(main.js)中 3、使用 import Vue from &#39;vue&#39;导入的Vue构造函数功能不完整，只提供了runtime-only的方式，并没有提供像网页中那样的使用方式。解决办法如下： 方式1：1、import Vue from &#39;../node_modules/vue/dist/vue.js&#39;—&gt; 这样导入是完整的 方式2：2、在webpack.config.js文件中添加resolve属性，并做如下配置：(只要修改webpack.config.js配置文件，就需要重新启动项目npm run dev)12345resolve:&#123; alias:&#123; // 修改 Vue 被导入时候的包的路径 &quot;vue$&quot;: &quot;vue/dist/vue.js&quot; &#125;&#125; 4、包的查找规则(解决导入包不完整的方式3) 1、找项目根目录中有没有node_modules 的文件夹 2、在node_modules中根据包名，找对应的 vue 文件夹 3、在vue文件夹中，找一个叫做package.json的包配置文件 4、在package.json文件中，查找一个main属性【main属性指定了这个包在被加载时候，的入口文件】 5、可以修改main属性值去使用完整的包 5、代码示例： 12345678910111213141516import Vue from &apos;vue&apos;// import Vue from &apos;../node_modules/vue/dist/vue.js&apos; 方式1console.log(&apos;ok&apos;);// 方式1和方式2都是以网页的形式创建注册组件的var login = &#123; template: &apos;&lt;h1&gt;这是login组件，是使用网页中形式创建出来的组件&lt;/h1&gt;&apos;&#125;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg:&apos;123&apos; &#125;, components: &#123; login &#125;&#125;) 8.1.2 使用不完整的包处理组件 1、创建一个login.vue文件，包含三部分：&lt;template&gt;、&lt;script&gt;、&lt;style&gt;(组件由模板、业务逻辑、样式三个部分组成) 2、默认webpack无法打包.vue文件，需要安装相关的loader： cnpm i vue-loader vue-template-compiler -D 3、在配置文件中，新增loader配置项 `{ test:/.vue$/, use: ‘vue-loader’ }12345678910111213141516171819202122232425262728293031323334353637// login.vue文件 &lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用.vue文件定义出来的---&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; msg: &quot;123&quot; &#125;; &#125;, methods: &#123; show() &#123; console.log(&quot;调用了login.vue中的show方法&quot;) &#125; &#125; render: function(createElements) &#123; return createElements(login) &#125; &#125; &lt;/stript&gt; &lt;style&gt;&lt;/style&gt;// 入口js文件(main.js)import Vue from &apos;vue&apos; import login from &apos;./login.vue&apos; // 导入组件 var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg:&apos;123&apos; &#125;, // render简写：render: c =&gt; c(login) render: function(createElements) &#123; return createElements(login) &#125; &#125;) 8.2 export default 和 export 的使用方式8.2.1 node中 Node中向外暴露成员的形式：module.exports = {} 在Node中使用 var 名称 = require(&#39;模块标识符&#39;)引入模块 使用module.exports 和 exports 来暴露成员 8.2.2 ES6中 在ES6中，也通过规范的形式，规定了ES6中如何导入和导出模块 ES6中导入模块：使用import 模块名称 from &#39;模块标识符&#39; ， import &#39;表示路径&#39; 在ES6中使用export default和export向外暴露成员：代码示例如下： 12345678var info = &#123; name: &apos;zs&apos;, age: 20&#125;export default info/* export default &#123; address: &apos;北京&apos;&#125; */ 注意1：export default export default 向外暴露的成员，可以使用任意的变量来接收 在一个模块中，export default 只允许向外暴露1次 在一个模块中，可以同时使用 export default 和 export 向外暴露成员 export var title = &#39;小星星&#39; export var content = &#39;哈哈哈&#39; 注意2：export 使用export向外暴露的成员，只能使用 { } 的形式来接收，这种形式叫做 【按需导出】 export可以向外暴露多个成员，同时如果某些成员，在import的时候不需要，则可以不在{}中定义 使用export导出的成员，必须严格按照导出时候的名称，来使用 {} 按需接收； 使用export导出的成员，如果就想换个名称来接收，可以使用as来起别名； 8.3 webpack-vue-router8.3.1 下载安装vue-router 1、下载安装vue：npm i vue-router -S 2、导入入口js文件(main.js)中：import VueRouter from &#39;vue-router&#39; 3、手动安装 VueRouter：Vue.use(VueRouter) 4、创建路由对象 5、将路由对象挂载到vm实例上 以上5步以后并不会显示其它组件，因为不能把router-link和router-view写在#app区域内，会被覆盖掉 6、要把其它路由渲染在app.vue中的app路由的结构中(render函数渲染和路由匹配监渲染要分清除) render渲染：显示区域是el属性控制的区域 路由匹配监听渲染：显示区域是router-view 8.3.2 style标签中的属性 lang属性：在style标签里加lang属性，样式可以写sass/less语法 普通的style标签只支持普通的样式，如果想要启用scss或less，需要为style元素设置lang属性 &lt;style lang&gt;&lt;/style&gt; scoped属性：在style标签里加scoped属性，样式只作用于当前作用域 只要style标签是在.vue组件中定义的，推荐都为style开启scoped属性 &lt;style scoped&gt;&lt;/style&gt; scoped属性的本质是，给div加了一个内部的属性，是通过css的属性选择器实现的。8.3.3 抽离路由模块 新建router.js文件，把路由对象的创建、组件的导入都放入router.js文件中 向外暴露路由对象：export default router]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS2.1之三列布局]]></title>
    <url>%2F2019%2F10%2F21%2FB-21-CSS2.1%E4%B9%8B%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1.布局1.1 圣杯布局1.2 双飞翼布局1.3 粘连布局 思想：将footer固定在最底部（没有滚动条的时候在屏幕的最底部，有滚动条的时候在整个页面的最底部） 做法： a.写出#content和#footer两个div，#content中包裹一个.main； b.首先设置html和body的高度为100%，再设置#content的高度为100%（为了把#footer挤到最下 边） c.设置.main的下内边距padding-bottom = #footer的高度; d.设置#footer的上外边距margin-top = .main的下内边距padding-bottom; 代码： 123456789101112131415161718192021222324&lt;!-- html代码 --&gt; html,body &#123; height: 100% &#125; #content &#123; background-color: pink; min-height: 100%; &#125; #content .main &#123; padding-bottom: 50px; &#125; #footer &#123; height: 50px; margin-top: -50px; background-color: aquamarine; &#125;&lt;!-- html代码 --&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;main&quot;&gt; 文本 &lt;br /&gt;文本 &lt;br /&gt;文本 &lt;br /&gt;文本 &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 2.详细分析2.1 三列布局1 满足条件： 1.两边固定，中间自适应 ---&gt; 1.1 1.2 2.中间列要完整显示 ---&gt; 2.1！只考虑这两点设计出来的三列布局的缺点是：中间列不能够优先渲染，用户体验比较差。 思路： 1.1 每一列用一个div,共分为left、center、right三列； 1.2 用绝对定位（必须相对于初始包含块进行定位），将left和right位置固定； 2.1 给中间列一个内边距 padding = 左右列的width； 代码： 1234567891011121314151617181920212223242526272829&lt;!-- css代码 --&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #left,#right &#123; width: 200px; background-color: pink; &#125; #left &#123; position: absolute; left: 0; top: 0 &#125; #right &#123; position: absolute; right: 0; top: 0; &#125; #center &#123; background-color: aquamarine; padding: 0px 200px; &#125;&lt;/style&gt; &lt;!-- html代码 --&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;center&quot;&gt;center&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; 2.2 三列布局2 满足条件: 1.两边固定，中间自适应 ---&gt; 1.1 2.中间列要完整显示 ---&gt; 3.中间列要优先加载 ---&gt; 3.1 3.2！这样设计出来的三列布局的缺点是：中间列与左右两边的列直接有重叠，结构不干净。 思路： 1.1 每一列用一个div,共分为left、center、right三列； 3.1 使用浮动将left和right放到相应的位置； 3.2 使用浮动以后，由于left、center、right依次放置的，所以right浮不上去 1.为了保持左右一致，调换位置让两个都浮上去。(布局好了，但并没有达到想要的效果) 2.为了保持左右一致，调换位置让两个都浮不上去。—&gt; 为圣杯布局做准备 代码： 12345678910111213141516171819202122232425&lt;!-- css代码 --&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #left,#right &#123; width: 200px; background-color: pink; &#125; #left &#123; float: left; &#125; #right &#123; float: right; &#125; #center &#123; background-color: aquamarine; padding: 0px 200px; &#125;&lt;/style&gt; &lt;!-- html代码 --&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;center&quot;&gt;center&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; 2.3 圣杯布局 满足条件: 1.两边固定，中间自适应---&gt; 1.1 1.2 2.中间列要完整显示---&gt; 2.1 3.中间列要优先加载---&gt; 3.1 3.2 思路： 1.1 每一列用一个div,共分为left、center、right三列； 3.1 使用浮动将left和right放到相应的位置； 3.2 使用浮动以后，由于left、center、right依次放置的，所以right浮不上去 2.为了保持左右一致，调换位置让两个都浮不上去。 3.3 让中间也浮动，把中间的宽度设置为100%,此时左右两边仍然像刚开始那样（两个都浮不上去）。 3.4 此时浮不上去是因为宽度不够了，所以利用margin-left(左外边距)为负值让三列布局到一行上。 3.5 使两边的列与中间的列没有重复。 1.给包裹三列布局的div一个左右的内边距（padding：0 左右两列的宽度） 2.使用相对定位：调整旁边两列的位置（使两列位置调整到两头）。 4.最后，设置页面（body）的最小宽度：min-width: (2 * (left宽 + right宽))px; ！这样设计出来的三列布局的缺点是：左右两列的高度与中间列的高度不能够同步改变。 5.使用伪等高布局原理实现高度同步： 1.设置左中右三列的padding-bottom: 10000px;用下内边距撑开高度需要同步的几个元素 2.设置左中右三列的margin-bottom: -1000px;再用负的下外边距收回盒子底部。 3.给包裹左中右三列的父div设置overflow: hidden; 伪等高原理: 用浮动使元素在同一列 padding-bottom: 10000px;用下内边距撑开高度需要同步的几个元素 margin-bottom: -1000px;再用负的下外边距收回盒子底部 给包裹的父div设置overflow: hidden; 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &lt;!-- css代码 --&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; min-width: 600px; &#125; #header &#123; background-color: aqua; text-align: center; border: 1px solid deeppink; &#125; #footer &#123; background-color: gray; text-align: center; border: 1px solid deeppink; &#125; #content &#123; padding: 0px 200px; overflow: hidden; &#125; #content .left ,#content .right&#123; background-color: pink; width: 200px; &#125; #content .center,#content .left,#content .right&#123; padding-bottom: 10000px; margin-bottom: -10000px;&#125; #content .left &#123; position: relative; left: -200px; float: left; margin-left: -100%; &#125; #content .right &#123; position: relative; right: -200px; float: right; margin-left: -200px; &#125; #content .center &#123; float: left; width: 100%; background-color: aquamarine; &#125; .clearfix:after &#123; content: &quot;&quot;; display: table; clear: both; &#125; &lt;/style&gt; &lt;!-- html代码 --&gt; &lt;div id=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div id=&quot;content&quot; class=&quot;clearfix&quot;&gt; &lt;div class=&quot;center&quot;&gt;center&lt;/div&gt; &lt;div class=&quot;left&quot;&gt; left&lt;br /&gt;left&lt;br /&gt;left&lt;br /&gt;left &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 2.4 双飞翼布局 满足条件： 同圣杯布局 思路： 同圣杯布局思路（只有3.5不同） 3.5 在center的里面放置一个div（.inner）用来放内容： 1.设置其内边距padding: 0 -200px; 2.或者设置其外边距margin: 0 -200px; 代码： 同圣杯布局代码,只需做如下修改：1234567891011&lt;!-- 添加如下css代码 --&gt;#content .center .inner &#123; /* margin: 0px 200px; */ padding: 0px 200px; &#125;&lt;!-- 修改html代码中center的结构 --&gt;&lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;inner&quot;&gt; center里的inner &lt;/div&gt; &lt;/div&gt; 3.其它布局3.1 两列布局 左侧浮动，右侧宽度自适应。 应用场景：商品展示（商品一列，描述一列） 1.图片一列，描述一列(两列布局：一列浮动，一列只给高度) 2.将图片设置为左列的背景图片(方便调位置：background-position: 水平值 垂直值;)，右列放置文字说明（设置display: inline-block;,这样说明文字不会环绕在图片的右侧，只会出现在图片下方） 3.给右列设置文字过长的用省略号代替(这样的话就必须给右列设置高度)： white-space: nowrap; overflow: hidden; text-overflow:ellipsis; 包裹区域必须不能让子元素去撑开]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS2.1</category>
      </categories>
      <tags>
        <tag>三列布局</tag>
        <tag>粘连布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本操作]]></title>
    <url>%2F2019%2F10%2F21%2FF-04-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[0. 什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。 源代码有必要管理起吗？ 1.0、2.0 … 人工的去处理不同的版本，做相应备份会很麻烦。 svn、vss、vcs、…、 git Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus linus自己写了一个版本管理的工具(Git) 1. Git安装 git仓储有三个区：工作区、暂存区、版本库。 2. 初始化Git仓储/(仓库) 这个仓库会存放，git对项目代码进行备份的文件。 在项目目录右键打开 git bash。 命令：git init 所有的备份文件都在初始化的.git文件中(这个文件夹是隐藏的) 3. 自报家门 就是在git中设置当前使用的用户是谁。 命令： 配置用户名：git config --global user.name &quot;用户名&quot; 配置邮箱：git config --global user.email &quot;邮箱&quot; 4. 把代码存储到.git仓储中4.4.1 把代码放到仓储的门口(暂存区) git add ./文件名：把指定的文件放到门口 git add ./：把当前目录下的所有修改都放到门口 4.4.2 把仓储门口的代码放到里面的房间中去 git commit -m &quot;对这次添加内容的说明&quot; 不加 -m 会进入另外一种模式(进入编辑器的状态) 进行编辑：按一下 i 退出：按Esc -&gt; 按英文分号 -&gt; q -&gt; 回车 强制退出：按Esc -&gt; 按英文冒号 -&gt; q -&gt; !(英文) 4.4.3 也可以一次性把修改的代码放到房间里(版本库)。 git commit --all &quot;说明&quot;：单独使用即可 all 表示把所有修改的文件提交到版本库。 5. 查看当前的状态 命令：git status 可以用来查看当前代码有没有被放到仓储中去。 一共有三种状态： 红色：工作区的代码没有放入暂存区，更没有到版本库中。 绿色：工作区的代码放入了暂存区，还没有保存到版本库。 工作区干净 (版本库保存的代码与工作区的代码一致)。 6. git中的忽略文件 .gitignore,在这个文件中可以设置要被忽略的文件或者目录。 被忽略的文件不会被提交到仓储里去。 在.gitignore中可以书写要被忽略的文件的路径。以/开头，一行写一个路径，这些路径所对应的文件都会被忽略，不会被提交到仓储中去。 写法： /.idea 会忽略.idea文件 /js 会忽略js目录里的所有文件 /js/*.js 会忽略js目录下的所有js文件 7. 查看日志 git log 查看历史提交的日志。 git log --oneline 可以看到简洁版的历史提交日志 就是查看提交过的历史（每一次提交的东西都会被git备份）。 8. 回退到指定的版本 Head默认指向最新版本。(点击右键可以复制粘贴) git reset --hard Head~0 表示回退到上一次代码提交时的状态。（当前代码） git reset --hard Head~1 表示回退到上上次代码提交时的状态。 git reset --hard 版本号（推荐使用） 可以通过版本号精确的回退到某一次提交时的状态。 需要先查看日志，然后看每一个日志前面的版本号(每个版本号都是唯一的)。 git reflog 可以看到每一次切换版本的记录：可以看到所有提交的版本号。 9. 分支 默认是有一个主分支 master。 9.1 创建分支 git branch dev 创建了一个dev分支。 在刚创建的dev分支里的东西和master分支里的东西是一样的。 9.2 切换分支 git checkout dev 切换到指定的分支，这里切换到名为dev的分支。 git branch 可以查看所有的分支以及当前所在的分支。 9.3 合并分支 git merge dev 合并分支内容，把当前分支与指定的分支(dev)，进行合并。 当前分支是指 git branch 命令输出的前面有*号的分支 conflict：合并时如果有冲突，需要手动去处理，处理还需要再提交一次。 两个分支都做了修改，合并分支时就会出现冲突 手动处理：git会自动合并冲突，然后需要自己去那个文件里面看哪个内容需要就留下，不需要的就手动从文件内容里面删除，然后再存储。9.4 删除分支 git branch -d dev 删除指定的分支，这里删除名为dev的分支。 不能删除当前所在的分支 10. GitHub https://github.com 不是git，只是一个网站 只不过这个网站提供了允许别人通过git上传代码的功能 10.1 github准备工作 在github中新建一个仓库(用来存储项目),仓库新建好之后有一个地址(点击HTTP会显示)，后面内容中的 [地址1] 为这个地址。 ! 用这个地址需要输入账号密码，可能会不安全，也比较麻烦，所以还可以使用密钥。 在github中新建一个密钥，将用git生成的密钥中的公钥文件中的内容添加到github中新建的密钥中。这个密钥也有一个地址(点击SSH会显示)，后面内容中的 [地址2] 为这个地址。 10.2 提交代码到github(当作git服务器来使用) git push 地址1 master 示例：git push https://github.com/geekying/test11.git master 会把当前分支的内容传到远程的master分支上 git pull 地址1 master 示例：git pull https://github.com/geekying/test11.git master 会把远程分支(master)的数据得到：(注意本地要初始化一个仓库) git clone 地址1 会得到远程仓储相同的数据，如果多次执行会覆盖本地内容。 10.3 ssh方式上传代码 公钥(.pub)、私钥，两者之间是有关联的。 用git生成公钥和私钥： ssh-keygen -t rsa -C &quot;邮箱&quot; 上传代码或者获取数据： git push 地址2 master git pull 地址2 master git clone 地址2 master 10.4 更简洁的上传方式 git remote add origin 地址2 添加一个远程地址。 将地址用一个变量(这里用的origin)代替 git push origin -u master 在push时，加上-u参数，那么再下一次push时，就只需要写git push就能上传代码。 加上-u之后，git会把当前分支与远程的分支进行关联。 上传代码或者获取数据： git push git pull git clone10.5 多人开发 先初始化一个项目 —&gt; git init 拿已有的代码 —&gt; git clone / git pull 自己修改以后要先在本地提交 git add ./ git commit –all “说明” 再放到GitHub —&gt; git push10.5 在push和pull操作冲突时 先pull,再push。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之面试题]]></title>
    <url>%2F2019%2F10%2F15%2FB-11-CSS3%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. css基本问题 CSS名字：层叠样式表 CSS全拼：Cascading Style Sheets 样式表的组成： – 样式表由 规则 组成 – 规则由 选择器+声明块 组成 – 声明块由 一条一条的 声明 组成 – 声明由 CSS合法的属性名+属性值 组成 浏览器渲染样式表的顺序：从右往左 – 原因：算法的复杂程度低，性能比较高 阐述对CSS选择器优先级的的理解： ！详细说明见 CSS3之选择器 中的3.css声明的优先级。 CSS声明的优先级（CSS选择器的优先级说法是是错误的） 层叠：先按来源进行刷选；如果来源相同，按选择器的特殊性继续刷选；选择器的特殊性如果相同，按顺序继续刷选。 2. 用css做选项卡 用target伪类 代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;!-- css代码： --&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; a &#123; text-decoration: none; color: paleturquoise; &#125; div &#123; background-color:pink; width: 100px; height: 100px; text-align: center; font: bold 20px/100px &quot;微软雅黑&quot;; /* 大小和字体必须写在最后 */ display:none; &#125; :target &#123; display: block; &#125;&lt;/style&gt;&lt;!-- html代码： --&gt;&lt;body&gt; &lt;a href=&quot;#div1&quot;&gt;div1&lt;/a&gt; &lt;a href=&quot;#div2&quot;&gt;div2&lt;/a&gt; &lt;a href=&quot;#div3&quot;&gt;div3&lt;/a&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;&lt;/body&gt; 3. 制作自定义按钮 用表单伪类checked 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- css代码： --&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; label &#123; float: left; &#125; label&gt;span &#123; display: inline-block; width: 100px; height: 100px; background-color: aqua; border-radius: 50%; &#125; input &#123; display: none; &#125; input:checked + span &#123; background-color: pink; &#125; &lt;/style&gt; &lt;!-- html代码： --&gt; &lt;body&gt; &lt;label &gt; &lt;input type=&quot;radio&quot; name=&quot;zi&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label &gt; &lt;input type=&quot;radio&quot; name=&quot;zi&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label &gt; &lt;input type=&quot;radio&quot; name=&quot;zi&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;/body&gt; 4. 导航栏最后一个不加边框 用not伪类 代码如下： 12345678910111213141516171819202122232425&lt;!-- css代码： --&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; float: left; padding: 0px 10px; &#125; li:not(:last-of-type) &#123; border-right: 1px solid pink; &#125; &lt;/style&gt; &lt;!-- html代码： --&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;first&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;second&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;third&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;fourth&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;fifth&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 5. css3中的过渡5.1 第一是对过渡的介绍 主要有过渡时间、过渡样式、过渡形式、延迟时间 4 个样式。 总结的需要注意的地方有： 不是所有的属性都有过渡，比如：如果元素设置了display: none;，身上的过渡就不会发生。 过渡时间一定要加单位，否则整个过渡机制可能失效（当你是一个列表的时候，设置0，就会失效）。 当属性值的列表长度不一致时： 超出的情况下是会被全部截掉的！ 不够的时候，关于时间的会重复列表，过渡形式会使用默认值(ease)！ 5.2 对过渡中的一些坑的了解 坑1：鼠标移入之后添加一个新的过渡： 在鼠标移入后，新的过渡会触发；旧的过渡不会触发，旧的属性变化会在瞬间完成。 在鼠标移出后，旧的过渡会触发；新的过渡不会发生。 坑2：transition在元素首次渲染还没有结束的情况下是不会被触发的。 6.css3中的2d变形6.1 第一是对2d变形的介绍 主要有旋转(rotate)、平移(translate)、倾斜(skew)、缩放(scale)、基点的变换(transform-origin) 5 个样式。 transform 属性只对块级元素(一般都是div)生效，一般配合过渡使用。 其中平移一定要带单位。 6.2 第二就是变换组合 变换组合的顺序不同，变换结果不同。因为这些变换的底层原理是矩阵，矩阵的变换是不可逆的。 变换组合时，计算方向时从右向左的，也是矩阵的一些计算。 7.css3中的3d变形7.1 第一是对3d变形的介绍 主要有旋转、平移、缩放、景深、transform-style、 backface-visibility六点，3d变形中没有倾斜，因为它是没有意义的。 7.2 注意点 其中旋转包括4个功能函数：绕x轴旋转、绕y轴旋转、绕z轴旋转、3d旋转(3d旋转就是绕着圆心到指定点所形成的射线进行旋转)。 平移有X、Y、Z三种，其中translateZ()是不能用百分比的。 缩放有X、Y、Z、3d四种，单独使用scaleZ()是没有意义的(变换组合时，把它放在最前面也没有用（无意义）。) 景深： 是能够让3d场景有远大近小的效果的一个属性，不可继承，但可以作用于后代元素，使用时一般不作用于自身。 景深越大，灭点越远，元素变形越小；景深越小，灭点越近，元素变形越明显。 景深的基点perspective-origin是有默认值的，为：perspective-origin: 50% 50%;。 景深的叠加： 叠加：爷父子三个元素中，如果爷父都设置的有景深，作用到子身上以后不是父身上的景深了，而是会进行叠加。 要尽量避免景深叠加！因为不同的浏览器叠加计算的方式不同。 transform-style是一个用于营造有层级的3d舞台的属性，不可继承，但作用于子元素（只是子元素，而不是后代元素）。！就是景深负责远大近小，它负责层次感。 backface-visibility：是否显示元素的背面，默认是显示的。hidden和visible。 8.css3中的动画8.1 第一是对动画的介绍8.2 第二是注意点]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之新增UI方案]]></title>
    <url>%2F2019%2F10%2F14%2FB-10-CSS3%E4%B9%8B%E6%96%B0%E5%A2%9EUI%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1. 文本新增属性1.1 opacity opacity属性指定了一个元素的透明度。 默认值：1.0 不可继承 可以简写为.1~.9，1.0是不透明，0是完全透明，值越小透明度越高。 1.2 rgba rgba(0,0,0,.8); 应用场景：背景透明文字不透明 1.3 文字阴影 text-shadow用来为文字添加阴影，而且可以添加多层，阴影值之间用逗号隔开。（多个阴影时，第一个阴影在最上边） 默认值：none 不可继承 值： – &lt;color&gt;可选。可以在偏移量之前或之后指定。如果没有指定颜色，则使用UA（用户代理）选择的颜色。 – &lt;offset-x&gt; &lt;offset-y&gt;必选。这些长度值指定阴影相对文字的偏移量。 ！ \&lt;offset-x&gt; 指定水平偏移量，若是负值则阴影位于文字左边。 ！ \&lt;offset-y&gt; 指定垂直偏移量，若是负值则阴影位于文字上面。 ！ 如果两者均为0，则阴影位于文字正后方(如果设置了\&lt;blur- radius&gt; 则会产生模糊效果)。 – &lt;blur-radius&gt;可选。这是 &lt;length&gt; 值。如果没有指定，则默认为0。值越大，模糊半径越大，阴影也就越大越淡。 应用场景： – 浮雕文字 123456h1&#123; text-align: center; font: 100px/200px &quot;微软雅黑&quot;; color: white; text-shadow: black 1px 1px 100px;&#125; – 文字模糊 1234567891011h1&#123; text-align: center; font: 100px/200px &quot;微软雅黑&quot;; color: black; transition: 1s;&#125;h1:hover&#123; color: rgba(0,0,0,0); text-shadow: black 0 0 200px;&#125; – 模糊背景 12345678910111213141516171819202122232425262728&lt;!-- css代码 --&gt;#wrap&#123; height: 100px; background: rgba(0,0,0,.5); position: relative;&#125;#wrap #bg&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; background: url(img/avatar.jpg) no-repeat; background-size:100% 100% ; z-index: -1; filter: blur(10px);&#125;img&#123; margin: 24px 0 0 24px;&#125;&lt;!-- html代码 --&gt;&lt;div id=&quot;wrap&quot;&gt; &lt;img src=&quot;img/avatar.jpg&quot; width=&quot;64px&quot; height=&quot;64px&quot;/&gt; &lt;div id=&quot;bg&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1.4 文字描边 只有webkit内核才支持：-webkit-text-stroke（准确的来说不能算是css3的东西，但需要知道） -webkit-text-stroke: blue 4px;，描边里面的文字颜色可以设置为透明色rgba(0,0,0,0) 1.5 文字排版 direction:控制文字的方向(ltr/rtl)。 一定要配合unicode-bidi:bidi-override;来使用 text-overflow :确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号（’…’）。 应用场景：文字溢出显示省略号 – white-space: nowrap; – overflow: hidden; – text-overflow: ellipsis; – 包裹区域必须不能让子元素撑开。 – 设置text-overflow: ellipsis;时，div的文字外面不能包裹p标签，否则文字只会溢出隐藏并不会显示省略号。（我自己加的） 1234567891011121314 &lt;!-- css代码 --&gt;div&#123; width: 200px; height: 200px; border: 1px solid; margin: 0 auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; &lt;!-- html代码 --&gt; &lt;div&gt;wcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcywcy&lt;/div&gt; 2. 盒模型新增属性2.1 盒模型阴影 box-shadow ： – 以逗号分割列表来描述一个或多个阴影效果，可以用到几乎任何元素上。 – 如果元素同时设置了 border-radius ，阴影也会有圆角效果。多个阴影时和多个 text-shadow 规则相同(第一个阴影在最上面)。 默认值: none 不可继承 值： – inset：默认阴影在边框外。使用inset后，阴影在边框内。 – &lt;offset-x&gt; &lt;offset-y&gt;：这是头两个 &lt;length&gt; 值，用来设置阴影偏移量。 ! \&lt;offset-x&gt; 设置水平偏移量，如果是负值则阴影位于元素左边。 ! \&lt;offset-y&gt; 设置垂直偏移量，如果是负值则阴影位于元素上面。 ! 如果两者都是0，那么阴影位于元素后面。这时如果设置\&lt;blur-radius&gt; 或\&lt;spread-radius&gt; 则有模糊效果。– &lt;blur-radius&gt;：这是第三个 &lt;length&gt; 值。值越大，模糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。 – &lt;spread-radius&gt;：这是第四个 &lt;length&gt; 值。取正值时，阴影扩大（阴影覆盖到元素上的距离）；取负值时，阴影收缩（阴影藏在元素下面的距离）。默认为0，此时阴影与元素同样大。 – &lt;color&gt;：阴影颜色，如果没有指定，则由浏览器决定。 2.2 盒模型倒影 -webkit-box-reflect : 设置元素的倒影（准确的来说不能算是css3的东西，但需要知道） 默认值:none 不可继承 值：（必须是123的顺序） – 倒影的方向：(第一个值) above, below, right, left– 倒影的距离：(第二个值) 长度单位– 渐变：(第三个值，可选值，可以不设置) 2.3 盒模型resize resize ：CSS 属性允许你控制一个元素的可调整大小性。 （一定要配合overflow：auto使用） 默认值：none 不可继承 值： – none：元素不能被用户缩放。 – both：允许用户在水平和垂直方向上调整元素的大小。 – horizontal：允许用户在水平方向上调整元素的大小。 – vertical：允许用户在垂直方向上调整元素的大小。 2.4 box-sizing(怪异盒模型) box-sizing属性定义了用户代理应该如何计算一个元素的总宽度和总高度。 可取值： box-sizing: border-box; border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。注意: border-box不包含margin。 box-sizing: content-box; 默认值，标准盒子模型。width 与 height只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距、边框和外边距都在这个盒子的外部。 box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。 默认值：content-box 不可继承 3. 新增UI样式3.1 圆角 传统的圆角生成方案，必须使用多张图片作为背景图案。 CSS3圆角的出现，使得我们再也不必浪费时间去制作这些图片了，而且还有其他多个优点： 减少维护的工作量。图片文件的生成、更新、编写网页代码，这些工作都不再需要了。 提高网页性能。由于不必再发出多余的HTTP请求，网页的载入速度将变快。 增加视觉可靠性。某些情况下（网络拥堵、服务器出错、网速过慢等等），背景图片会下载失败，导致视觉效果不佳。CSS3就不会发生这种情况。 border-radius：用来设置边框圆角。当使用一个半径时确定一个圆形；当使用两个半径时确定一个椭圆，这个(椭)圆与边框的交集形成圆角效果。 默认值 : 0 不可继承 值： 固定的px值定义圆形半径或椭圆的半长轴，半短轴。不能用负值 使用百分数定义圆形半径或椭圆的半长轴，半短轴。水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度。不能用负值 这是一个简写属性，用来设置 – border-top-left-radius, – border-top-right-radius, – border-bottom-right-radius, – border-bottom-left-radius 半径的第一个语法取值可取1~4个值: – border-radius: radius – border-radius: top-left-and-bottom-right top-right-and-bottom-left – border-radius: top-left top-right-and-bottom-left bottom-right – border-radius: top-left top-right bottom-right bottom-left 半径的第二个语法取值也可取1~4个值 – border-radius: (first radius values) / radius– border-radius: (first radius values) / top-left-and-bottom-right top-right-and-bottom-left – border-radius: (first radius values) / top-left top-right-and-bottom-left bottom-right – border-radius: (first radius values) / top-left top-right bottom-right bottom-left 注意 ! 百分比值: – 在旧版本的 Chrome 和 Safari 中不支持。(fixed in Sepember 2010) – 在 11.50 版本以前的 Opera 中实现有问题。 – Gecko 2.0 (Firefox 4) 版本前实现不标准：水平半轴和垂直半轴都相对于盒子模型的宽度。 – 在旧版本的 iOS (iOS 5 之前) 和 Android 中 (WebKit 532 之前) 不支持。 3.2 边框图片 border-image： CSS属性允许在元素的边框上绘制图像。 – 这使得绘制复杂的外观组件更加简单，使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式。 默认值： 不可继承 – border-image-source: none – border-image-slice: 100% – border-image-width: 1 – border-image-outset: none – border-image-repeat: stretch 3.3 背景3.3.1 css2 默认情况下，背景图片是从padding开始绘制的，超出的部分是从border开始剪裁的。背景颜色是除了margin。 background-color background-color 会设置元素的背景色。 默认值： transparent 不可继承 background-image background-image属性用于为一个元素设置一个或多个背景图像，图像在绘制时，以z轴方向堆叠的方式进行。先指定的图像会在之后指定的图像上面进行绘制。 注意：background-color会在image之下进行绘制，边框和内容会在image之上进行绘制。 默认值：none 不可继承 background-image可以设置多个背景图片，用逗号隔开[url(img1), url(img2)]； background-repeat background-repeat CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。 默认值：repeat 不可继承 值： – repeat-x = repeat no-repeat – repeat-y = no-repeat repeat – repeat = repeat repeat – no-repeat = no-repeat no-repeat – 第一个值代表水平方向。 – 第二个值代表垂直方向。 background-position background-position属性 ：指定背景位置的初始位置 默认值：0% 0% 不可继承 值： 数值：单位是px。正值右移下移，负值左移上移。 百分比：参照尺寸为背景图片定位区域的大小减去背景图片的大小【(盒子的宽高 - 图片的宽高) * 设置的百分比 = 数值（xxx px）】（不是参照图片也不是参照盒子）。 – 第一个值：元素在水平方向的位移。 – 第二个值：元素在垂直方向的位移 关键字： – top left and left top (！Same as ‘0% 0%’.) – top, top center, and center top (！Same as ‘50% 0%’.) – right top and top right (！Same as ‘100% 0%’.) – left, left center, and center left (！Same as ‘0% 50%’.) – center and center center (！Same as ‘50% 50%’.) – right, right center, and center right (！Same as ‘100% 50%’.) – bottom left and left bottom (！Same as ‘0% 100%’.) – bottom, bottom center, and center bottom (！Same as ‘50% 100%’.) – bottom right and right bottom (！Same as ‘100% 100%’.) 如果只有一个值被指定，则这个值就会默认设置背景图片位置中的水平方向，与此同时垂直方向的默认值被设置成50%。 background-attachment background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。 默认值：scroll 不可继承 值： – fixed：此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。 – scroll：此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动。 3.3.2 css3 background-origin：设置背景的渲染的起始位置 border-box padding-box content-box background-clip：设置背景裁剪位置 取值：border-box 、padding-box、content-box、text 取值为text时，是从文本开始，要配合使用。 background-clip: text; -webkit-background-clip: text; color: transparent;颜色透明，这个不是必须的 background-size background-size：设置背景图片大小 默认值：auto auto 不可继承 值： – 百分比： 指定背景图片相对背景区（background positioning area）的百分比。 – 背景区由background-origin设置，默认为盒模型的内容区与内边距。 – auto：以背景图片的比例缩放背景图片。 注意： ！单值时，这个值指定图片的宽度，图片的高度隐式的为auto。 ！两个值: 第一个值指定图片的宽度，第二个值指定图片的高度 。 background background是CSS简写属性，用来集中设置各种背景属性。 background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat, background-size, background-attachment。 默认值：不可继承 – background-image: none – background-position: 0% 0% – background-size: auto auto – background-repeat: repeat – background-origin: padding-box – background-clip: border-box – background-attachment: scroll – background-color: transparent ！ 顺序无关 3.4 渐变3.4.1 概述 CSS 渐变 是在 CSS3 Image Module 中新增加的图片类型；使用 CSS 渐变可以在两种颜色间制造出平滑的渐变效果. 用它代替图片，可以加快页面的载入时间、减小带宽占用。同时，因为渐变是由浏览器直接生成的，它在页面缩放时的效果比图片更好，因此你可以更加灵活、便捷的调整页面布局。 浏览器支持两种类型的渐变：线性渐变 (linear)，通过 linear-gradient 函数定义，以及 径向渐变 (radial)，通过 radial-gradient 函数定义. 3.4.2 分类 线性渐变 为了创建一个线性渐变，需要设置一个起始点和一个方向（指定为一个角度）。 还要定义终止色。终止色就是你想让浏览器去平滑的过渡过去，并且必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。 默认从上到下发生渐变：background-image: linear-gradient(red,blue); 改变渐变方向：（top bottom left right） linear-gradient(to 结束的方向,red,blue); 使用角度：linear-gradient(角度,red,blue); 颜色节点的分布（第一个不写为0%，最后一个不写为100%）：linear-gradient(red 长度或者百分比,blue 长度或者百分比); 重复渐变： repeating-linear-gradient(60deg,red 0,blue 30%); 径向渐变 radial-gradient() 函数创建一个&lt;image&gt;，用来展示由原点（渐变中心）辐射开的颜色渐变 默认均匀分布: radial-gradient(red,blue); – 不均匀分布：radial-gradient(red 50%,blue 70%); 改变渐变的形状：radial-gradient(circle ,red,blue); – circle – ellipse（默认为椭圆） 渐变形状的大小(size): – radial-gradient(closest-corner circle ,red,blue) – closest-side 最近边 – farthest-side 最远边 – closest-corner 最近角 – farthest-corner 最远角 （默认值） 改变圆心：radial-gradient(closest-corner circle at 10px 10px,red,blue); 渐变使用总结：background-image:radial-gradient(大小 圆心/形状,颜色1 距离/百分比,颜色2 距离/百分,颜色3 距离/百分... );]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>css新增UI方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之自定义字体]]></title>
    <url>%2F2019%2F10%2F14%2FB-09-CSS3%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[1. 自定义字体 @font-face:允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face可以消除对用户电脑字体的依赖。 font-family– 所指定的字体名字将会被用于font或font-family属性。 src– 字体资源 ！注意：不能在一个CSS选择器中定义@font-face 2. 字体图标 1.Adobe illustrator – AI是一种应用于出版、多媒体和在线图像的工业标准矢量插画的软件，是一款非常好的矢量图形处理工具。 – 该软件主要应用于印刷出版、海报书籍排版、专业插画、多媒体图像处理和互联网页面的制作等。 – 也可以为线稿提供较高的精度和控制，适合生产任何小型设计到大型的复杂项目 2.FontLab – FontLab是一个专业级的字体编辑软件，广泛应用于字体 设计人员和排版印刷业等专业场合。 – 它能够对已有的字体进行修改，也可以完全按照要求 重新设计需要的字体。 – 字体兼容处理网站： https://www.fontsquirrel.com/tools/webfont-generator – icomoon字体图标 https://icomoon.io/#home 3.字体图标基本思路 – 设计一套矢量图 – 将不同的矢量图绑定到不同的字符上生成自定义字体 – 一般通过工具或者站点来处理 – 在页面中运用]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>css自定义字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之选择器]]></title>
    <url>%2F2019%2F10%2F14%2FB-08-CSS3%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.相关地址 CSS3选择器规范地址：https://www.w3.org/TR/2011/REC-css3-selectors-20110929/ CSS3选择最新选择器规范: https://www.w3.org/TR/selectors 2.各种选择器 2.1 基本选择器 通配符选择器： * { margin: 0; padding: 0; border: none; } 元素选择器： body { background: #eee; } 类选择器： .list { list-style: square; } ID选择器：#list { width: 500px; margin: 0 auto; } 后代选择器：.list li { margin-top: 10px; background: #abcdef; } 2.2 基本选择器扩展 子元素选择器：#wrap &gt; .inner {color: pink;} – 也可称为直接后代选择器,此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素。 相邻兄弟选择器：#wrap #first + .inner {color: #f00;} – 它只会匹配紧跟着的兄弟元素。 通用兄弟选择器：#wrap #first ~ div { border: 1px solid;} – 它会匹配所有的兄弟元素(不需要紧跟)。 选择器分组：h1,h2,h3{color: pink;} – 此处的逗号我们称之为结合符。 2.3 属性选择器 存在和值属性选择器 – [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。 – [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。 – [attr~=val]：表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为val。 子串值属性选择器 – [attr|=val] : 选择attr属性的值是val（包括val）或以val-开头的元素。 – [attr^=val] : 选择attr属性的值以val开头（包括val）的元素。 – [attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。 – [attr*=val] : 选择attr属性的值中包含字符串val的元素。 2.4 伪类与伪元素选择器 链接伪类：注意:link，:visited，:target是作用于链接元素的！ – :link 表示作为超链接，并指向一个未访问的地址的所有锚。 – :visited 表示作为超链接，并指向一个已访问的地址的所有锚。 – :target 代表一个特殊的元素，它的id是URI的片段标识符 动态伪类：注意:hover，:active基本可以作用于所有的元素！ – :hover 表示悬浮到元素上。 – :active 表示匹配被用户激活的元素（点击按住时）。 – 由于a标签的:link和:visited可以覆盖了所有a标签的状态，所以当:link，:visited，:hover，:active同时出现在a标签身上时 :link和:visited不能放在最后！！！ – :visited选择器只有下列的属性才能被应用到已访问链接： color background-color border-color 表单相关伪类 – :enabled 匹配可编辑的表单。 – :disable 匹配被禁用的表单。 – :checked 匹配被选中的表单。 – :focus 匹配获焦的表单。 结构性伪类 ！ index的值从1开始计数！！ ！index可以为变量n(只能是n) ！index可以为even odd #wrap ele:nth-child(index) 表示匹配#wrap中第index的子元素 这个子元素必须是ele。 #wrap ele:nth-of-type(index) 表示匹配#wrap中第index的ele子元素。 除此之外:nth-child和:nth-of-type有一个很重要的区别：nth-of-type以元素为中心！！！ :nth-child(index)系列 – :first-child – :last-child – :nth-last-child(index) – :only-child (相对于:first-child:last-child 或者 :nth-child(1):nth-last-child(1)) :nth-of-type(index)系列 – :first-of-type – :last-of-type – :nth-last-type(index) – :only-of-type (相对于:first-of-type:last-of-type 或者 :nth-of-type(1):nth-last-of-type(1)) – :not -- :empty(内容必须是空的，有空格都不行，有attr[属性]没关系) 根元素伪类选择器 – ：root (有的根元素为html,有的为body) 伪元素 – ::after – ::before – ::firstLetter – ::firstLine – ::selection ! 一个元素只有两个伪元素(before 和 after) ！伪元素选择器建议写两个冒号。 3. css声明的优先级3.1 选择器的特殊性 选择器的特殊性由选择器本身的组件确定，特殊性值表述为4个部分，如 0,0,0,0。 一个选择器的具体特殊性如下确定： – 1.对于选择器中给定的ID属性值，加 0,1,0,0。 – 2.对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0。 – 3.对于选择器中的给定的各个元素和伪元素，加0,0,0,1。 – 4.通配符选择器的特殊性为0,0,0,0。 – 5.结合符对选择器特殊性没有一点贡献。 – 6.内联声明的特殊性都是1,0,0,0。 – 7.继承没有特殊性 ！特殊性 1,0,0,0 大于所有以0开头的特殊性(不进位)。 ！选择器的特殊性最终都会授予给其对应的声明。 ！如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性越大的越占优势。 ！注意：id选择器和属性选择器： div[id=”test”]（0,0,1,1） #test（0,1,0,0） 3.2 重要声明 有时某个声明比较重要，超过了所有其他声明，css2.1就称之为重要声明，并允许在这些声明的结束分号之前插入 !important 来标志。 必须要准确的放置 !important 否则声明无效。 !important 总是要放在声明的最后，即分号的前面。 标志为 !important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决。 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决。 如果一个重要声明与非重要声明冲突，胜出的总是重要声明。 3.3 继承 继承没有特殊性，甚至连0特殊性都没有。 0特殊性要比无特殊性来的强。 3.4 来源 css样式的来源大致有三种 – 创作人员 – 读者 – 用户代理 权重： – 读者的重要声明 – 创作人员的重要声明 – 创作人员的正常声明 – 读者的正常声明 – 用户代理的声明 3.5 层叠 找出所有相关的规则，这些规则都包含一个选择器。 计算声明的优先级 – 先按来源排序 – 在按选择器的特殊性排序 – 最终按顺序]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>css选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS2.1之CSS Hack]]></title>
    <url>%2F2019%2F10%2F11%2FB-07-CSS%E4%B9%8BCSS-Hack%2F</url>
    <content type="text"><![CDATA[1. css hack 用到时进行查阅即可。 不推荐使用 123456789101112131415161718192021222324 只在IE下生效: &lt;!--[if IE]&gt; 这段文字只在IE浏览器显示 &lt;![endif]--&gt; 只在IE6下生效 &lt;!--[if IE 6]&gt; 这段文字只在IE6浏览器显示 &lt;![endif]--&gt; 只在IE6以上版本生效&lt;!--[if gte IE 6]&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]--&gt; 只在IE8上不生效&lt;!--[if ! IE 8]&gt; 这段文字在非IE8浏览器显示&lt;![endif]--&gt; 非IE浏览器生效&lt;!--[if !IE]&gt; 这段文字只在非IE浏览器显示&lt;![endif]--&gt; 2. 自定义检测低版本ie的函数 12345678910111213 &lt;script type=&quot;text/javascript&quot;&gt; console.log(isIE(8)); //js中的作用域都是函数作用域 function isIE(version)&#123; var b = document.createElement(&quot;b&quot;); b.innerHTML=&quot;&lt;!--[if IE &quot;+version+&quot;]&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;&quot;; return b.getElementsByTagName(&quot;i&quot;).length == 1 ; &#125; //伪数组: 具有length属性的js对象// console.log(document.body.getElementsByTagName(&quot;i&quot;).length); &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS2.1</category>
      </categories>
      <tags>
        <tag>css Hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS基本操作]]></title>
    <url>%2F2019%2F10%2F11%2FB-06-CSS%E4%B9%8BPS%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. PS基本操作(1)1.1 设置PS的单位为像素(px) 进入PS –&gt; 界面选项 –&gt; 单位与标尺 –&gt; 像素 –&gt; 确定 1.2 标尺 ctrl + R 出现标尺，再按标尺消失。(要先放一张图片) 1.3 辅助线 鼠标放在标尺上，往下/右拖，就会出现辅助线，不需要的话再拖回去即可。(左边要选中拖动) ctrl + H ：隐藏辅助线，再按显示。 1.4 调整图片大小 alt + 滚轮 ：放大/缩小 ctrl + 1 ：恢复到100% ctrl + 0 ：适应屏幕大小 1.5 虚线框(4种) F8 ：显示虚线框选中部分的宽高等信息 ctrl + D ：让虚线框消失]]></content>
      <categories>
        <category>前端</category>
        <category>PS</category>
      </categories>
      <tags>
        <tag>ps基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之IE兼容问题]]></title>
    <url>%2F2019%2F10%2F11%2FB-06-CSS%E4%B9%8BIE%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. IE6对图片格式png24支持度不高1.1 导致的问题 如果使用的图片格式是png24，则会导致透明效果无法正常显示。 1.2 解决方法 可以使用png8来代替png24，即可解决问题– 缺点：但是使用png8代替png24以后，图片的清晰度会有所下降。 使用JavaScript来解决该问题，需要向页面中引入一个外部的JavaScript文件，后在写一下简单的JS代码，来处理该问题。 123456&lt;!-- 在body标签的最后引入外部的JS文件 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/DD_belatedPNG_0.0.8a-min.js&quot;&gt;&lt;/script&gt;&lt;!--再创建一个新的script标签，并且编写一些js代码 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; DD_belatedPNG.fix(&quot;*&quot;);&lt;/script&gt; CSS Hack – 同方法2，代码如下： 1234&lt;!--[if IE 6]&gt; &lt;script src=&quot;js/DD_belatedPNG_0.0.8a-min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;DD_belatedPNG.fix(&apos;img&apos;);&lt;/script&gt;&lt;![endif]--&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>高度塌陷</tag>
        <tag>IE兼容问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之框架集]]></title>
    <url>%2F2019%2F10%2F11%2FB-05-CSS%E4%B9%8B%E6%A1%86%E6%9E%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[1. 框架集1.1 概述 框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面。 框架集可以同时引入多个页面，而内联框架只能引入一个，在h5标准中，推荐使用框架集，而不使用内联框架。 使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中，所以要使用框架集，页面中就不可以使用body标签。 属性： – rows，指定框架集中的所有的框架，一行一行的排列。 – cols， 指定框架集中的所有的页面，一列一列的排列。 – 这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小。 frameset中也可以再嵌套frameset。 frameset和iframe一样，它里边的内容都不会被搜索引擎所检索，所以如果搜索引擎检索到的页面是一个框架页的话，它是不能去判断里边的内容的。 使用框架集则意味着页面中不能有自己的内容，只能引入其他的页面，而每单独加载一个页面，浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求，用户的体验比较差。如果非得用建议使用frameset而不使用iframe。 演示： 123456789101112&lt;frameset cols=&quot;30% , * , 30%&quot;&gt; &lt;!-- 在frameset中使用frame子标签来指定要引入的页面 ,引入几个页面就写几个frame --&gt; &lt;frame src=&quot;01.表格.html&quot; /&gt; &lt;frame src=&quot;02.表格.html&quot; /&gt; &lt;!-- 嵌套一个frameset --&gt; &lt;frameset rows=&quot;30%,50%,*&quot;&gt; &lt;frame src=&quot;04.表格的布局.html&quot; /&gt; &lt;frame src=&quot;05.完善clearfix.html&quot; /&gt; &lt;frame src=&quot;06.表单.html&quot; /&gt; &lt;/frameset&gt;&lt;/frameset&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>框架集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见问题及解决方法]]></title>
    <url>%2F2019%2F10%2F10%2FB-00-CSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 高度塌陷1.1 塌陷原因 在文档流中，父元素的高度默认是被子元素撑开的。但是当为子元素设置浮动以后，子会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。 1.2 解决方法（均为设置塌陷元素） 清除浮动：让浮动的子元素撑开父级的高度 1. 给父级加高度 做法：直接给父级加高度: height: 100px; 缺点：扩展性不好。 2. 开启BFC 做法：触发bfc,利用浮动盒子的特点和定位盒子的特点:高宽都由内容撑开。 a.给父元素设置 overflow: hidden; b.给父元素设置 position: absolute; c.给父元素设置 float: left; 缺点： ie 6 7底下不支持BFC。 ! 其中b和c会影响页面的布局。 3. br标签 做法：在浮动的元素后面添加&lt;br clear=&quot;all&quot; /&gt;. 缺点： ie6 不支持. 违反了结构、行为、样式相分离的原则. 4. 空标签 做法1：可以直接在高度塌陷的父元素的最后，添加一个空白的div，然后再对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用。 做法2：在浮动的元素后面添加空的兄弟div,并给这个空元素设置清除浮动:&lt;div style=&quot;clear: both;&quot;&gt;\&lt;/div&gt; 缺点： 违反了结构、行为、样式相分离的原则，还会在页面中添加多余的结构。 ie6下元素的最小高度为19px(可以尝试给元素的fontsize设为0—&gt; 2px). 5. 伪元素 + 开启haslayout 做法：用伪元素after清除浮动： 给父元素设置：.clearfix:after {content: &quot;&quot;; display: block/table; clear: both;} ie6给父元素设置：.clearfix {*zoom: 1;} 缺点：因为ie6 7 下不支持伪元素,所以要额外的去开启haslayout。 详细说明：通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用 代码如下： 12345678910111213141516.clearfix:after&#123; /*添加一个内容*/ content: &quot;&quot;; /*转换为一个块元素*/ display: block; /*清除两侧的浮动*/ clear: both;&#125;/* * 在IE6中不支持after伪类, * 所以在IE6中还需要使用hasLayout来处理 */.clearfix&#123; zoom:1;&#125; 完善clearfix: 同时解决外边距重叠和高度塌陷 12345678910.clearfix:before,.clearfix:after&#123; content: &quot;&quot;; display: table; clear: both;&#125;.clearfix&#123; zoom: 1;&#125; BFC说明： 1. BFC是什么? 根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。 2. 开启元素的BFC以后，元素将会有何特性? 1.父元素的垂直外边距不会和子元素重叠 2.开启BFC的元素不会被浮动元素所覆盖 3.开启BFC的元素可以包含浮动的子元素 3. 如何开启元素的BFC？ 1.设置元素浮动 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题 2.设置元素绝对定位 与设置浮动效果相同 3.设置元素为inline-block 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 4.将元素的overflow设置为一个非visible的值 具体代码： overflow: auto; overflow: hidden; ie6代码： zoom: 1; 2. 垂直外边距重叠场景及解决办法2.1 相邻兄弟盒子垂直外边距重叠 解决方法一：在两个盒子之间加上 &lt;div style=&quot;height: 1px;&quot;&gt;&lt;/div&gt; 解决方法二：在两个盒子之间加上 &lt;br /&gt; 解决方法三：在下面的盒子外包裹一个div#wrap，并给#wrap设置overflow: hidden; 2.2 相邻父子盒子垂直外边距重叠 解决方法一：给父盒子添加上边框border: 1px solid; 解决方法二：给父盒子加上clearfix类： 12345.clearfix:before &#123; content:&quot;&quot;; display: table; clear: both;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css常见问题</tag>
        <tag>高度塌陷</tag>
        <tag>垂直外边距重叠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客搭建过程]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在b站上看了codesheep和geekmubai的视频教程（视频是Mac系统），二者结合，搭建了自己的博客（我的是Windows系统），主题及修改则是到处查着修改，比较混乱，暂时还没整理。只整理了一下搭建的过程并记录了下来，如下所示： 1.去官网安装node.js 打开命令行(win + R –&gt; cmd –&gt; 回车) C:\Users\颖&gt;npm -v （查看npm是否安装好） 6.9.0 C:\Users\颖&gt;node -v （查看node是否安装好） 10.16.0 2.安装hexo博客框架 C:\Users\颖&gt;npm install -g cnpm –registry=https://registry.npm.taobao.org (用npm安装cnpm,把镜像源指向淘宝) C:\Users\颖&gt;cnpm C:\Users\颖&gt;cnpm -v （查看cnpm是否安装好） C:\Users\颖&gt;cnpm install -g hexo-cli （用cnpm安装hexo博客框架） 3.建立一个空的blog文件夹 C:\Users\颖&gt;cd blog （进入blog文件夹里） C:\Users\颖\blog&gt;hexo init （初始化一个博客，会生成一些东西可以在命令行用dir查看） C:\Users\颖\blog&gt;hexo s （在本地启动博客） 4.把博客部署到github 在github中新建一个仓库，这个仓库的名称必须是Git名字+github.io C:\Users\颖\blog&gt;cnpm install –save hexo-deployer-git （安装一个部署插件） 5.打开blog中的_config.yml文件，用记事本打开到最底部，做如下修改： deploy:&nbsp;&nbsp;&nbsp;type: git&nbsp;&nbsp;&nbsp;repo: https://github.com/geekying/geekying.github.io.git (github中新建的仓库的地址)&nbsp;&nbsp;&nbsp;branch: master 6.去官网下载git，安装完成后在git中做如下操作： $ git config –global user.name “geekying” $ git config –global user.email “congyingw@sina.com“ $ ssh-keygen -t rsa -C “congyingw@sina.com“ -在github中新建一个密钥，内容为刚才生成的.ssh中的id_rsa.pub文件中的密钥 7.回到命令行，完成部署 C:\Users\颖\blog&gt;hexo d （hexo deploy） 8.更换主题 C:\Users\颖\blog&gt;git clone https://github.com/kjhuanhao/HEXO-HHC-NEXT （克隆一下主题） -(我换成了next主题https://github.com/kjhuanhao/HEXO-HHC-NEXT) 打开blog中的.config文件，用记事本打开到最底部，做如下修改： themes：next回到命令行 C:\Users\颖\blog&gt;hexo clean C:\Users\颖\blog&gt;hexo g (generate生成) C:\Users\颖\blog&gt;hexo s (server) C:\Users\颖\blog&gt;hexo d (deploy) 9.新建一篇博客 C:\Users\颖\blog&gt;hexo n “标题” &emsp;&emsp;在blog文件夹里找到source/_post中的markdown文件，进行内容编辑，编辑好之后重复更换主题的最后四条语句即可。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之表格和表单]]></title>
    <url>%2F2019%2F10%2F09%2FB-04-CSS%E4%B9%8B%E8%A1%A8%E6%A0%BC%E5%92%8C%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1.表格1.1 表格概述 表格的作用就是用来表示格式化的数据。 1.2 表格标签 table、tr、th、td (表格) – 在table标签中使用tr来表示表格中的一行，有几行就有几个tr。 – 在tr中需要使用td来创建一个单元格，有几个单元格就有几个td。 – th表示表头。 caption、thead、tbody、tfoot (长表格) caption表示表格的标题 thead、tbody、tfoot – thead 表格的头部、tbody 表格主体、tfoot 表格底部 – 这三个标签的作用，就来区分表格的不同的部分，他们都是table的子标签，都需要直接写到table中，tr需要写在这些标签当中。 – thead中的内容，永远会显示在表格的头；tfoot中的内容，永远都会显示表格的底部；tbody中的内容，永远都会显示表格的中间。 – 如果表格中没有写tbody，浏览器会自动在表格中添加tbody。并且将所有的tr都放到tbody中。 ！ 注意tr并不是table的子元素，而是tbody的子元素。通过table &gt; tr 无法选中， 需要通过tbody &gt; tr 1.3 合并单元格 合并单元格指将两个或两个以上的单元格合并为一个单元格。 合并单元格可以通过在th或td中设置属性来完成。 – colspan：用来设置横向的合并单元格。 – rowspan：用来设置纵向的合并单元格。 1.4 表格的样式 之前学习的很多属性都可以用来设置表格的样式，比如color可以用 来设置文本的颜色。padding可以设置内容和表格边框的距离。 width：设置表格的宽度 margin: 0 auto; 让表格居中 border：边框 background-color：设置背景样式 text-align：设置文本的水平对齐 vertical-align：设置文本的垂直对齐 – 可选值：top、baseline、middle、bottom border-spacing：边框间距 – table和td边框之间默认有一个距离通过border-spacing属性可以设置这个距离 border-collapse：合并边框 – 可选值：collapse(合并边框)、separate(不合并边框) – 如果设置了边框合并，则border-spacing自动失效。 2. 表单2.1 表单概述 现实生活中的表单是用来提交信息的。 网页中表单的作用就是用来将用户信息提交给服务器的。比如：百度的搜索框 注册 登录这些操作都需要填写表单。最常用到的表单就是baidu的搜索框。 2.2 表单项12345文本框 &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;密码框 &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;多选框 &lt;input type=&quot;checkbox&quot; name=&quot;sports&quot;&gt; 单选框 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;提交按钮 &lt;input type=&quot;submit&quot; value=&quot; 提交 &quot;&gt;下拉列表 &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;/select&gt; 2.3 表单标签 form – 使用form标签创建一个表单。 – form标签中必须指定一个 action 属性，该属性指向的是一个服务器的地址，当提交表单时将会提交到action属性对应的地址。 fieldset – 在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset中。 legend – 在fieldset可以使用legend子标签，来指定组名。 label – label标签专门用来选中表单中的提示文字的。 – 该标签可以指定一个for属性，该属性的值需要指定一个表单项的id值。 inpute input是使用的最多的表单项，它可以 根据不同的type属性呈现不同的状态。 type属性可选值： text：文本框 – 使用input来创建一个文本框，它的type属性是text。 password：密码框 – 使用input创建一个密码框，它的type属性值是password。 radio：单选按钮 – 使用input来创建一个单选按钮，它的type属性使用radio。 – 单选按钮通过name属性进行分组，name属性相同是一组按钮。 – 像这种需要用户选择但是不需要用户直接填写内容的表单项，还必须指定一个value属性，这样被选中的表单项value属性值将会最终提交给服务器。 – 如果希望在单选按钮中指定默认选中的选项，则可以在希望选中的项中添加checked=”checked”属性。 checkbox：多选框 – 使用input创建一个多选框，它的type属性使用checkbox。 – 多选框通过name属性进行分组，name属性相同是一组按钮。 – 像这种需要用户选择但是不需要用户直接填写内容的表单项，还必须指定一个value属性，这样被选中的表单项value属性值将会最终提交给服务器。 – 如果希望在多选框中指定默认选中的选项，则可以在希望选中的项中添加checked=”checked”属性。 submit：提交按钮 – 提交按钮可以将表单中的信息提交给服务器。 – 使用input创建一个提交按钮,它的type属性值是submit。 – 在提交按钮中可以通过value属性来指定按钮上的文字。 reset ：重置按钮 – 点击重置按钮以后表单中内容将会恢复为默认值。 – 使用input创建一个重置按钮,它的type属性值是reset。 – 在重置按钮中可以通过value属性来指定重置上的文字。 如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性(name表示提交内容的名字)。 用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器。url地址?查询字符串 – 查询字符串的格式：属性名=属性值&amp;属性名=属性值&amp;属性名=属性值&amp;属性名=属性值 在文本框中也可以指定value属性值，该值将会作为文本框的默认值显示。 通过修改value属性值，可以修改按钮上的文字 fieldset、legend、label (长表单) -fieldset用来为表单项进行分组。 -legend用于指定每组的名字。 -label标签用来为表单项定义描述文字。 select、option、optgroup optgroup用于为列表项分组。 option表示下拉列表中的列表项。 使用select来创建一个下拉列表。 – 下拉列表的name属性需要指定给select，而value属性需要指定给option。 – 可以通过在option中添加selected=”selected”来将选项设置为默认选中。 – 当为select添加一个multiple=”multiple”，则下拉列表变为一个多选的下拉列表。 – 在select中可以使用optgroup对选项进行分组，同一个optgroup中的选项是一组，可以通过label属性来指定分组的名字。 textarea – textarea用来创建一个文本域，实际效果和 文本框类似，只是可以输入多行数据。 – 可用属性： *cols：文本域的列数 *rows：文本域的行数 button – 也可以使用button标签来创建按钮。这种方式和使用input类似，只不过由于它是成对出现的标签，使用起来更加的灵活。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>表格</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒子模型+元素背景设置]]></title>
    <url>%2F2019%2F10%2F09%2FB-03-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2B%E5%85%83%E7%B4%A0%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 盒子模型1.1 盒子概述 CSS处理网页时，它认为每个元素都包含在一 个不可见的盒子里，这样方便布局。 1.2 盒子模型 一个盒子会分成几个部分： – 内容区(content) – 内边距(padding) – 边框(border) – 外边距(margin) 1.3 内容区 内容区指的是盒子中放置内容的区域，也就是元素中的文本内容，子元素都是存在于内容区中的。 如果没有为元素设置内边距和边框，则内容区大小默认和盒子大小是一致的。 通过width和height两个属性可以设置内容区的大小。 width和height属性只适用于块元素。 1.4 内边距 内边距指的就是元素内容区与边框以内 的空间。 默认情况下width和height不包含padding的大小。 使用padding属性来设置元素的内边距。 padding:10px 20px 30px 40px; –这样会设置元素的上、右、下、左四个方向的内边距。 padding:10px 20px 30px; –分别指定上、左右、下四个方向的内边距 padding:10px 20px; –分别指定上下、左右四个方向的内边距 padding:10px; – 同时指定上左右下四个方向的内边距 同时在css中还提供了padding-top、padding-right、paddingright、padding-bottom分别用来指定四个方向的内边距。 1.5 边框 可以在元素周围创建边框，边框是元素可见框的最外部。 可以使用border属性来设置盒子的边框： – border:1px red solid; – 上边的样式分别指定了边框的宽度、颜色和样式。 也可以使用border-top/left/right/bottom分别指定上右下左 四个方向的边框。 和padding一样，默认width和height并包括边框的宽度。 边框可以设置多种样式： – none（没有边框） – dotted（点线） – dashed（虚线） – solid（实线） – double（双线） – groove（槽线） – ridge（脊线） – inset（凹边） – outset（凸边） 1.6 外边距 外边距是元素边框与周围元素相距的空间。 使用margin属性可以设置外边距。 用法和padding类似，同样也提供了四个方向的margin-top/right/bottom/left。 当将左右外边距设置为auto时，浏览器会将左右外边距设置为相等，所以这行代码margin:0 auto可以使元素居中。2. 盒子的位置及大小相关 2.1 display 不能为行内元素设置width、height、margin-top和margin-bottom。 可以通过修改display来修改元素的性质。 可选值： – block：设置元素为块元素 – inline：设置元素为行内元素 – inline-block：设置元素为行内块元素 – none：隐藏元素（元素将在页面中完全消失） 2.2 visibility visibility属性主要用于元素是否可见。 和display不同，使用visibility隐藏一个元素，隐藏后其在文档中所占的位置会依然保持，不会被其他元素覆盖。 可选值： – visible：可见的 – hidden：隐藏的(占位) 2.3 overflow 当相关标签里面的内容超出了样式的宽度 和高度是，就会发生一些奇怪的事情，浏 览器会让内容溢出盒子。 可以通过overflow来控制内容溢出的情况。 可选值： – visible：默认值 – scroll：添加滚动条(不管是否溢出，并且水平和垂直都添加) – auto：根据需要添加滚动条 – hidden：隐藏超出盒子的内容 2.4 文档流 文档流指的是文档中可现实的对象在排列时所占用的位置。 2.5 浮动 浮动指的是使元素脱离原来的文本流，在父元素中浮动起来。 浮动使用float属性。 可选值： – none，默认值，不清除浮动。 – left，清除左侧浮动元素对当前元素的影响。 – right，清除右侧浮动元素对当前元素的影响。 – both，清除两侧浮动元素对当前元素的影响清除对他影响最大的那个元素的浮动。 块级元素和行内元素都可以浮动，当一个行内元素浮动以后将会自动变为一个块级元素。 当一个块级元素浮动以后，宽度会默认被内容撑开，所以当漂浮一个块级元素时我们都会为其指定一个宽度。 当一个元素浮动以后，其下方的元素会上移。元素中的内容将会围绕在元素的周围。- 浮动会使元素完全脱离文本流，也就是不再在文档中在占用位置。 元素设置浮动以后，会一直向上漂浮直到遇到父元素的边界或者其他 浮动元素。 元素浮动以后即完全脱离文档流，这时不会再影响父元素的高度。也就是浮动元素不会撑开父元素。 浮动元素默认会变为块元素，即使设置display:inline以后其依然是个块元素。 2.6 清除浮动 clear属性可以用于清除元素周围的浮动对元素的影响。 元素不会因为上方出现了浮动元素而改变位置。 可选值： – left：忽略左侧浮动 – right：忽略右侧浮动 – both：忽略全部浮动 – none：不忽略浮动，默认值 2.7 定位 定位：定位指的就是将指定的元素摆放到页面的任意位置，通过定位可以任意的摆放元素。 通过position属性来设置元素的定位 可选值： -static：默认值，元素没有开启定位 -relative：开启元素的相对定位 -absolute：开启元素的绝对定位 -fixed：开启元素的固定定位（也是绝对定位的一种） 当开启了元素的定位（position属性值是一个非static的值）时，可以通过left right top bottom四个属性来设置元素的偏移量– left：元素相对于其定位位置的左侧偏移量。 – right：元素相对于其定位位置的右侧偏移量。 – top：元素相对于其定位位置的上边的偏移量。 – bottom：元素相对于其定位位置下边的偏移量。 *通常偏移量只需要使用两个就可以对一个元素进行定位。一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位。 */ 2.8 相对定位 每个元素在页面的文档流中都有一个自然位置。相对于这个位置对元素进行移动就称为相对定位。周围的元素完全不受此影响。 当元素的position属性设置为relative时，则开启了元素的相对定位。 开启了相对定位以后，可以使用top、right、bottom、left四个属性对元素进行定位。 相对定位的特点: – 当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生任何变化。 – 相对定位是相对于元素在文档流中原来的位置进行定位。 – 相对定位的元素不会脱离文档流。 – 相对定位会使元素的层级提升，使元素可以覆盖文本流中的元素。 – 相对定位不会改变元素的性质，块还是块，内联还是内联 2.9 绝对定位 绝对定位指使元素相对于html元素或离他最近的祖先定位元素进行定位。 当position属性值设置为absolute时，则开启了元素的绝对定位。 开启了绝对定位以后，可以使用top、right、 bottom、left四个属性对元素进行定位。 绝对定位的特点： – 开启绝对定位，会使元素脱离文档流。 – 开启绝对定位以后，如果不设置偏移量，则元素的位置不会发生变化。 – 绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位）。如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位。 – 绝对定位会使元素提升一个层级。 – 绝对定位会改变元素的性质(内联元素变成块元素)。 – 块元素的宽度和高度默认都被内容撑开 2.10 固定定位 固定定位的元素会被锁定在屏幕的某个位置上，当访问者滚动网页时，固定元素会在屏幕上保持不动。 当将position属性设置为fixed时，则开启了元素的固定定位。 当开启了固定定位以后，可以使用top、right、bottom、left四个属性对元素进行定位。 绝对定位的特点： –固定定位也是一种绝对定位，它的大部分特点都和绝对定位一样。 –固定定位永远都会相对于浏览器窗口进行定位。 – 固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动。 – IE6不支持固定定位。 后三条是不同之处。 2.11 层级 如果定位元素的层级是一样，则下边的元素会盖住上边的。 通过z-index属性可以用来设置元素的层级。可以为z-index指定一个正整数作为值，该值将会作为当前元素的层级。 层级越高，越优先显示。(也就是z-index 值较大的元素会显示在网页的最上层) 对于没有开启定位的元素不能使用z-index。 3. css背景设置3.0 background background是背景的简写属性，通过这个属性可以一次性设置多个样式，而且样式的顺序没有要求。 例如： background: green url(img/1.jpg) no-repeat center center fixed 3.1 background-color background-color属性用来为元素设置背景颜色。 需要指定一个颜色值，当指定了一个颜色以后，整个元素的可见区域都会使用这个颜色作为背景色。 如果不设置背景颜色，元素默认背景颜色为透明，实际上会显示父元素的背景颜色。 3.2 background-image 使用background-image来设置背景图片 语法：background-image:url(相对路径); 显示规则： – 如果背景图片大于元素，默认会显示图片的左上角。 – 如果背景图片和元素一样大，则会将背景图片全部显示。 – 如果背景图片小于元素大小，则会默认将背景图片平铺以充满元素。 可以同时为一个元素指定背景颜色和背景图片 – 这样背景颜色将会作为背景图片的底色。 – 一般情况下设置背景图片时都会同时指定一个背景颜色。 3.3 background-repeat background-repeat用于设置背景图片的重复方式。 可选值：– repeat：默认值，背景图片会双方向重复（平铺）。 – no-repeat：背景图片不会重复，有多大就显示多大。 – repeat-x：背景图片沿水平方向重复。 – repeat-y：背景图片沿垂直方向重复。 如果只设置背景图片默认背景图片将会使 用平铺的方式，可以通过该属性进行修改。 3.4 background-position 通过background-position可以调整背景图片在元素中的位置(背景图片默认是贴着元素的左上角显示)。 可选值：该属性可以使用 top right left bottom center中的两个值，来指定一个背景图片的位置 – top left 左上 – bottom right 右下 – 如果只给出一个值，则第二个值默认是center 也可以直接指定两个偏移量： 第一个值是水平偏移量 – 如果指定的是一个正值，则图片会向右移动指定的像素。 – 如果指定的是一个负值，则图片会向左移动指定的像素。 第二个是垂直偏移量 – 如果指定的是一个正值，则图片会向下移动指定的像素。 – 如果指定的是一个负值，则图片会向上移动指定的像素。 可以通过三种方式来确定图片在水平方向和垂直方向的起点。 – 关键字 – 数值 – 百分比 3.5 background-attachment background-attachment用来设置背景图片是否随页面一起滚动 可选值： – scroll：默认值，背景图片随着窗口滚动。 – fixed：背景图片会固定在某一位置，不随页面滚动。 当背景图片的background-attachment设置为fixed时， 背景图片的定位永远相对于浏览器的窗口。 不随窗口滚动的图片，一般都是设置给body，而不设置给其他元素。 3.6 CSS Sprite (雪碧图) CSS Sprites是一种网页图片应用处理方式。 通过这种方式我们可以将网页中的零星图 片集中放到一张大图上。 这样一来，一次请求便可以同时加载多张 图片，大大提高了图片的加载效率。 消除按钮闪烁(闪烁会造成一次不佳的用户体验)。 产生问题的原因： – 背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求。 – 但是我们外部资源并不是同时加载，浏览器会在资源被使用才去加载资源。 – 由于加载图片需要一定的时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况。 – 为了解决该问题，可以将三个图片整合为一张图片，这样可以同时将三张图片一起加载，就不会出现闪烁的问题了。 – 然后在通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术（CSS-Sprite）。 优点： – 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片，提高访问效率，提高了用户体验。 – 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css盒子模型</tag>
        <tag>溢出</tag>
        <tag>定位</tag>
        <tag>css背景设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2019%2F10%2F09%2FB-02-CSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. css选择器选择器（selector），会告诉浏览器：网页 上的哪些元素需要设置什么样的样式。 1.1 元素选择器 元素选择器（标签选择器），可以根据标 签的名字来从页面中选取指定的元素。 语法： 标签名 { } 1.2 类选择器 类选择器，可以根据元素的class属性值选 取元素。 语法： .className { } 1.3 ID选择器 ID选择器，可以根据元素的id属性值选取元素。 语法：#id { } 1.4 复合选择器 (交集选择器) 复合选择器，可以同时使用多个选择器， 这样可以选择同时满足多个选择器的元素。 语法：选择器1选择器2{} 1.5 群组选择器(并集选择器) 群组选择器，可以同时使用多个选择器， 多个选择器将被同时应用指定的样式。 语法： 选择器1,选择器2,选择器3 { } 1.6 通用选择器 通用选择器，可以同时选中页面中的所有 元素。 语法： *{ } 1.7 后代选择器 后代选择器可以根据标签的关系，为处在 元素内部的代元素设置样式。 语法： 祖先元素 后代元素 后代元素 { } 1.8 伪类选择器有四个伪类可以根据访问者与该链接的交互方式，将链接设置成4种不同的状态。 正常链接 a:link{ } 访问过的链接 a:visited{ }（只能定义字体颜色） 鼠标滑过的链接 a:hover{ } 正在点击的链接 a:active{ } 其他伪类： 获取焦点 :focus 指定元素前 :before 指定元素后 :after 选中的元素 ::selection 1.9 伪元素选择器给段落定义样式： 首字母 :first-letter{ } 首行 :first-line{ } 1.10 属性选择器 属性选择器可以挑选带有特殊属性的标签。 语法: [属性名]{ } – 属性名可以是类名/id名等 [属性名=&quot;属性值&quot;]{ } – 属性为某个特定值的 [属性名~=&quot;属性值&quot;]{ } – 选取属性值中包含指定词汇的元素。 [属性名|=&quot;属性值&quot;]{ } – 选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [属性名^=&quot;属性值&quot;]{ } – 属性值以XXX开头 [属性名$=&quot;属性值&quot;]{ } – 属性值以XXX结尾 [属性名*=&quot;属性值&quot;]{ } – 属性值包含XXX 1.11 直接子元素选择器 子元素选择器可以给另一个元素的子元素设置样式。 语法：父元素 &gt; 子元素{} 1.12 兄弟选择器 除了根据祖先父子关系，还可以根据兄弟 关系查找元素。 语法: 查找后边一个兄弟元素 ： 兄弟元素 + 兄弟元素{} 查找后边所有的兄弟元素： 兄弟元素 ~ 兄弟元素{} 1.13 否定伪类选择器 否定伪类可以帮助我们选择不是其他东西 的某件东西。 语法: :not(选择器){} 比如： p:not(.hello)表示选择所有的p元素但 是class为hello的除外。 1.13 结构伪类选择器 #wrap ele:first-child – 选择#wrap下的第一个子元素，这个子元素必须是（ele)才可以 #wrap ele:last-child – 选择#wrap下的最后一个子元素，这个子元素必须是（ele)才可以 #wrap ele:nth-child(n) – 选择#wrap下指定位置子元素，这个子元素必须是（ele)才可以 ,n 是整数或odd(奇数位置)/even(偶数位置) #wrap ele:first-of-type 选择#wrap下指定(ele)类型的第一个子元素 #wrap ele:last-of-type 选择#wrap下指定(ele)类型的最后一个子元素 #wrap ele:nth(n)-of-type 选择#wrap下指定类型(ele)的第n个子元素 2. 选择器的权重2.1 权重概述 在页面中使用CSS选择器选中元素时，经常都是一个元素同时被多个选择器选中。如果两个选择器设置的是同一个样式则会产生冲突， 这样h1到底要应用那个样式呢？CSS中会默认使用权重较大的样式 2.2 权重的计算 不同的选择器有不同的权重值： 内联样式：权重是1000 id选择器：权重是100 类、属性、伪类选择器：权重是10 元素选择器：权重是1 通配符：权重是0 默认样式：没有权重 计算权重需要将一个样式的全部选择器相加，权重高的优先显示，权重相同的就后面的样式使用。 ！权重相加结果不会超过最大值]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css选择器</tag>
        <tag>标签关系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown常用语法]]></title>
    <url>%2F2019%2F10%2F09%2F00-markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标题 # 一级标题一级标题 ## 二级标题二级标题 ### 三级标题三级标题 #### 四级标题四级标题 ##### 五级标题五级标题 ###### 六级标题六级标题 2.列表(注意空格) * ：无序列表 + ：无序列表 - ：无序列表 ：有序列表 ：有序列表 ：有序列表3.换行 按两次回车 html中的标签br &lt;可识别的内容&gt;4.分割线 --- 连续输入三个- *** 连续输入三个* 5.超链接 [超链接名字](超链接的地址src) wcy’blog 6.粗体和斜体 *内容* ：一个*号代表 斜体 这是斜体文字 **内容** ：两个*号代表 粗体 这是粗体文字 ***内容*** ：三个*号代表 斜体+粗体 这是斜体+粗体文字 7.引用 &gt; 引用一段话 这是引用的话的示例 &lt;!–￼0–&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown常用语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2019%2F10%2F09%2FB-01-CSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. CSS简介1.1 css概述 层叠样式表 (Cascading Style Sheets) css可以用来为网页创建样式表，通过样式表可以对网页进行装饰。 1.2 基本语法 CSS的样式表由一个一个的样式构成，一个样式又由 选择器 和 声明块 构成。 语法：选择器 {样式名:样式值；样式名:样式值; } 1.3 行内样式 可以直接将样式写到标签内部的style属性中，这种样式不用填写选择器，直接编写声明即可。 &lt;p style=&quot;color: red;font-size: 30px&quot;&gt;&lt;/p&gt; 这种方式编写简单，定位准确。但是由于直接将css代码写到了html标签的内部，导 致结构与表现耦合，同时导致样式不能够 复用，所以这种方式我们不使用。 1.4 内部样式表 可以直接将样式写到&lt;style&gt;标签中。 &lt;style&gt; p{color:red; font-size: 30px;} &lt;/style&gt; 这样使css独立于html代码，而且可以同时为多个元素设置样式，这是我们使用的比较多的一种方式。 但是这种方式，样式只能在一个页面中使用，不能在多个页面中重复使用。 1.5 外部样式表 可以将所有的样式保存到一个外部的css文件中，然后通过标签将样式表引入 到文件中。 这种方式将样式表放入到了页面的外部， 可以在多个页面中引入，同时浏览器加载文件时可以使用缓存，这是我们开发中使用的最多的方式。 2. 文本格式化2.1 单位 px：对于不同的显示器来说一个像素 的大小是不同的。 百分比：也可以使用一个百分数来表示一个大小，百分比是相对于父元素来说的。 em ：em和百分比类似，也是相对于父元素说的，1em就相当于100%，2em相当于200%，1.5em相当于150%。 2.2 颜色 颜色英文单词 aqua、black、blue、fuchsia、gray、green、 lime、maroon、navy、olive、orange、 purple、red、silver、teal、white、yellow 十六进制颜色 颜色 是由指定浓度的红绿蓝混合而成的。比如：：#6600FF RGB值 –也可以使用计算机中常用的RGB值来表示 颜色。 –可以使用0255的数值，也可以使 用0%100%的百分比数。 RGB(100%,0%,0%) RGB(0,255,0) –第一个数表示红色的浓度，第二个数表示 绿色浓度，第三个数表示蓝色的浓度。 RGBA – RGBA表示一个颜色和RGB类似，只不过比 RGB多了一个A（alpha）来表示透明度， 透明度需要一个0-1的值。 RGBA(255,100,5,0.5) – 0表示完全透明， 1表示完全不透明。 2. 文字属性2.0 字体属性的简写 font可以一次性同时设置多个字体的样式。 语法：font:加粗 斜体 小型大写 大小/行高 字体 这里前边几个加粗、斜体和小型大写的顺 序无所谓，也可以不写，但是大小和字体 必须写且必须写到后两个。 2.1 文字大小 font-size用来指定文字的大小。 2.2 字体 font-family可以指定标签中文字使用的字体。 例如：p{font-family:Arial} 通过font-family可以同时指定多个字体。 例如：p{font-family:Arial , Helvetica , sans-serif} 这里面sans-serif并不是指的具体某一个字体。而是一类字体。 2.3 字体分类 serif（衬线字体） sans-serif（非衬线字体） monospace （等宽字体） cursive （草书字体） fantasy （虚幻字体） 以上这些分类都是一些大的分类，并没有 涉及具体的类型，如果将字体指定为这些 格式，浏览器会自己选择指定类型的字体。 2.4 斜体和粗体 font-style用来指定文本的斜体。 – 指定斜体：font-style:italic; – 指定非斜体：font-style:normal; font-weight用来指定文本的粗体。 – 指定粗体：font-weight:bold; – 指定非粗体：font-weight:normal; 2.5 小型大写字母 font-variant属性可以将字母类型设置为小型大写: font-variant:small-caps; 2.6 行间距 line-height用于设置行高，行高越大则行间距越大。 行间距 = line-height – font-size 2.7 大写化 text-transform样式用于将元素中的字母全都变成大小。 大写：text-transform:uppercase; 小写：text-tansform:lowercase; 首字母大写：text-transform:capitalize; 正常：text-transform:none; 2.8 文本的修饰 text-decoration属性，用来给文本添加各 种修饰。通过它可以为文本的上方、下方 或者中间添加线条。 可选值：underline / overline /line-through / none 2.9 字母间距和单词间距 letter-spacing用来设置字符之间的间距。 word-spacing用来设置单词之间的间距。 这两个属性都可以直接指定一个长度或百分数作为值。正数代表的是增加距离，而负数代表减少距离。 2.10 对齐文本 text-align用于设置文本的对齐方式。 可选值： – left：左对齐 – right：右对齐 – justify：两边对齐 – center：居中对齐 2.11 首行缩进 text-indent用来设置首行缩进。 该样式需要指定一个长度，并且只对第一行生效。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>样式表</tag>
        <tag>css基本语法</tag>
        <tag>文本格式化</tag>
        <tag>文字属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F10%2F09%2FA-01-HTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. HTML简介1.1 HTML概述 HTML(Hypertext Markup Language)：超文本标记语言。 它负责网页三要素中的结构。 HTML使用标签的的形式来标识网页中的不同组成部分。 超文本指的是超链接，使用超链接可以让我们从一个页面跳转到另一个页面。 1.2 标签 HTML中的标记指的就是标签 HTML使用标记标签来描述网页 结构： 1.&lt;标签名&gt;标签内容&lt;/标签&gt; 2.&lt;标签名 /&gt; 1.3 元素 我们还将一个完整的标签称为元素 父元素、子元素、祖先元素、后代元素 1.4 属性 通过属性为HTML元素提供附加信息。 属性需要设置在开始标签或自结束标签中。 属性总是以名称/值对的形式出现。 有些属性可以是任意值，有些则必须是指定值。 常见属性 ：id、class、tittle 1.5 注释 HTML注释中的内容不会在网页中显示。 格式: &lt;!– 注释内容 –&gt; 注释不能嵌套！ 2. HTML的发展2.1 发展历史 1993年6月：HTML第一个版本发布。 1995年11月：HTML2.0 1997年1月：HTML3.2（W3C推荐） 1999年12月：HTML4.01（W3C推荐） 2000年底：XHTML1.0（W3C推荐） 2014年10月：HTML5（W3C推荐） 2.2 doctype(文档声明)说明：不进行文档声明或者不进行正确的文档声明浏览器有可能会出现怪异模式，为避免这种情况，所以一定要进行正确的文档声明。 html4 1.过渡版:&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 2.严格版:&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 3.框架集:&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN” “http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; xhtml1.0 1.过渡版:&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “ http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 2.严格版:&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 3.框架集:&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; html5 &lt;!DOCTYPE html&gt; 3. 编码3.1 编码问题 在计算机的内部，文件都是以二进制编码 保存的。 所谓的二进制编码就是指1和0，也就是我 们的所有内容都需要转换为1和0。 中国两个字在计算机的底层保存的可能要 转换为10100101这种二进制码，这一过程 称为编码。 计算机在读取文件时需要将10100101在转 换为中国给我们显示这一过程称为解码。 3.2 字符集 字 符集规定了如何将文本转换为二进制编码。 常见的字符集：ASKII、ISO8859-1、GBK、 GB2312、UTF-8。 如果编码和解码所用的字符集不一致，就会出现乱码问题。 为了避免乱码，我们统一使用utf-8：&lt;meta charset=&quot;utf-8&quot; /&gt;。 3.3 &lt;meta&gt; meta的作用： –&lt;meta&gt; 标签可提供有关页面的元信息，比如 针对搜索引擎和更新频度的描述和关键词。 –&lt;meta&gt; 标签位于文档的头部，不包含任何内 容。&lt;meta&gt; 标签的属性定义了与文档相关联 的名称/值对。 meta的用法: – 设置页面的字符集：&lt;meta charset=&quot;utf-8&quot;&gt; – 设置网页的描述：&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; – 设置页面的关键字：&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; – 请求的重定向：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;url=地址&quot;/&gt; 4. 常用标签4.1 &lt;html&gt; 作用：&lt;html&gt;标签用于告诉浏览器这个文档中包含 的信息是用HTML编写的。 用法：所有的网页的内容都需要编写到html标签中， 一个页面中html标签只能有一个；html标签中有两个子标签head和body。 4.2 &lt;head&gt; 作用：&lt;head&gt;标签用来表示网页的元数据，head中 包含了浏览器和搜索引擎使用的其他不可见信 息。 用法： head标签作为html标签的子元素的出现，一 个网页中只能有一个head。 4.3 &lt;title&gt; 作用：&lt;title&gt;标签表示网页的标题，一般会在网页的标 题栏上显示；title标签中的文字，是页面优化的最重要因素。在 搜索引擎的搜索时最先看到的、最醒目的内容。 用法： 建议将title标签紧贴着head标签编写，这样搜索 引擎可以快速检索到标题标签； 网站中的多个页面的title也不应该重复，这样不利 于搜索隐藏检索。 4.4 &lt;body&gt; 作用：&lt;body&gt;标签用来设置网页的主体，所有在页 面中能看到的内容都应该编写到body标签中。 用法： body标签作为html的子标签使用。 4.5 &lt;h1&gt;~&lt;h6&gt; 作用：h1h6都是网页中的标题标签，用来表示网页 中的一个标题，不同的是，从h1h6重要性越 来越低； 标题标签相当于正文的标题，通常认为重要性 仅次于页面的title； 一般标题标签我们只会使用到h3，h3以后的标 题标签对于搜索引擎就没有什么意义了； 一个页面中只会使用一个h1标签。 4.6 &lt;p&gt; 作用：&lt;p&gt;标签表示网页中的一个段落； 一般浏览器会在段落的前和后各加上一个换行， 也就是段落会在页面中自成一行。 4.7 &lt;br /&gt; 作用：&lt;br /&gt;标签表示一个换行标签，使用br标签可 以使br标签后的内容另起一行。 4.8 &lt;hr /&gt; 作用：&lt;hr /&gt;标签是水平线标签，使用hr标签可以在 页面中打印一条水平线，水平线可以将页面分 成上下两个部分。 4.9 &lt;img /&gt; 作用：&lt; img /&gt;标签是图片标签，可以用来向页面中 引入一张外部的图片。 属性： src • 指向一个外部的图片的路径；alt • 图片的描述 4.10 &lt;a&gt; 作用：标签是超链接标签，通过a标签，可以快 速跳转到其他页面。 属性：href • 指向一个链接地址；– target • 设置打开目标页面的位置(可选值：_blank新窗口、 _self当前窗口)。 5. 实体(转义字符)5.1 实体 在HTML中预留了一些字符，这些预留字符是不能在网页中直接使用的。 比如&lt;和&gt;,我们不能直接在页面中使用&lt;和 &gt;号，因为浏览器会将它解析为html标签 为了可以使用这些预留字符，我们必须在 html中使用字符实体。 语法: &amp;实体名; 5.2 实体字符 小于号&lt; : &amp;lt; 大于号&gt; : &amp;gt; 空格 : &amp;nbsp; 和符号&amp; : &amp;amp 版权© : &amp;copy; 引号” : &amp;quot; 注册商标® : &amp;reg;商标™ : &amp;trade; 6. 开发工具6.1 文本编辑器 记事本 Notepad++(免费) Sublime(收费) 6.2 IDE(集成开发工具) DreamWeaver（收费） WebStorm（收费） Hbuilder（免费） 7. 文本标签7.1 &lt;em&gt;和&lt;strong&gt; em标签用于表示一段内容中的着重点。 strong标签用于表示一个内容的重要性。 通常em显示为斜体，而strong显示为粗体；这两个标签可以单独使用，也可以一起使用。 7.2 &lt;i&gt;和&lt;b&gt; i标签会使文字变成斜体。 b标签会使文字变成粗体。 这两个标签和em和strong类似，但是这两个标签没有语义。 所以根据html5标准，当我们只想设置文本 特殊显示，而不需要强调内容时就可以使 用i和b标签。 7.3 &lt;small&gt; small标签表示细则一类的旁注，通常包括 免责声明、注意事项、法律限制、版权信 息等。 浏览器在显示small标签时会显示一个比父 元素小的字号。 7.4 &lt;cite&gt; 使用cite标签(《》)可以指明对某内容的引用或参 考。例如，戏剧、文章或图书的标题，歌 曲、电影、照片或雕塑的名称等。 7.5 &lt;blockquote&gt;和&lt;q&gt; blockquote和q表示标记引用的文本。 blockquote用于长引用(“”)，q用于短引用。 在两个标签中还可以使用cite属性来表示引用的地址。 7.6 &lt;sup&gt;和&lt;sub&gt; sup和sub用于定义上标和下标 7.7 &lt;ins&gt;和&lt;del&gt; ins表示插入的内容，显示时通常会加上下划线。 del表示删除的内容，显示时通常会加上删除线。 7.8 &lt;code&gt;和&lt;pre&gt; 如果你的内容包含代码示例或文件名，就 可以使用code元素。 pre元素表示的是预格式化文本，可以使用 pre包住code来表示一段代码。 7.9 有序列表 使用ol和li来创建一个有序列表。 7.10 无序列表 使用ul和li来创建一个有序列表。 7.9 定义列表 使用dl、dd、dt来创建一个定义列表。 12345678&lt;dl&gt; &lt;dt&gt;定义项1&lt;/dt&gt; &lt;dd&gt;定义描述1&lt;/dd&gt; &lt;dt&gt;定义项2&lt;/dt&gt; &lt;dd&gt;定义描述2&lt;/dd&gt; &lt;dt&gt;定义项3&lt;/dt&gt; &lt;dd&gt;定义描述3&lt;/dd&gt; &lt;/dl&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
        <category>HTML基础</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html的发展</tag>
        <tag>html标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java循环语句语]]></title>
    <url>%2F2019%2F10%2F08%2F03-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[1. switch语句1.1 switch语句结构（掌握） 格式 123456789101112switch (表达式) &#123; case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程： 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 1.2 switch语句练习-春夏秋冬（应用） 需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。 运行结果： 1234春：3、4、5夏：6、7、8秋：9、10、11冬：1、2、12 示例代码： 123456789101112131415161718192021222324252627282930313233public class Demo1 &#123; public static void main(String[] args) &#123; //键盘录入月份数据，使用变量接收 Scanner sc = new Scanner(System.in); System.out.println("请输入一个月份："); int month = sc.nextInt(); //case穿透 switch(month) &#123; case 1: case 2: case 12: System.out.println("冬季"); break; case 3: case 4: case 5: System.out.println("春季"); break; case 6: case 7: case 8: System.out.println("夏季"); break; case 9: case 10: case 11: System.out.println("秋季"); break; default: System.out.println("你输入的月份有误"); &#125; &#125;&#125; 注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。 2. for循环2.1 for循环结构（掌握） 循环： 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 for循环格式： 123for (初始化语句;条件判断语句;条件控制语句) &#123; 循环体语句;&#125; 格式解释： 初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去 循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去 执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 2.2 for循环练习-输出数据（应用） 需求：在控制台输出1-5和5-1的数据 示例代码： 12345678910111213public class ForTest01 &#123; public static void main(String[] args) &#123; //需求：输出数据1-5 for(int i=1; i&lt;=5; i++) &#123; System.out.println(i); &#125; System.out.println("--------"); //需求：输出数据5-1 for(int i=5; i&gt;=1; i--) &#123; System.out.println(i); &#125; &#125;&#125; 2.3 for循环练习-求和（应用） 需求：求1-5之间的数据和，并把求和结果在控制台输出 示例代码： 12345678910111213141516171819202122public class ForTest02 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //从1开始到5结束的数据，使用循环结构完成 for(int i=1; i&lt;=5; i++) &#123; //将反复进行的事情写入循环结构内部 // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中 sum += i; /* sum += i; sum = sum + i; 第一次：sum = sum + i = 0 + 1 = 1; 第二次：sum = sum + i = 1 + 2 = 3; 第三次：sum = sum + i = 3 + 3 = 6; 第四次：sum = sum + i = 6 + 4 = 10; 第五次：sum = sum + i = 10 + 5 = 15; */ &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println("1-5之间的数据和是：" + sum); &#125;&#125; 本题要点： 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的 2.4 for循环练习-求偶数和（应用） 需求：求1-100之间的偶数和，并把求和结果在控制台输出 } 示例代码： 123456789101112131415public class ForTest03 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同 for(int i=1; i&lt;=100; i++) &#123; //对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数 if(i%2 == 0) &#123; sum += i; &#125; &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println("1-100之间的偶数和是：" + sum); &#125;&#125; 2.5 for循环练习-水仙花（应用） 需求：在控制台输出所有的“水仙花数” 解释：什么是水仙花数？ 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数 例如153 3*3*3 + 5*5*5 + 1*1*1 = 153 思路： 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数 示例代码 1234567891011121314151617public class ForTest04 &#123; public static void main(String[] args) &#123; //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i=100; i&lt;1000; i++) &#123; //在计算之前获取三位数中每个位上的值 int ge = i%10; int shi = i/10%10; int bai = i/10/10%10; //判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等 if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123; //输出满足条件的数字就是水仙花数 System.out.println(i); &#125; &#125; &#125;&#125; 2.6 for循环练习-统计水仙花数个数（应用） 需求：统计“水仙花数”一共有多少个，并在控制台输出个数 示例代码： 12345678910111213141516171819public class ForTest05 &#123; public static void main(String[] args) &#123; //定义变量count，用于保存“水仙花数”的数量，初始值为0 int count = 0; //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i=100; i&lt;1000; i++) &#123; //在计算之前获取三位数中每个位上的值 int ge = i%10; int shi = i/10%10; int bai = i/10/10%10; //在判定水仙花数的过程中，满足条件不再输出，更改为修改count的值，使count+1 if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123; count++; &#125; &#125; //打印输出最终结果 System.out.println("水仙花共有：" + count + "个"); &#125;&#125; 本题要点： 今后如果需求带有统计xxx，请先想到计数器变量 计数器变量定义的位置，必须在循环外部 3. while循环3.1 while结构（掌握） while循环完整格式： 12345初始化语句;while (条件判断语句) &#123; 循环体语句; 条件控制语句;&#125; while循环执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 示例代码： 12345678910111213141516public class WhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次"HelloWorld" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println("HelloWorld"); &#125; System.out.println("--------"); //while循环实现 int j = 1; while(j&lt;=5) &#123; System.out.println("HelloWorld"); j++; &#125; &#125;&#125; 3.2 while循环练习-珠穆朗玛峰（应用） 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度? 示例代码： 1234567891011121314151617181920public class WhileTest &#123; public static void main(String[] args) &#123; //定义一个计数器，初始值为0 int count = 0; //定义纸张厚度 double paper = 0.1; //定义珠穆朗玛峰的高度 int zf = 8844430; //因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环 //折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度 while(paper &lt;= zf) &#123; //循环的执行过程中每次纸张折叠，纸张的厚度要加倍 paper *= 2; //在循环中执行累加，对应折叠了多少次 count++; &#125; //打印计数器的值 System.out.println("需要折叠：" + count + "次"); &#125;&#125; 4. 循环细节4.1 do…while循环结构（掌握） 完整格式： 12345初始化语句;do &#123; 循环体语句; 条件控制语句;&#125;while(条件判断语句); 执行流程： ① 执行初始化语句 ② 执行循环体语句 ③ 执行条件控制语句 ④ 执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行 ⑤ 回到②继续 示例代码： 12345678910111213141516public class DoWhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次"HelloWorld" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println("HelloWorld"); &#125; System.out.println("--------"); //do...while循环实现 int j = 1; do &#123; System.out.println("HelloWorld"); j++; &#125;while(j&lt;=5); &#125;&#125; 4.2 三种循环的区别（理解） 三种循环的区别 for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行） do…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断） for循环和while的区别 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用 死循环（无限循环）的三种格式 for(;;){} while(true){} do {} while(true); 4.3 跳转控制语句（掌握） 跳转控制语句（break） 跳出循环，结束循环 跳转控制语句（continue） 跳过本次循环，继续下次循环 注意： continue只能在循环中进行使用！ 4.4 循环嵌套（理解） 循环嵌套概述：在循环中，继续定义循环 示例代码： 123456789public static void main(String[] args) &#123; //外循环控制小时的范围，内循环控制分钟的范围 for (int hour = 0; hour &lt; 24; hour++) &#123; for (int minute = 0; minute &lt; 60; minute++) &#123; System.out.println(hour + "时" + minute + "分"); &#125; System.out.println("--------"); &#125; &#125; 理解： 请反复理解这句话（整个内循环，就是外循环的一个循环体，内部循环体没有执行完毕，外循环是不会继续向下执行的） 结论： 外循环执行一次，内循环执行一圈 5. Random5.1 Random产生随机数（掌握） 概述： Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能 API后续课程详细讲解，现在可以简单理解为Java已经写好的代码 使用步骤： 导入包 import java.util.Random; 创建对象 Random r = new Random(); 产生随机数 int num = r.nextInt(10); 解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19 示例代码： 12345678910111213141516import java.util.Random;public class RandomDemo &#123; public static void main(String[] args) &#123; //创建对象 Random r = new Random(); //用循环获取10个随机数 for(int i=0; i&lt;10; i++) &#123; //获取随机数 int number = r.nextInt(10); System.out.println("number:" + number); &#125; //需求：获取一个1-100之间的随机数 int x = r.nextInt(100) + 1; System.out.println(x); &#125;&#125; 5.3 Random练习-猜数字（应用） 需求： 程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 A. 如果猜的数字比真实数字大，提示你猜的数据大了 B. 如果猜的数字比真实数字小，提示你猜的数据小了 C. 如果猜的数字与真实数字相等，提示恭喜你猜中了 示例代码： 123456789101112131415161718192021222324252627282930import java.util.Random;import java.util.Scanner;public class RandomTest &#123; public static void main(String[] args) &#123; //要完成猜数字的游戏，首先需要有一个要猜的数字，使用随机数生成该数字，范围1到100 Random r = new Random(); int number = r.nextInt(100) + 1; while(true) &#123; //使用程序实现猜数字，每次均要输入猜测的数字值，需要使用键盘录入实现 Scanner sc = new Scanner(System.in); System.out.println("请输入你要猜的数字："); int guessNumber = sc.nextInt(); //比较输入的数字和系统产生的数据，需要使用分支语句。 //这里使用if..else..if..格式，根据不同情况进行猜测结果显示 if(guessNumber &gt; number) &#123; System.out.println("你猜的数字" + guessNumber + "大了"); &#125; else if(guessNumber &lt; number) &#123; System.out.println("你猜的数字" + guessNumber + "小了"); &#125; else &#123; System.out.println("恭喜你猜中了"); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>流程控制语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础语法02]]></title>
    <url>%2F2019%2F10%2F08%2F02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java基础语法1. 运算符1.1 算术运算符（理解）1.1.1 运算符和表达式运算符：对常量或者变量进行操作的符号 表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。 ​ 不同运算符连接的表达式体现的是不同类型的表达式。 举例说明： 123int a = 10;int b = 20;int c = a + b; +：是运算符，并且是算术运算符。 a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。 1.1.2 算术运算符 符号 作用 说明 + 加 参看小学一年级 - 减 参看小学一年级 * 乘 参看小学二年级，与“×”相同 / 除 参看小学二年级，与“÷”相同 % 取余 获取的是两个数据做除法的余数 注意： /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。 1234int a = 10;int b = 3;System.out.println(a / b); // 输出结果3System.out.println(a % b); // 输出结果1 1.1.3 字符的“+”操作char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值： ‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加 ‘A’ – 65 A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加 ‘0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加 123456789// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少char ch1 = 'a';System.out.println(ch1 + 1); // 输出98，97 + 1 = 98char ch2 = 'A';System.out.println(ch2 + 1); // 输出66，65 + 1 = 66char ch3 = '0';System.out.println(ch3 + 1); // 输出49，48 + 1 = 49 算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。 提升规则： byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。 整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型 ​ 等级顺序：byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double 例如： 123456789byte b1 = 10;byte b2 = 20;// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度int i3 = b1 + b2; // 应该使用int接收byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型-------------------------------int num1 = 10;double num2 = 20.0;double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型 tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。 1.1.4 字符串的“+”操作当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。 1System.out.println("itheima"+ 666); // 输出：itheima666 在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。 1234System.out.println(1 + 99 + "年黑马"); // 输出：199年黑马System.out.println(1 + 2 + "itheima" + 3 + 4); // 输出：3itheima34// 可以使用小括号改变运算的优先级 System.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7 1.2 赋值运算符（应用）赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。 符号 作用 说明 = 赋值 a=10，将10赋值给变量a += 加后赋值 a+=b，将a+b的值给a -= 减后赋值 a-=b，将a-b的值给a *= 乘后赋值 a*=b，将a×b的值给a /= 除后赋值 a/=b，将a÷b的商给a %= 取余后赋值 a%=b，将a÷b的余数给a 注意： 扩展的赋值运算符隐含了强制类型转换。 1234short s = 10;s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10); 1.3 自增自减运算符（理解） 符号 作用 说明 ++ 自增 变量的值加1 – 自减 变量的值减1 注意事项： ​ ++和– 既可以放在变量的后边，也可以放在变量的前边。 ​ 单独使用的时候， ++和– 无论是放在变量的前边还是后边，结果是一样的。 ​ 参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者–。 ​ 参与操作的时候，如果放在变量的前边，先拿变量做++或者–，后拿变量参与操作。 ​ 最常见的用法：单独使用。 123456789101112131415int i = 10;i++; // 单独使用System.out.println("i:" + i); // i:11int j = 10;++j; // 单独使用System.out.println("j:" + j); // j:11int x = 10;int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1System.out.println("x:" + x + ", y:" + y); // x:11，y:10int m = 10;int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1System.out.println("m:" + m + ", m:" + m); // m:11，m:11 练习： 123456789int x = 10;int y = x++ + x++ + x++;System.out.println(y); // y的值是多少？/*解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。所以整个式子应该是：int y = 10 + 11 + 12;输出结果为33。*/注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！ 1.4 关系运算符（应用）关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。 符号 说明 == a==b，判断a和b的值是否相等，成立为true，不成立为false != a!=b，判断a和b的值是否不相等，成立为true，不成立为false &gt; a&gt;b，判断a是否大于b，成立为true，不成立为false &gt;= a&gt;=b，判断a是否大于等于b，成立为true，不成立为false &lt; a&lt;b，判断a是否小于b，成立为true，不成立为false &lt;= a&lt;=b，判断a是否小于等于b，成立为true，不成立为false 注意事项： ​ 关系运算符的结果都是boolean类型，要么是true，要么是false。 ​ 千万不要把“==”误写成“=”，”==”是判断是否相等的关系，”=”是赋值。 123456789101112int a = 10;int b = 20;System.out.println(a == b); // falseSystem.out.println(a != b); // trueSystem.out.println(a &gt; b); // falseSystem.out.println(a &gt;= b); // falseSystem.out.println(a &lt; b); // trueSystem.out.println(a &lt;= b); // true// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量boolean flag = a &gt; b;System.out.println(flag); // 输出false 1.5 逻辑运算符（应用）逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。 符号 作用 说明 &amp; 逻辑与 a&amp;b，a和b都是true，结果为true，否则为false | 逻辑或 a|b，a和b都是false，结果为false，否则为true ^ 逻辑异或 a^b，a和b结果不同为true，相同为false ! 逻辑非 !a，结果和a的结果正好相反 1234567891011121314151617181920212223242526272829//定义变量int i = 10;int j = 20;int k = 30;//&amp; “与”，并且的关系，只要表达式中有一个值为false，结果即为falseSystem.out.println((i &gt; j) &amp; (i &gt; k)); //false &amp; false,输出falseSystem.out.println((i &lt; j) &amp; (i &gt; k)); //true &amp; false,输出falseSystem.out.println((i &gt; j) &amp; (i &lt; k)); //false &amp; true,输出falseSystem.out.println((i &lt; j) &amp; (i &lt; k)); //true &amp; true,输出trueSystem.out.println("--------");//| “或”，或者的关系，只要表达式中有一个值为true，结果即为trueSystem.out.println((i &gt; j) | (i &gt; k)); //false | false,输出falseSystem.out.println((i &lt; j) | (i &gt; k)); //true | false,输出trueSystem.out.println((i &gt; j) | (i &lt; k)); //false | true,输出trueSystem.out.println((i &lt; j) | (i &lt; k)); //true | true,输出trueSystem.out.println("--------");//^ “异或”，相同为false，不同为trueSystem.out.println((i &gt; j) ^ (i &gt; k)); //false ^ false,输出falseSystem.out.println((i &lt; j) ^ (i &gt; k)); //true ^ false,输出trueSystem.out.println((i &gt; j) ^ (i &lt; k)); //false ^ true,输出trueSystem.out.println((i &lt; j) ^ (i &lt; k)); //true ^ true,输出falseSystem.out.println("--------");//! “非”，取反System.out.println((i &gt; j)); //falseSystem.out.println(!(i &gt; j)); //!false，,输出true 短路逻辑运算符 符号 作用 说明 &amp;&amp; 短路与 作用和&amp;相同，但是有短路效果 || 短路或 作用和|相同，但是有短路效果 在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。 逻辑与&amp;，无论左边真假，右边都要执行。 短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。 逻辑或|，无论左边真假，右边都要执行。 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。 123456789int x = 3;int y = 4;System.out.println((x++ &gt; 4) &amp; (y++ &gt; 5)); // 两个表达都会运算System.out.println(x); // 4System.out.println(y); // 5System.out.println((x++ &gt; 4) &amp;&amp; (y++ &gt; 5)); // 左边已经可以确定结果为false，右边不参与运算System.out.println(x); // 4System.out.println(y); // 4 1.6 三元运算符（理解）三元运算符语法格式： 1关系表达式 ? 表达式1 : 表达式2; 解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。 举例： 123int a = 10;int b = 20;int c = a &gt; b ? a : b; // 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值 三元运算符案例： 1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。 1234567891011public class OperatorTest01 &#123; public static void main(String[] args) &#123; //1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。 int weight1 = 180; int weight2 = 200; //2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。 boolean b = weight1 == weight2 ? true : false; //3：输出结果 System.out.println("b:" + b); &#125;&#125; 2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。 1234567891011121314public class OperatorTest02 &#123; public static void main(String[] args) &#123; //1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。 int height1 = 150; int height2 = 210; int height3 = 165; //2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。 int tempHeight = height1 &gt; height2 ? height1 : height2; //3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。 int maxHeight = tempHeight &gt; height3 ? tempHeight : height3; //4：输出结果 System.out.println("maxHeight:" + maxHeight); &#125;&#125; 2. 数据输入（应用）我们可以通过 Scanner 类来获取用户的输入。使用步骤如下： 1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。 1import java.util.Scanner; 2、创建Scanner对象。 1Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变 3、接收数据 1int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。 示例： 1234567891011import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; //创建对象 Scanner sc = new Scanner(System.in); //接收数据 int x = sc.nextInt(); //输出数据 System.out.println("x:" + x); &#125;&#125; 改写三个和尚案例，数据使用键盘录入。 1234567891011121314151617181920import java.util.Scanner;public class ScannerTest &#123; public static void main(String[] args) &#123; //身高未知，采用键盘录入实现。首先导包，然后创建对象。 Scanner sc = new Scanner(System.in); //键盘录入三个身高分别赋值给三个变量。 System.out.println("请输入第一个和尚的身高："); int height1 = sc.nextInt(); System.out.println("请输入第二个和尚的身高："); int height2 = sc.nextInt(); System.out.println("请输入第三个和尚的身高："); int height3 = sc.nextInt(); //用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。 int tempHeight = height1 &gt; height2 ? height1 : height2; //用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。 int maxHeight = tempHeight &gt; height3 ? tempHeight : height3; //输出结果。 System.out.println("这三个和尚中身高最高的是：" + maxHeight +"cm"); &#125;&#125; 3. 流程控制语句（应用）在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。 3.1 流程控制语句分类​ 顺序结构 ​ 分支结构(if, switch) ​ 循环结构(for, while, do…while) 3.2 顺序结构顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。 顺序结构执行流程图： 3.3 分支结构之if语句if语句格式11234格式：if (关系表达式) &#123; 语句体; &#125; 执行流程： ①首先计算关系表达式的值 ②如果关系表达式的值为true就执行语句体 ③如果关系表达式的值为false就不执行语句体 ④继续执行后面的语句内容 示例： 123456789101112131415161718public class IfDemo &#123; public static void main(String[] args) &#123; System.out.println("开始"); //定义两个变量 int a = 10; int b = 20; //需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b if(a == b) &#123; System.out.println("a等于b"); &#125; //需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c int c = 10; if(a == c) &#123; System.out.println("a等于c"); &#125; System.out.println("结束"); &#125;&#125; if语句格式2123456格式：if (关系表达式) &#123; 语句体1; &#125; else &#123; 语句体2; &#125; 执行流程： ①首先计算关系表达式的值 ②如果关系表达式的值为true就执行语句体1 ③如果关系表达式的值为false就执行语句体2 ④继续执行后面的语句内容 示例： 12345678910111213141516public class IfDemo02 &#123; public static void main(String[] args) &#123; System.out.println("开始"); //定义两个变量 int a = 10; int b = 20; b = 5; //需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b if(a &gt; b) &#123; System.out.println("a的值大于b"); &#125; else &#123; System.out.println("a的值不大于b"); &#125; System.out.println("结束"); &#125;&#125; if语句案例：奇偶数 需求：任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。 分析： ​ ①为了体现任意给出一个整数，采用键盘录入一个数据 ​ ②判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构 ​ ③判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0 ​ ④根据判定情况，在控制台输出对应的内容 1234567891011121314151617import java.util.Scanner;public class IfTest01 &#123; public static void main(String[] args) &#123; //为了体现任意给出一个整数，采用键盘录入一个数据。(导包，创建对象，接收数据) Scanner sc = new Scanner(System.in); System.out.println("请输入一个整数："); int number = sc.nextInt(); //判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构 //判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0 //根据判定情况，在控制台输出对应的内容 if(number%2 == 0) &#123; System.out.println(number + "是偶数"); &#125; else &#123; System.out.println(number + "是奇数"); &#125; &#125;&#125; if语句格式312345678910格式：if (关系表达式1) &#123; 语句体1; &#125; else if (关系表达式2) &#123; 语句体2; &#125; …else &#123; 语句体n+1;&#125; 执行流程： ①首先计算关系表达式1的值 ②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值 ③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值 ④… ⑤如果没有任何关系表达式为true，就执行语句体n+1。 示例：键盘录入一个星期数(1,2,…7)，输出对应的星期一，星期二，…星期日 1234567891011121314151617181920212223242526import java.util.Scanner;public class IfDemo03 &#123; public static void main(String[] args) &#123; System.out.println("开始"); // 需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日 Scanner sc = new Scanner(System.in); System.out.println("请输入一个星期数(1-7)："); int week = sc.nextInt(); if(week == 1) &#123; System.out.println("星期一"); &#125; else if(week == 2) &#123; System.out.println("星期二"); &#125; else if(week == 3) &#123; System.out.println("星期三"); &#125; else if(week == 4) &#123; System.out.println("星期四"); &#125; else if(week == 5) &#123; System.out.println("星期五"); &#125; else if(week == 6) &#123; System.out.println("星期六"); &#125; else &#123; System.out.println("星期日"); &#125; System.out.println("结束"); &#125;&#125; if语句格式3案例： 需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。 分析： ​ ①小明的考试成绩未知，可以使用键盘录入的方式获取值 ​ ②由于奖励种类较多，属于多种判断，采用if…else…if格式实现 ​ ③为每种判断设置对应的条件 ​ ④为每种判断设置对应的奖励 123456789101112131415161718192021222324import java.util.Scanner;public class IfTest02 &#123; public static void main(String[] args) &#123; //小明的考试成绩未知，可以使用键盘录入的方式获取值 Scanner sc = new Scanner(System.in); System.out.println("请输入一个分数："); int score = sc.nextInt(); //由于奖励种类较多，属于多种判断，采用if...else...if格式实现 //为每种判断设置对应的条件 //为每种判断设置对应的奖励 //数据测试：正确数据，边界数据，错误数据 if(score&gt;100 || score&lt;0) &#123; System.out.println("你输入的分数有误"); &#125; else if(score&gt;=95 &amp;&amp; score&lt;=100) &#123; System.out.println("山地自行车一辆"); &#125; else if(score&gt;=90 &amp;&amp; score&lt;=94) &#123; System.out.println("游乐场玩一次"); &#125; else if(score&gt;=80 &amp;&amp; score&lt;=89) &#123; System.out.println("变形金刚玩具一个"); &#125; else &#123; System.out.println("胖揍一顿"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>流程控制语句</tag>
        <tag>Path环境变量</tag>
        <tag>java基础语法</tag>
        <tag>运算符</tag>
        <tag>数据输入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础语法01]]></title>
    <url>%2F2019%2F10%2F08%2F01-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. Java概述1.1 Java语言发展史（了解）语言：人与人交流沟通的表达方式 计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言 Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言 Java之父：詹姆斯·高斯林（James Gosling） 2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：https://www.oracle.com 当前，我们课程使用的JDK版本：11.0 1.2 Java语言跨平台原理（理解）Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。 1.3 JRE和JDK（记忆）JVM（Java Virtual Machine），Java虚拟机 JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API） JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具 总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。 1.4 JDK的下载和安装（应用）1.4.1 下载通过官方网站获取JDK http://www.oracle.com 注意：针对不同的操作系统，需要下载对应版本的JDK。 具体下载步骤请参见《JDK下载及安装说明文档》 1.4.2 安装傻瓜式安装，下一步即可。但默认的安装路径是在C:\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\develop。 注意：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。 具体安装步骤请参见《JDK下载及安装说明文档》 1.4.3 JDK的安装目录介绍 目录名称 说明 bin 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 conf 该路径下存放了JDK的相关配置文件。 include 该路径下存放了一些平台特定的头文件。 jmods 该路径下存放了JDK的各种模块。 legal 该路径下存放了JDK各模块的授权文档。 lib 该路径下存放了JDK工具的一些补充JAR包。 2. 第一个演示程序2.1 常用DOS命令（应用）在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。 1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。 2、常用命令及其作用 操作 说明 盘符名称: 盘符切换。E:回车，表示切换到E盘。 dir 查看当前路径下的内容。 cd 目录 进入单级目录。cd itheima cd .. 回退到上一级目录。 cd 目录1\目录2... 进入多级目录。cd itheima\JavaSE cd \ 回退到盘符目录。 cls 清屏。 exit 退出命令提示符窗口。 2.2 Path环境变量的配置（应用）2.2.1 为什么配置环境变量开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以配置环境变量的作用就是可以使bin目录下的java相关命令可以在任意目录下使用。 2.2.2 配置环境变量步骤具体配置步骤请参见《Java环境变量配置说明》文档。 2.3 HelloWorld案例（应用）HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。各种计算机语言都习惯使用该案例作为第一个演示案例。 2.3.1 Java程序开发运行流程开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。 2.3.2 HelloWorld案例的编写1、新建文本文档文件，修改名称为HelloWorld.java。 2、用记事本打开HelloWorld.java文件，输写程序内容。 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; 2.3.3 HelloWorld案例的编译和运行存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。 编译：javac 文件名.java 范例：javac HelloWorld.java 执行：java 类名 范例：java HelloWorld 2.4 HelloWorld案例常见问题（理解）2.4.1 BUG在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。 2.4.2 BUG的解决1、具备识别BUG的能力：多看 2、具备分析BUG的能力：多思考，多查资料 3、具备解决BUG的能力：多尝试，多总结 2.4.3 HelloWorld案例常见问题1、非法字符问题。Java中的符号都是英文格式的。 2、大小写问题。Java语言对大小写敏感（区分大小写）。 3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。 4、编译命令后的java文件名需要带文件后缀.java 5、运行命令后的class文件名（类名）不带文件后缀.class … 2.5 Notepad++软件的安装和使用（应用）2.5.1 什么要使用Notepad++软件Notepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。 2.5.2 Notepad++软件安装安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\develop。 具体安装步骤请参见《Nodepad++软件安装及配置说明》文档。 2.5.3Notepad++软件配置安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。 具体配置的说明请参见《Nodepad++软件安装及配置说明》文档。 3. java基础语法3.1 注释（理解）注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种： 单行注释。单行注释的格式是使用//，从//开始至本行结尾的文字将作为注释文字。 1// 这是单行注释文字 多行注释。多行注释的格式是使用/* 和 */将一段较长的注释括起来。 123456/*这是多行注释文字这是多行注释文字这是多行注释文字*/注意：多行注释不能嵌套使用。 文档注释。文档注释以/**开始，以*/结束。（以后讲） 3.2 关键字（理解）关键字是指被java语言赋予了特殊含义的单词。 关键字的特点： ​ 关键字的字母全部小写。 ​ 常用的代码编辑器对关键字都有高亮显示，比如现在我们能看到的public、class、static等。 3.3 常量（应用）常量：在程序运行过程中，其值不可以发生改变的量。 Java中的常量分类： ​ 字符串常量 用双引号括起来的多个字符（可以包含0个、一个或多个），例如”a”、”abc”、”中国”等 ​ 整数常量 整数，例如：-10、0、88等 ​ 小数常量 小数，例如：-5.5、1.0、88.88等 ​ 字符常量 用单引号括起来的一个字符，例如：’a’、’5’、’B’、’中’等 ​ 布尔常量 布尔值，表示真假，只有两个值true和false ​ 空常量 一个特殊的值，空值，值为null 除空常量外，其他常量均可使用输出语句直接输出。 123456789public class Demo &#123; public static void main(String[] args) &#123; System.out.println(10); // 输出一个整数 System.out.println(5.5); // 输出一个小数 System.out.println('a'); // 输出一个字符 System.out.println(true); // 输出boolean值true System.out.println("欢迎来到黑马程序员"); // 输出字符串 &#125;&#125; 3.4 数据类型（记忆、应用）3.4.1 计算机存储单元我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”， 通常用大写字母”B”表示，字节是由连续的8个位组成。 除了字节外还有一些常用的存储单位，其换算单位如下： 1B（字节） = 8bit 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 3.4.2 Java中的数据类型Java是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。 Java中的基本数据类型： 数据类型 关键字 内存占用 取值范围 整数类型 byte 1 -128~127 short 2 -32768~32767 int(默认) 4 -2的31次方到2的31次方-1 long 8 -2的63次方到2的63次方-1 浮点类型 float 4 负数：-3.402823E+38到-1.401298E-45 正数： 1.401298E-45到3.402823E+38 double(默认) 8 负数：-1.797693E+308到-4.9000000E-324 正数：4.9000000E-324 到1.797693E+308 字符类型 char 2 0-65535 布尔类型 boolean 1 true，false 说明： ​ e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。 ​ 在java中整数默认是int类型，浮点数默认是double类型。 3.5 变量（应用）3.5.1 变量的定义变量：在程序运行过程中，其值可以发生改变的量。 从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。 变量的定义格式： 123数据类型 变量名 = 初始化值; // 声明变量并赋值int age = 18;System.out.println(age); 或者 123456// 先声明，后赋值（使用前赋值即可）数据类型 变量名;变量名 = 初始化值;double money;money = 55.5;System.out.println(money); 还可以在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。 123456789int a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开System.out.println(a);System.out.println(b);int c,d; // 声明int类型的变量c和d，中间使用逗号隔开c = 30;d = 40;System.out.println(c);System.out.println(d); 变量的使用：通过变量名访问即可。 3.5.2 使用变量时的注意事项 在同一对花括号中，变量名不能重复。 变量在使用之前，必须初始化（赋值）。 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。 3.6 标识符（记忆、理解）标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。 Java中标识符的组成规则： ​ 由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。 ​ 不能使用java中的关键字作为标识符。 ​ 标识符对大小写敏感（区分大小写）。 Java中标识符的命名约定： ​ 小驼峰式命名：变量名、方法名 ​ 首字母小写，从第二个单词开始每个单词的首字母大写。 ​ 大驼峰式命名：类名 ​ 每个单词的首字母都大写。 ​ 另外，标识符的命名最好可以做到见名知意 ​ 例如：username、studentNumber等。 3.7 类型转换（理解）在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。 自动类型转换： ​ 把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如： 12double num = 10; // 将int类型的10直接赋值给double类型System.out.println(num); // 输出10.0 强制类型转换： ​ 把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。 ​ 强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量; ​ 例如： 123double num1 = 5.5;int num2 = (int) num1; // 将double类型的num1强制转换为int类型System.out.println(num2); // 输出5（小数位直接舍弃） 说明： char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，’a’对应97。 12int a = 'a';System.out.println(a); // 将输出97 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。 12345678byte b1 = 10;byte b2 = 20;byte b3 = b1 + b2; // 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。// 修改为:int num = b1 + b2;// 或者：byte b3 = (byte) (b1 + b2); boolean类型不能与其他基本数据类型相互转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java发展</tag>
        <tag>JRE和JDK</tag>
        <tag>DOS命令</tag>
        <tag>Path环境变量</tag>
        <tag>java基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
